package edu.cmu.sv.kelinci.instrumentor;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Set;

import org.apache.commons.io.IOUtils;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;


/**
 * @author rodykers
 *
 * Instrumentation component of Kelinci. Adds AFL style instrumentation to a JAVA
 * program, plus the Kelinci 'javaside' component.
 */
public class Instrumentor {

	public static ClassLoader classloader;

	public static void main(String[] args) {

		// get class loader
		classloader = Thread.currentThread().getContextClassLoader();

		// parse command line arguments
		Options options = Options.v();
		CmdLineParser parser = new CmdLineParser(options);
		try {
			parser.parseArgument(args);
		} catch (CmdLineException e) {
			parser.printUsage(System.err);
			return;
		}

		// load all classes to instrument (instrument library classes?)
		Set<String> inputClasses = Options.v().getInput();

		Set<String> skipped = new HashSet<>();

		ClassTransformer transformer = new ClassTransformer();

		for (String cls : inputClasses) {
			// System.out.println("Instrumenting class: " + cls);

			String className = cls.substring(0, cls.lastIndexOf(".class"));

			try {
				byte[] bytes = transformer.instrumentClass(className);
				writeClass(cls, bytes);
			} catch (RuntimeException rte) {
				throw rte;
			}

		}

		// add Kelinci classes
		String[] resources = {
				"edu/cmu/sv/kelinci/Kelinci.class",
				"edu/cmu/sv/kelinci/Kelinci$1.class",
				"edu/cmu/sv/kelinci/Kelinci$2.class",
				"edu/cmu/sv/kelinci/Kelinci$3.class",
				"edu/cmu/sv/kelinci/Kelinci$ApplicationCall.class",
				"edu/cmu/sv/kelinci/Kelinci$FuzzRequest.class",
				"edu/cmu/sv/kelinci/Kelinci$NullOutputStream.class",
				"edu/cmu/sv/kelinci/Mem.class",
				"edu/cmu/sv/kelinci/quantification/PartitionSet.class",
				"edu/cmu/sv/kelinci/quantification/Partition.class",
				"edu/cmu/sv/kelinci/quantification/Pair.class",
                "edu/cmu/sv/kelinci/quantification/KDynamic.class",
                "edu/cmu/sv/kelinci/quantification/Greedy.class",
                "edu/cmu/sv/kelinci/quantification/PartitionAlgorithm.class",
                "edu/cmu/sv/kelinci/quantification/PartitionAlgorithmByIndex.class"
				};
		for (String resource : resources) {
			loadAndWriteResource(resource);
		}

		if (skipped.size() > 0) {
			System.out.println("\nWARNING!!! Instrumentation of some classes has been skipped.");
			System.out.println("This is due to the JSR/RET bytecode construct that is not supported by ASM.");
			System.out.println("It is deprecated and should not be present in bytecode generated by a recent compiler.");
			System.out.println("If this is your code, try using a different compiler.");
			System.out.println("If this is a library, there might be not too much harm in skipping instrumentation of these classes.");
			System.out.println("Classes that were skipped:");
			for (String cls : skipped)
				System.out.println(cls);
		}
	}

	private static void writeClass(String cls, byte[] bytes) {
		if (Options.v().outputJar()) {
			JarFileIO.v().addFileToJar(cls, bytes);
		} else {
			String s = cls.substring(0, cls.lastIndexOf(".class")).
					replace('.', '/') + ".class";
			String path = Options.v().getOutput().endsWith("/") ?
					Options.v().getOutput() + s :
						Options.v().getOutput() + "/" + s;
			Path out = Paths.get(path);
			try {
				Files.createDirectories(out.getParent());
				Files.write(out, bytes);
				System.out.println("File written: " + path);
			} catch (IOException e) {
				System.err.println("Error writing to file: " + path);
				e.printStackTrace();
			}
		}
	}

	private static void loadAndWriteResource(String resource) {
		InputStream is = classloader.getResourceAsStream(resource);
		if (is == null) {
			System.err.println("Error loading Kelinci classes for addition to output");
			return;
		}
		byte[] rbytes;
		try {
			rbytes = IOUtils.toByteArray(is);
		} catch (IOException e) {
			System.err.println("Error loading Kelinci classes for addition to output");
			e.printStackTrace();
			return;
		}
		writeClass(resource, rbytes);
	}

}
