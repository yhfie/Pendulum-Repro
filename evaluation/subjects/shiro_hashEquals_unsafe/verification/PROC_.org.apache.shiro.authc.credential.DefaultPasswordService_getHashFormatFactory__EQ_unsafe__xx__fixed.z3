(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :produce-models true)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 20000000)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun javaTypeType () T@T)
(declare-fun fixed.java.lang.Object () T@U)
(declare-fun fixed.org.apache.shiro.authc.credential.HashingPasswordService () T@U)
(declare-fun fixed.org.apache.shiro.authc.credential.DefaultPasswordService () T@U)
(declare-fun oneStep (T@U T@U) T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.DefaultHashService () T@U)
(declare-fun refType () T@T)
(declare-fun fixed.$StringConst0 () T@U)
(declare-fun fixed.java.io.Serializable () T@U)
(declare-fun fixed.java.lang.Comparable () T@U)
(declare-fun fixed.java.lang.CharSequence () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.Hash () T@U)
(declare-fun fixed.java.lang.Throwable () T@U)
(declare-fun fixed.java.lang.Exception () T@U)
(declare-fun fixed.java.lang.RuntimeException () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.HashFormat () T@U)
(declare-fun fixed.org.apache.shiro.util.ByteSource () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.HashRequest () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.HashService () T@U)
(declare-fun fixed.java.lang.ClassCastException () T@U)
(declare-fun fixed.sg.edu.nus.comp.tsunami.safe.Safe () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat () T@U)
(declare-fun fixed.org.slf4j.Logger () T@U)
(declare-fun fixed.java.lang.Appendable () T@U)
(declare-fun fixed.java.lang.AbstractStringBuilder () T@U)
(declare-fun fixed.$StringConst1 () T@U)
(declare-fun fixed.java.lang.reflect.AnnotatedElement () T@U)
(declare-fun fixed.java.lang.reflect.GenericDeclaration () T@U)
(declare-fun fixed.java.lang.reflect.Type () T@U)
(declare-fun fixed.$StringConst2 () T@U)
(declare-fun fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat () T@U)
(declare-fun fixed.$StringConst3 () T@U)
(declare-fun fixed.$StringConst4 () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.HashRequest$Builder () T@U)
(declare-fun fixed.org.apache.shiro.util.ByteSource$Util () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory () T@U)
(declare-fun fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService () T@U)
(declare-fun fixed.org.slf4j.LoggerFactory () T@U)
(declare-fun fixed.java.lang.StringBuilder () T@U)
(declare-fun fixed.java.lang.String () T@U)
(declare-fun fixed.java.lang.NullPointerException () T@U)
(declare-fun fixed.java.lang.IndexOutOfBoundsException () T@U)
(declare-fun fixed.java.lang.ArrayIndexOutOfBoundsException () T@U)
(declare-fun fixed.java.lang.Boolean () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun fixed.$type () T@U)
(declare-fun fixed.$alloc () T@U)
(declare-fun fixed.$null () T@U)
(declare-fun fixed.$intToBool (Int) Bool)
(declare-fun fixed.$refToBool (T@U) Bool)
(declare-fun fixed.$boolToInt (Bool) Int)
(declare-fun fixed.$cmpReal (Real Real) Int)
(declare-fun fixed.$cmpInt (Int Int) Int)
(declare-fun fixed.$intToRef (Int) T@U)
(declare-fun inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 () T@U)
(declare-fun inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 () T@U)
(declare-fun MapType0Type (T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U T@U) T@U)
(declare-fun fixed.$heap () T@U)
(declare-fun MapType1Type (T@T T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1TypeInv1 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun fixed.$arrSizeHeap () T@U)
(declare-fun fixed.$stringSizeHeap () T@U)
(declare-fun $this () T@U)
(declare-fun inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0 () T@U)
(declare-fun fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory$org.apache.shiro.authc.credential.DefaultPasswordService$hashFormatFactory263 () T@U)
(declare-fun inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0 () T@U)
(declare-fun %lbl%+1924611 () Bool)
(declare-fun AA_TEMP280@1 () Bool)
(declare-fun AA_TEMP280@0 () Bool)
(declare-fun AA_TEMP281@1 () Bool)
(declare-fun AA_TEMP281@0 () Bool)
(declare-fun %lbl%@1944002 () Bool)
(declare-fun %lbl%+1924610 () Bool)
(declare-fun %lbl%+1924609 () Bool)
(declare-fun %lbl%+1924608 () Bool)
(declare-fun %lbl%+1924607 () Bool)
(declare-fun %lbl%+1924606 () Bool)
(declare-fun %lbl%+1924605 () Bool)
(declare-fun %lbl%+1924604 () Bool)
(declare-fun %lbl%+1924603 () Bool)
(declare-fun %lbl%+1924602 () Bool)
(declare-fun %lbl%+1924601 () Bool)
(declare-fun %lbl%+1943671 () Bool)
(declare-fun %lbl%+1943676 () Bool)
(assert  (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0)
 :qid |typeInv:U_2_int|
 :pattern ( (int_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
 :qid |cast:U_2_int|
 :pattern ( (U_2_int x))
))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType)
 :qid |funType:int_2_U|
 :pattern ( (int_2_U arg0@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :qid |typeInv:U_2_real|
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))
 :qid |cast:U_2_real|
 :pattern ( (U_2_real x@@0))
))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType)
 :qid |funType:real_2_U|
 :pattern ( (real_2_U arg0@@2))
))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
 :qid |typeInv:U_2_bool|
 :pattern ( (bool_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))
 :qid |cast:U_2_bool|
 :pattern ( (U_2_bool x@@1))
))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType)
 :qid |funType:bool_2_U|
 :pattern ( (bool_2_U arg0@@4))
))))
(assert (forall ((x@@2 T@U) ) (! (UOrdering2 x@@2 x@@2)
 :qid |bg:subtype-refl|
 :no-pattern (U_2_int x@@2)
 :no-pattern (U_2_bool x@@2)
)))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@3)))
 (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z)))
 :qid |bg:subtype-trans|
 :pattern ( (UOrdering2 x@@3 y) (UOrdering2 y z))
)))
(assert (forall ((x@@4 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@4)))
 (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0))))
 :qid |bg:subtype-antisymm|
 :pattern ( (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4))
)))
(assert  (and (= (Ctor javaTypeType) 3) (= (type fixed.java.lang.Object) javaTypeType)))
(assert (forall ((w T@U) ) (!  (=> (and (= (type w) javaTypeType) (UOrdering2 fixed.java.lang.Object w)) (= fixed.java.lang.Object w))
 :pattern ( (UOrdering2 fixed.java.lang.Object w))
)))
(assert (= (type fixed.org.apache.shiro.authc.credential.HashingPasswordService) javaTypeType))
(assert (forall ((w@@0 T@U) ) (!  (=> (and (= (type w@@0) javaTypeType) (UOrdering2 fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@0)) (= fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@0))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@0))
)))
(assert (= (type fixed.org.apache.shiro.authc.credential.DefaultPasswordService) javaTypeType))
(assert (not (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService fixed.java.lang.Object)))
(assert (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService fixed.java.lang.Object))
(assert (not (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService fixed.org.apache.shiro.authc.credential.HashingPasswordService)))
(assert (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService fixed.org.apache.shiro.authc.credential.HashingPasswordService))
(assert (forall ((w@@1 T@U) ) (!  (=> (= (type w@@1) javaTypeType) (=> (and (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@1) (UOrdering2 w@@1 fixed.java.lang.Object)) (or (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@1) (= fixed.java.lang.Object w@@1))))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@1) (UOrdering2 w@@1 fixed.java.lang.Object))
)))
(assert (forall ((w@@2 T@U) ) (!  (=> (= (type w@@2) javaTypeType) (=> (and (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@2) (UOrdering2 w@@2 fixed.org.apache.shiro.authc.credential.HashingPasswordService)) (or (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@2) (= fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@2))))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@2) (UOrdering2 w@@2 fixed.org.apache.shiro.authc.credential.HashingPasswordService))
)))
(assert (forall ((w@@3 T@U) ) (!  (=> (and (= (type w@@3) javaTypeType) (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@3)) (or (or (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@3) (UOrdering2 fixed.java.lang.Object w@@3)) (UOrdering2 fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@3)))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@3))
)))
(assert (forall ((arg0@@5 T@U) (arg1 T@U) ) (! (= (type (oneStep arg0@@5 arg1)) javaTypeType)
 :qid |funType:oneStep|
 :pattern ( (oneStep arg0@@5 arg1))
)))
(assert (forall ((w@@4 T@U) ) (!  (=> (and (= (type w@@4) javaTypeType) (UOrdering2 w@@4 fixed.org.apache.shiro.authc.credential.DefaultPasswordService)) (= (oneStep fixed.java.lang.Object w@@4) fixed.org.apache.shiro.authc.credential.DefaultPasswordService))
 :pattern ( (UOrdering2 w@@4 fixed.org.apache.shiro.authc.credential.DefaultPasswordService))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.DefaultHashService) javaTypeType))
(assert (forall ((w@@5 T@U) ) (!  (=> (and (= (type w@@5) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.DefaultHashService w@@5)) (= fixed.org.apache.shiro.crypto.hash.DefaultHashService w@@5))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.DefaultHashService w@@5))
)))
(assert  (and (= (Ctor refType) 4) (= (type fixed.$StringConst0) refType)))
(assert (forall ((w@@6 T@U) ) (!  (=> (and (= (type w@@6) refType) (UOrdering2 fixed.$StringConst0 w@@6)) (= fixed.$StringConst0 w@@6))
 :pattern ( (UOrdering2 fixed.$StringConst0 w@@6))
)))
(assert (= (type fixed.java.io.Serializable) javaTypeType))
(assert (forall ((w@@7 T@U) ) (!  (=> (and (= (type w@@7) javaTypeType) (UOrdering2 fixed.java.io.Serializable w@@7)) (= fixed.java.io.Serializable w@@7))
 :pattern ( (UOrdering2 fixed.java.io.Serializable w@@7))
)))
(assert (= (type fixed.java.lang.Comparable) javaTypeType))
(assert (forall ((w@@8 T@U) ) (!  (=> (and (= (type w@@8) javaTypeType) (UOrdering2 fixed.java.lang.Comparable w@@8)) (= fixed.java.lang.Comparable w@@8))
 :pattern ( (UOrdering2 fixed.java.lang.Comparable w@@8))
)))
(assert (= (type fixed.java.lang.CharSequence) javaTypeType))
(assert (forall ((w@@9 T@U) ) (!  (=> (and (= (type w@@9) javaTypeType) (UOrdering2 fixed.java.lang.CharSequence w@@9)) (= fixed.java.lang.CharSequence w@@9))
 :pattern ( (UOrdering2 fixed.java.lang.CharSequence w@@9))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat) javaTypeType))
(assert (forall ((w@@10 T@U) ) (!  (=> (and (= (type w@@10) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat w@@10)) (= fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat w@@10))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat w@@10))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory) javaTypeType))
(assert (forall ((w@@11 T@U) ) (!  (=> (and (= (type w@@11) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory w@@11)) (= fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory w@@11))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory w@@11))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.Hash) javaTypeType))
(assert (forall ((w@@12 T@U) ) (!  (=> (and (= (type w@@12) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.Hash w@@12)) (= fixed.org.apache.shiro.crypto.hash.Hash w@@12))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.Hash w@@12))
)))
(assert (= (type fixed.java.lang.Throwable) javaTypeType))
(assert (not (= fixed.java.lang.Throwable fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.lang.Object))
(assert (not (= fixed.java.lang.Throwable fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.io.Serializable))
(assert (forall ((w@@13 T@U) ) (!  (=> (= (type w@@13) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@13) (UOrdering2 w@@13 fixed.java.lang.Object)) (or (= fixed.java.lang.Throwable w@@13) (= fixed.java.lang.Object w@@13))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@13) (UOrdering2 w@@13 fixed.java.lang.Object))
)))
(assert (forall ((w@@14 T@U) ) (!  (=> (= (type w@@14) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@14) (UOrdering2 w@@14 fixed.java.io.Serializable)) (or (= fixed.java.lang.Throwable w@@14) (= fixed.java.io.Serializable w@@14))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@14) (UOrdering2 w@@14 fixed.java.io.Serializable))
)))
(assert (forall ((w@@15 T@U) ) (!  (=> (and (= (type w@@15) javaTypeType) (UOrdering2 fixed.java.lang.Throwable w@@15)) (or (or (= fixed.java.lang.Throwable w@@15) (UOrdering2 fixed.java.lang.Object w@@15)) (UOrdering2 fixed.java.io.Serializable w@@15)))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@15))
)))
(assert (forall ((w@@16 T@U) ) (!  (=> (and (= (type w@@16) javaTypeType) (UOrdering2 w@@16 fixed.java.lang.Throwable)) (= (oneStep fixed.java.lang.Object w@@16) fixed.java.lang.Throwable))
 :pattern ( (UOrdering2 w@@16 fixed.java.lang.Throwable))
)))
(assert (= (type fixed.java.lang.Exception) javaTypeType))
(assert (not (= fixed.java.lang.Exception fixed.java.lang.Throwable)))
(assert (UOrdering2 fixed.java.lang.Exception fixed.java.lang.Throwable))
(assert (forall ((w@@17 T@U) ) (!  (=> (= (type w@@17) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Exception w@@17) (UOrdering2 w@@17 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Exception w@@17) (= fixed.java.lang.Throwable w@@17))))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@17) (UOrdering2 w@@17 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@18 T@U) ) (!  (=> (and (= (type w@@18) javaTypeType) (UOrdering2 fixed.java.lang.Exception w@@18)) (or (= fixed.java.lang.Exception w@@18) (UOrdering2 fixed.java.lang.Throwable w@@18)))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@18))
)))
(assert (forall ((w@@19 T@U) ) (!  (=> (and (= (type w@@19) javaTypeType) (UOrdering2 w@@19 fixed.java.lang.Exception)) (= (oneStep fixed.java.lang.Throwable w@@19) fixed.java.lang.Exception))
 :pattern ( (UOrdering2 w@@19 fixed.java.lang.Exception))
)))
(assert (= (type fixed.java.lang.RuntimeException) javaTypeType))
(assert (not (= fixed.java.lang.RuntimeException fixed.java.lang.Exception)))
(assert (UOrdering2 fixed.java.lang.RuntimeException fixed.java.lang.Exception))
(assert (forall ((w@@20 T@U) ) (!  (=> (= (type w@@20) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.RuntimeException w@@20) (UOrdering2 w@@20 fixed.java.lang.Exception)) (or (= fixed.java.lang.RuntimeException w@@20) (= fixed.java.lang.Exception w@@20))))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@20) (UOrdering2 w@@20 fixed.java.lang.Exception))
)))
(assert (forall ((w@@21 T@U) ) (!  (=> (and (= (type w@@21) javaTypeType) (UOrdering2 fixed.java.lang.RuntimeException w@@21)) (or (= fixed.java.lang.RuntimeException w@@21) (UOrdering2 fixed.java.lang.Exception w@@21)))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@21))
)))
(assert (forall ((w@@22 T@U) ) (!  (=> (and (= (type w@@22) javaTypeType) (UOrdering2 w@@22 fixed.java.lang.RuntimeException)) (= (oneStep fixed.java.lang.Exception w@@22) fixed.java.lang.RuntimeException))
 :pattern ( (UOrdering2 w@@22 fixed.java.lang.RuntimeException))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.format.HashFormat) javaTypeType))
(assert (forall ((w@@23 T@U) ) (!  (=> (and (= (type w@@23) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.HashFormat w@@23)) (= fixed.org.apache.shiro.crypto.hash.format.HashFormat w@@23))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.HashFormat w@@23))
)))
(assert (= (type fixed.org.apache.shiro.util.ByteSource) javaTypeType))
(assert (forall ((w@@24 T@U) ) (!  (=> (and (= (type w@@24) javaTypeType) (UOrdering2 fixed.org.apache.shiro.util.ByteSource w@@24)) (= fixed.org.apache.shiro.util.ByteSource w@@24))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.util.ByteSource w@@24))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.HashRequest) javaTypeType))
(assert (forall ((w@@25 T@U) ) (!  (=> (and (= (type w@@25) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashRequest w@@25)) (= fixed.org.apache.shiro.crypto.hash.HashRequest w@@25))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashRequest w@@25))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.HashService) javaTypeType))
(assert (forall ((w@@26 T@U) ) (!  (=> (and (= (type w@@26) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashService w@@26)) (= fixed.org.apache.shiro.crypto.hash.HashService w@@26))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashService w@@26))
)))
(assert (= (type fixed.java.lang.ClassCastException) javaTypeType))
(assert (not (= fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException))
(assert (forall ((w@@27 T@U) ) (!  (=> (= (type w@@27) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ClassCastException w@@27) (UOrdering2 w@@27 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.ClassCastException w@@27) (= fixed.java.lang.RuntimeException w@@27))))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@27) (UOrdering2 w@@27 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@28 T@U) ) (!  (=> (and (= (type w@@28) javaTypeType) (UOrdering2 fixed.java.lang.ClassCastException w@@28)) (or (= fixed.java.lang.ClassCastException w@@28) (UOrdering2 fixed.java.lang.RuntimeException w@@28)))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@28))
)))
(assert (forall ((w@@29 T@U) ) (!  (=> (and (= (type w@@29) javaTypeType) (UOrdering2 w@@29 fixed.java.lang.ClassCastException)) (= (oneStep fixed.java.lang.RuntimeException w@@29) fixed.java.lang.ClassCastException))
 :pattern ( (UOrdering2 w@@29 fixed.java.lang.ClassCastException))
)))
(assert (= (type fixed.sg.edu.nus.comp.tsunami.safe.Safe) javaTypeType))
(assert (not (= fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object)))
(assert (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object))
(assert (forall ((w@@30 T@U) ) (!  (=> (= (type w@@30) javaTypeType) (=> (and (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@30) (UOrdering2 w@@30 fixed.java.lang.Object)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@30) (= fixed.java.lang.Object w@@30))))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@30) (UOrdering2 w@@30 fixed.java.lang.Object))
)))
(assert (forall ((w@@31 T@U) ) (!  (=> (and (= (type w@@31) javaTypeType) (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@31)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@31) (UOrdering2 fixed.java.lang.Object w@@31)))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@31))
)))
(assert (forall ((w@@32 T@U) ) (!  (=> (and (= (type w@@32) javaTypeType) (UOrdering2 w@@32 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= (oneStep fixed.java.lang.Object w@@32) fixed.sg.edu.nus.comp.tsunami.safe.Safe))
 :pattern ( (UOrdering2 w@@32 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat) javaTypeType))
(assert (forall ((w@@33 T@U) ) (!  (=> (and (= (type w@@33) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat w@@33)) (= fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat w@@33))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat w@@33))
)))
(assert (= (type fixed.org.slf4j.Logger) javaTypeType))
(assert (forall ((w@@34 T@U) ) (!  (=> (and (= (type w@@34) javaTypeType) (UOrdering2 fixed.org.slf4j.Logger w@@34)) (= fixed.org.slf4j.Logger w@@34))
 :pattern ( (UOrdering2 fixed.org.slf4j.Logger w@@34))
)))
(assert (= (type fixed.java.lang.Appendable) javaTypeType))
(assert (forall ((w@@35 T@U) ) (!  (=> (and (= (type w@@35) javaTypeType) (UOrdering2 fixed.java.lang.Appendable w@@35)) (= fixed.java.lang.Appendable w@@35))
 :pattern ( (UOrdering2 fixed.java.lang.Appendable w@@35))
)))
(assert (= (type fixed.java.lang.AbstractStringBuilder) javaTypeType))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.Object))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.Appendable)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.Appendable))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.CharSequence)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.CharSequence))
(assert (forall ((w@@36 T@U) ) (!  (=> (= (type w@@36) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@36) (UOrdering2 w@@36 fixed.java.lang.Object)) (or (= fixed.java.lang.AbstractStringBuilder w@@36) (= fixed.java.lang.Object w@@36))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@36) (UOrdering2 w@@36 fixed.java.lang.Object))
)))
(assert (forall ((w@@37 T@U) ) (!  (=> (= (type w@@37) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@37) (UOrdering2 w@@37 fixed.java.lang.Appendable)) (or (= fixed.java.lang.AbstractStringBuilder w@@37) (= fixed.java.lang.Appendable w@@37))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@37) (UOrdering2 w@@37 fixed.java.lang.Appendable))
)))
(assert (forall ((w@@38 T@U) ) (!  (=> (= (type w@@38) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@38) (UOrdering2 w@@38 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.AbstractStringBuilder w@@38) (= fixed.java.lang.CharSequence w@@38))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@38) (UOrdering2 w@@38 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@39 T@U) ) (!  (=> (and (= (type w@@39) javaTypeType) (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@39)) (or (or (or (= fixed.java.lang.AbstractStringBuilder w@@39) (UOrdering2 fixed.java.lang.Object w@@39)) (UOrdering2 fixed.java.lang.Appendable w@@39)) (UOrdering2 fixed.java.lang.CharSequence w@@39)))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@39))
)))
(assert (forall ((w@@40 T@U) ) (!  (=> (and (= (type w@@40) javaTypeType) (UOrdering2 w@@40 fixed.java.lang.AbstractStringBuilder)) (= (oneStep fixed.java.lang.Object w@@40) fixed.java.lang.AbstractStringBuilder))
 :pattern ( (UOrdering2 w@@40 fixed.java.lang.AbstractStringBuilder))
)))
(assert (= (type fixed.$StringConst1) refType))
(assert (forall ((w@@41 T@U) ) (!  (=> (and (= (type w@@41) refType) (UOrdering2 fixed.$StringConst1 w@@41)) (= fixed.$StringConst1 w@@41))
 :pattern ( (UOrdering2 fixed.$StringConst1 w@@41))
)))
(assert (= (type fixed.java.lang.reflect.AnnotatedElement) javaTypeType))
(assert (forall ((w@@42 T@U) ) (!  (=> (and (= (type w@@42) javaTypeType) (UOrdering2 fixed.java.lang.reflect.AnnotatedElement w@@42)) (= fixed.java.lang.reflect.AnnotatedElement w@@42))
 :pattern ( (UOrdering2 fixed.java.lang.reflect.AnnotatedElement w@@42))
)))
(assert (= (type fixed.java.lang.reflect.GenericDeclaration) javaTypeType))
(assert (not (= fixed.java.lang.reflect.GenericDeclaration fixed.java.lang.reflect.AnnotatedElement)))
(assert (UOrdering2 fixed.java.lang.reflect.GenericDeclaration fixed.java.lang.reflect.AnnotatedElement))
(assert (forall ((w@@43 T@U) ) (!  (=> (= (type w@@43) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.reflect.GenericDeclaration w@@43) (UOrdering2 w@@43 fixed.java.lang.reflect.AnnotatedElement)) (or (= fixed.java.lang.reflect.GenericDeclaration w@@43) (= fixed.java.lang.reflect.AnnotatedElement w@@43))))
 :pattern ( (UOrdering2 fixed.java.lang.reflect.GenericDeclaration w@@43) (UOrdering2 w@@43 fixed.java.lang.reflect.AnnotatedElement))
)))
(assert (forall ((w@@44 T@U) ) (!  (=> (and (= (type w@@44) javaTypeType) (UOrdering2 fixed.java.lang.reflect.GenericDeclaration w@@44)) (or (= fixed.java.lang.reflect.GenericDeclaration w@@44) (UOrdering2 fixed.java.lang.reflect.AnnotatedElement w@@44)))
 :pattern ( (UOrdering2 fixed.java.lang.reflect.GenericDeclaration w@@44))
)))
(assert (= (type fixed.java.lang.reflect.Type) javaTypeType))
(assert (forall ((w@@45 T@U) ) (!  (=> (and (= (type w@@45) javaTypeType) (UOrdering2 fixed.java.lang.reflect.Type w@@45)) (= fixed.java.lang.reflect.Type w@@45))
 :pattern ( (UOrdering2 fixed.java.lang.reflect.Type w@@45))
)))
(assert (= (type fixed.$StringConst2) refType))
(assert (forall ((w@@46 T@U) ) (!  (=> (and (= (type w@@46) refType) (UOrdering2 fixed.$StringConst2 w@@46)) (= fixed.$StringConst2 w@@46))
 :pattern ( (UOrdering2 fixed.$StringConst2 w@@46))
)))
(assert (= (type fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat) refType))
(assert (forall ((w@@47 T@U) ) (!  (=> (and (= (type w@@47) refType) (UOrdering2 fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat w@@47)) (= fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat w@@47))
 :pattern ( (UOrdering2 fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat w@@47))
)))
(assert (= (type fixed.$StringConst3) refType))
(assert (forall ((w@@48 T@U) ) (!  (=> (and (= (type w@@48) refType) (UOrdering2 fixed.$StringConst3 w@@48)) (= fixed.$StringConst3 w@@48))
 :pattern ( (UOrdering2 fixed.$StringConst3 w@@48))
)))
(assert (= (type fixed.$StringConst4) refType))
(assert (forall ((w@@49 T@U) ) (!  (=> (and (= (type w@@49) refType) (UOrdering2 fixed.$StringConst4 w@@49)) (= fixed.$StringConst4 w@@49))
 :pattern ( (UOrdering2 fixed.$StringConst4 w@@49))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.HashRequest$Builder) javaTypeType))
(assert (forall ((w@@50 T@U) ) (!  (=> (and (= (type w@@50) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashRequest$Builder w@@50)) (= fixed.org.apache.shiro.crypto.hash.HashRequest$Builder w@@50))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.HashRequest$Builder w@@50))
)))
(assert (= (type fixed.org.apache.shiro.util.ByteSource$Util) javaTypeType))
(assert (forall ((w@@51 T@U) ) (!  (=> (and (= (type w@@51) javaTypeType) (UOrdering2 fixed.org.apache.shiro.util.ByteSource$Util w@@51)) (= fixed.org.apache.shiro.util.ByteSource$Util w@@51))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.util.ByteSource$Util w@@51))
)))
(assert (= (type fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory) javaTypeType))
(assert (forall ((w@@52 T@U) ) (!  (=> (and (= (type w@@52) javaTypeType) (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory w@@52)) (= fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory w@@52))
 :pattern ( (UOrdering2 fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory w@@52))
)))
(assert (= (type fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService) refType))
(assert (forall ((w@@53 T@U) ) (!  (=> (and (= (type w@@53) refType) (UOrdering2 fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService w@@53)) (= fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService w@@53))
 :pattern ( (UOrdering2 fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService w@@53))
)))
(assert (= (type fixed.org.slf4j.LoggerFactory) javaTypeType))
(assert (forall ((w@@54 T@U) ) (!  (=> (and (= (type w@@54) javaTypeType) (UOrdering2 fixed.org.slf4j.LoggerFactory w@@54)) (= fixed.org.slf4j.LoggerFactory w@@54))
 :pattern ( (UOrdering2 fixed.org.slf4j.LoggerFactory w@@54))
)))
(assert (= (type fixed.java.lang.StringBuilder) javaTypeType))
(assert (not (= fixed.java.lang.StringBuilder fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.StringBuilder fixed.java.lang.Object))
(assert (forall ((w@@55 T@U) ) (!  (=> (= (type w@@55) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.StringBuilder w@@55) (UOrdering2 w@@55 fixed.java.lang.Object)) (or (= fixed.java.lang.StringBuilder w@@55) (= fixed.java.lang.Object w@@55))))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@55) (UOrdering2 w@@55 fixed.java.lang.Object))
)))
(assert (forall ((w@@56 T@U) ) (!  (=> (and (= (type w@@56) javaTypeType) (UOrdering2 fixed.java.lang.StringBuilder w@@56)) (or (= fixed.java.lang.StringBuilder w@@56) (UOrdering2 fixed.java.lang.Object w@@56)))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@56))
)))
(assert (forall ((w@@57 T@U) ) (!  (=> (and (= (type w@@57) javaTypeType) (UOrdering2 w@@57 fixed.java.lang.StringBuilder)) (= (oneStep fixed.java.lang.Object w@@57) fixed.java.lang.StringBuilder))
 :pattern ( (UOrdering2 w@@57 fixed.java.lang.StringBuilder))
)))
(assert (= (type fixed.java.lang.String) javaTypeType))
(assert (not (= fixed.java.lang.String fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.Object))
(assert (forall ((w@@58 T@U) ) (!  (=> (= (type w@@58) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@58) (UOrdering2 w@@58 fixed.java.lang.Object)) (or (= fixed.java.lang.String w@@58) (= fixed.java.lang.Object w@@58))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@58) (UOrdering2 w@@58 fixed.java.lang.Object))
)))
(assert (forall ((w@@59 T@U) ) (!  (=> (and (= (type w@@59) javaTypeType) (UOrdering2 fixed.java.lang.String w@@59)) (or (= fixed.java.lang.String w@@59) (UOrdering2 fixed.java.lang.Object w@@59)))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@59))
)))
(assert (forall ((w@@60 T@U) ) (!  (=> (and (= (type w@@60) javaTypeType) (UOrdering2 w@@60 fixed.java.lang.String)) (= (oneStep fixed.java.lang.Object w@@60) fixed.java.lang.String))
 :pattern ( (UOrdering2 w@@60 fixed.java.lang.String))
)))
(assert (= (type fixed.java.lang.NullPointerException) javaTypeType))
(assert (not (= fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException))
(assert (forall ((w@@61 T@U) ) (!  (=> (= (type w@@61) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.NullPointerException w@@61) (UOrdering2 w@@61 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.NullPointerException w@@61) (= fixed.java.lang.RuntimeException w@@61))))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@61) (UOrdering2 w@@61 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@62 T@U) ) (!  (=> (and (= (type w@@62) javaTypeType) (UOrdering2 fixed.java.lang.NullPointerException w@@62)) (or (= fixed.java.lang.NullPointerException w@@62) (UOrdering2 fixed.java.lang.RuntimeException w@@62)))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@62))
)))
(assert (forall ((w@@63 T@U) ) (!  (=> (and (= (type w@@63) javaTypeType) (UOrdering2 w@@63 fixed.java.lang.NullPointerException)) (= (oneStep fixed.java.lang.RuntimeException w@@63) fixed.java.lang.NullPointerException))
 :pattern ( (UOrdering2 w@@63 fixed.java.lang.NullPointerException))
)))
(assert (= (type fixed.java.lang.IndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException))
(assert (forall ((w@@64 T@U) ) (!  (=> (= (type w@@64) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@64) (UOrdering2 w@@64 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@64) (= fixed.java.lang.RuntimeException w@@64))))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@64) (UOrdering2 w@@64 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@65 T@U) ) (!  (=> (and (= (type w@@65) javaTypeType) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@65)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@65) (UOrdering2 fixed.java.lang.RuntimeException w@@65)))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@65))
)))
(assert (forall ((w@@66 T@U) ) (!  (=> (and (= (type w@@66) javaTypeType) (UOrdering2 w@@66 fixed.java.lang.IndexOutOfBoundsException)) (= (oneStep fixed.java.lang.RuntimeException w@@66) fixed.java.lang.IndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@66 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (= (type fixed.java.lang.ArrayIndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException)))
(assert (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException))
(assert (forall ((w@@67 T@U) ) (!  (=> (= (type w@@67) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@67) (UOrdering2 w@@67 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@67) (= fixed.java.lang.IndexOutOfBoundsException w@@67))))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@67) (UOrdering2 w@@67 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@68 T@U) ) (!  (=> (and (= (type w@@68) javaTypeType) (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@68)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@68) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@68)))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@68))
)))
(assert (forall ((w@@69 T@U) ) (!  (=> (and (= (type w@@69) javaTypeType) (UOrdering2 w@@69 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= (oneStep fixed.java.lang.IndexOutOfBoundsException w@@69) fixed.java.lang.ArrayIndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@69 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (= (type fixed.java.lang.Boolean) javaTypeType))
(assert (not (= fixed.java.lang.Boolean fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Boolean fixed.java.lang.Object))
(assert (forall ((w@@70 T@U) ) (!  (=> (= (type w@@70) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Boolean w@@70) (UOrdering2 w@@70 fixed.java.lang.Object)) (or (= fixed.java.lang.Boolean w@@70) (= fixed.java.lang.Object w@@70))))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@70) (UOrdering2 w@@70 fixed.java.lang.Object))
)))
(assert (forall ((w@@71 T@U) ) (!  (=> (and (= (type w@@71) javaTypeType) (UOrdering2 fixed.java.lang.Boolean w@@71)) (or (= fixed.java.lang.Boolean w@@71) (UOrdering2 fixed.java.lang.Object w@@71)))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@71))
)))
(assert (forall ((w@@72 T@U) ) (!  (=> (and (= (type w@@72) javaTypeType) (UOrdering2 w@@72 fixed.java.lang.Boolean)) (= (oneStep fixed.java.lang.Object w@@72) fixed.java.lang.Boolean))
 :pattern ( (UOrdering2 w@@72 fixed.java.lang.Boolean))
)))
(assert (forall ((w@@73 T@U) ) (!  (=> (and (= (type w@@73) javaTypeType) (UOrdering2 w@@73 fixed.java.lang.Object)) (or (or (or (or (or (or (or (= fixed.java.lang.Object w@@73) (UOrdering2 w@@73 fixed.org.apache.shiro.authc.credential.DefaultPasswordService)) (UOrdering2 w@@73 fixed.java.lang.Throwable)) (UOrdering2 w@@73 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (UOrdering2 w@@73 fixed.java.lang.AbstractStringBuilder)) (UOrdering2 w@@73 fixed.java.lang.StringBuilder)) (UOrdering2 w@@73 fixed.java.lang.String)) (UOrdering2 w@@73 fixed.java.lang.Boolean)))
 :pattern ( (UOrdering2 w@@73 fixed.java.lang.Object))
)))
(assert (forall ((w@@74 T@U) ) (!  (=> (and (= (type w@@74) javaTypeType) (UOrdering2 w@@74 fixed.org.apache.shiro.authc.credential.HashingPasswordService)) (or (= fixed.org.apache.shiro.authc.credential.HashingPasswordService w@@74) (UOrdering2 w@@74 fixed.org.apache.shiro.authc.credential.DefaultPasswordService)))
 :pattern ( (UOrdering2 w@@74 fixed.org.apache.shiro.authc.credential.HashingPasswordService))
)))
(assert (forall ((w@@75 T@U) ) (!  (=> (and (= (type w@@75) javaTypeType) (UOrdering2 w@@75 fixed.org.apache.shiro.authc.credential.DefaultPasswordService)) (= fixed.org.apache.shiro.authc.credential.DefaultPasswordService w@@75))
 :pattern ( (UOrdering2 w@@75 fixed.org.apache.shiro.authc.credential.DefaultPasswordService))
)))
(assert (forall ((w@@76 T@U) ) (!  (=> (and (= (type w@@76) javaTypeType) (UOrdering2 w@@76 fixed.org.apache.shiro.crypto.hash.DefaultHashService)) (= fixed.org.apache.shiro.crypto.hash.DefaultHashService w@@76))
 :pattern ( (UOrdering2 w@@76 fixed.org.apache.shiro.crypto.hash.DefaultHashService))
)))
(assert (forall ((w@@77 T@U) ) (!  (=> (and (= (type w@@77) refType) (UOrdering2 w@@77 fixed.$StringConst0)) (= fixed.$StringConst0 w@@77))
 :pattern ( (UOrdering2 w@@77 fixed.$StringConst0))
)))
(assert (forall ((w@@78 T@U) ) (!  (=> (and (= (type w@@78) javaTypeType) (UOrdering2 w@@78 fixed.java.io.Serializable)) (or (= fixed.java.io.Serializable w@@78) (UOrdering2 w@@78 fixed.java.lang.Throwable)))
 :pattern ( (UOrdering2 w@@78 fixed.java.io.Serializable))
)))
(assert (forall ((w@@79 T@U) ) (!  (=> (and (= (type w@@79) javaTypeType) (UOrdering2 w@@79 fixed.java.lang.Comparable)) (= fixed.java.lang.Comparable w@@79))
 :pattern ( (UOrdering2 w@@79 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@80 T@U) ) (!  (=> (and (= (type w@@80) javaTypeType) (UOrdering2 w@@80 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.CharSequence w@@80) (UOrdering2 w@@80 fixed.java.lang.AbstractStringBuilder)))
 :pattern ( (UOrdering2 w@@80 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@81 T@U) ) (!  (=> (and (= (type w@@81) javaTypeType) (UOrdering2 w@@81 fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat)) (= fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat w@@81))
 :pattern ( (UOrdering2 w@@81 fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat))
)))
(assert (forall ((w@@82 T@U) ) (!  (=> (and (= (type w@@82) javaTypeType) (UOrdering2 w@@82 fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory)) (= fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory w@@82))
 :pattern ( (UOrdering2 w@@82 fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory))
)))
(assert (forall ((w@@83 T@U) ) (!  (=> (and (= (type w@@83) javaTypeType) (UOrdering2 w@@83 fixed.org.apache.shiro.crypto.hash.Hash)) (= fixed.org.apache.shiro.crypto.hash.Hash w@@83))
 :pattern ( (UOrdering2 w@@83 fixed.org.apache.shiro.crypto.hash.Hash))
)))
(assert (forall ((w@@84 T@U) ) (!  (=> (and (= (type w@@84) javaTypeType) (UOrdering2 w@@84 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Throwable w@@84) (UOrdering2 w@@84 fixed.java.lang.Exception)))
 :pattern ( (UOrdering2 w@@84 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@85 T@U) ) (!  (=> (and (= (type w@@85) javaTypeType) (UOrdering2 w@@85 fixed.java.lang.Exception)) (or (= fixed.java.lang.Exception w@@85) (UOrdering2 w@@85 fixed.java.lang.RuntimeException)))
 :pattern ( (UOrdering2 w@@85 fixed.java.lang.Exception))
)))
(assert (forall ((w@@86 T@U) ) (!  (=> (and (= (type w@@86) javaTypeType) (UOrdering2 w@@86 fixed.java.lang.RuntimeException)) (or (or (or (= fixed.java.lang.RuntimeException w@@86) (UOrdering2 w@@86 fixed.java.lang.ClassCastException)) (UOrdering2 w@@86 fixed.java.lang.NullPointerException)) (UOrdering2 w@@86 fixed.java.lang.IndexOutOfBoundsException)))
 :pattern ( (UOrdering2 w@@86 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@87 T@U) ) (!  (=> (and (= (type w@@87) javaTypeType) (UOrdering2 w@@87 fixed.org.apache.shiro.crypto.hash.format.HashFormat)) (= fixed.org.apache.shiro.crypto.hash.format.HashFormat w@@87))
 :pattern ( (UOrdering2 w@@87 fixed.org.apache.shiro.crypto.hash.format.HashFormat))
)))
(assert (forall ((w@@88 T@U) ) (!  (=> (and (= (type w@@88) javaTypeType) (UOrdering2 w@@88 fixed.org.apache.shiro.util.ByteSource)) (= fixed.org.apache.shiro.util.ByteSource w@@88))
 :pattern ( (UOrdering2 w@@88 fixed.org.apache.shiro.util.ByteSource))
)))
(assert (forall ((w@@89 T@U) ) (!  (=> (and (= (type w@@89) javaTypeType) (UOrdering2 w@@89 fixed.org.apache.shiro.crypto.hash.HashRequest)) (= fixed.org.apache.shiro.crypto.hash.HashRequest w@@89))
 :pattern ( (UOrdering2 w@@89 fixed.org.apache.shiro.crypto.hash.HashRequest))
)))
(assert (forall ((w@@90 T@U) ) (!  (=> (and (= (type w@@90) javaTypeType) (UOrdering2 w@@90 fixed.org.apache.shiro.crypto.hash.HashService)) (= fixed.org.apache.shiro.crypto.hash.HashService w@@90))
 :pattern ( (UOrdering2 w@@90 fixed.org.apache.shiro.crypto.hash.HashService))
)))
(assert (forall ((w@@91 T@U) ) (!  (=> (and (= (type w@@91) javaTypeType) (UOrdering2 w@@91 fixed.java.lang.ClassCastException)) (= fixed.java.lang.ClassCastException w@@91))
 :pattern ( (UOrdering2 w@@91 fixed.java.lang.ClassCastException))
)))
(assert (forall ((w@@92 T@U) ) (!  (=> (and (= (type w@@92) javaTypeType) (UOrdering2 w@@92 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@92))
 :pattern ( (UOrdering2 w@@92 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (forall ((w@@93 T@U) ) (!  (=> (and (= (type w@@93) javaTypeType) (UOrdering2 w@@93 fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat)) (= fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat w@@93))
 :pattern ( (UOrdering2 w@@93 fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat))
)))
(assert (forall ((w@@94 T@U) ) (!  (=> (and (= (type w@@94) javaTypeType) (UOrdering2 w@@94 fixed.org.slf4j.Logger)) (= fixed.org.slf4j.Logger w@@94))
 :pattern ( (UOrdering2 w@@94 fixed.org.slf4j.Logger))
)))
(assert (forall ((w@@95 T@U) ) (!  (=> (and (= (type w@@95) javaTypeType) (UOrdering2 w@@95 fixed.java.lang.Appendable)) (or (= fixed.java.lang.Appendable w@@95) (UOrdering2 w@@95 fixed.java.lang.AbstractStringBuilder)))
 :pattern ( (UOrdering2 w@@95 fixed.java.lang.Appendable))
)))
(assert (forall ((w@@96 T@U) ) (!  (=> (and (= (type w@@96) javaTypeType) (UOrdering2 w@@96 fixed.java.lang.AbstractStringBuilder)) (= fixed.java.lang.AbstractStringBuilder w@@96))
 :pattern ( (UOrdering2 w@@96 fixed.java.lang.AbstractStringBuilder))
)))
(assert (forall ((w@@97 T@U) ) (!  (=> (and (= (type w@@97) refType) (UOrdering2 w@@97 fixed.$StringConst1)) (= fixed.$StringConst1 w@@97))
 :pattern ( (UOrdering2 w@@97 fixed.$StringConst1))
)))
(assert (forall ((w@@98 T@U) ) (!  (=> (and (= (type w@@98) javaTypeType) (UOrdering2 w@@98 fixed.java.lang.reflect.AnnotatedElement)) (or (= fixed.java.lang.reflect.AnnotatedElement w@@98) (UOrdering2 w@@98 fixed.java.lang.reflect.GenericDeclaration)))
 :pattern ( (UOrdering2 w@@98 fixed.java.lang.reflect.AnnotatedElement))
)))
(assert (forall ((w@@99 T@U) ) (!  (=> (and (= (type w@@99) javaTypeType) (UOrdering2 w@@99 fixed.java.lang.reflect.GenericDeclaration)) (= fixed.java.lang.reflect.GenericDeclaration w@@99))
 :pattern ( (UOrdering2 w@@99 fixed.java.lang.reflect.GenericDeclaration))
)))
(assert (forall ((w@@100 T@U) ) (!  (=> (and (= (type w@@100) javaTypeType) (UOrdering2 w@@100 fixed.java.lang.reflect.Type)) (= fixed.java.lang.reflect.Type w@@100))
 :pattern ( (UOrdering2 w@@100 fixed.java.lang.reflect.Type))
)))
(assert (forall ((w@@101 T@U) ) (!  (=> (and (= (type w@@101) refType) (UOrdering2 w@@101 fixed.$StringConst2)) (= fixed.$StringConst2 w@@101))
 :pattern ( (UOrdering2 w@@101 fixed.$StringConst2))
)))
(assert (forall ((w@@102 T@U) ) (!  (=> (and (= (type w@@102) refType) (UOrdering2 w@@102 fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat)) (= fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat w@@102))
 :pattern ( (UOrdering2 w@@102 fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat))
)))
(assert (forall ((w@@103 T@U) ) (!  (=> (and (= (type w@@103) refType) (UOrdering2 w@@103 fixed.$StringConst3)) (= fixed.$StringConst3 w@@103))
 :pattern ( (UOrdering2 w@@103 fixed.$StringConst3))
)))
(assert (forall ((w@@104 T@U) ) (!  (=> (and (= (type w@@104) refType) (UOrdering2 w@@104 fixed.$StringConst4)) (= fixed.$StringConst4 w@@104))
 :pattern ( (UOrdering2 w@@104 fixed.$StringConst4))
)))
(assert (forall ((w@@105 T@U) ) (!  (=> (and (= (type w@@105) javaTypeType) (UOrdering2 w@@105 fixed.org.apache.shiro.crypto.hash.HashRequest$Builder)) (= fixed.org.apache.shiro.crypto.hash.HashRequest$Builder w@@105))
 :pattern ( (UOrdering2 w@@105 fixed.org.apache.shiro.crypto.hash.HashRequest$Builder))
)))
(assert (forall ((w@@106 T@U) ) (!  (=> (and (= (type w@@106) javaTypeType) (UOrdering2 w@@106 fixed.org.apache.shiro.util.ByteSource$Util)) (= fixed.org.apache.shiro.util.ByteSource$Util w@@106))
 :pattern ( (UOrdering2 w@@106 fixed.org.apache.shiro.util.ByteSource$Util))
)))
(assert (forall ((w@@107 T@U) ) (!  (=> (and (= (type w@@107) javaTypeType) (UOrdering2 w@@107 fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory)) (= fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory w@@107))
 :pattern ( (UOrdering2 w@@107 fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory))
)))
(assert (forall ((w@@108 T@U) ) (!  (=> (and (= (type w@@108) refType) (UOrdering2 w@@108 fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService)) (= fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService w@@108))
 :pattern ( (UOrdering2 w@@108 fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService))
)))
(assert (forall ((w@@109 T@U) ) (!  (=> (and (= (type w@@109) javaTypeType) (UOrdering2 w@@109 fixed.org.slf4j.LoggerFactory)) (= fixed.org.slf4j.LoggerFactory w@@109))
 :pattern ( (UOrdering2 w@@109 fixed.org.slf4j.LoggerFactory))
)))
(assert (forall ((w@@110 T@U) ) (!  (=> (and (= (type w@@110) javaTypeType) (UOrdering2 w@@110 fixed.java.lang.StringBuilder)) (= fixed.java.lang.StringBuilder w@@110))
 :pattern ( (UOrdering2 w@@110 fixed.java.lang.StringBuilder))
)))
(assert (forall ((w@@111 T@U) ) (!  (=> (and (= (type w@@111) javaTypeType) (UOrdering2 w@@111 fixed.java.lang.String)) (= fixed.java.lang.String w@@111))
 :pattern ( (UOrdering2 w@@111 fixed.java.lang.String))
)))
(assert (forall ((w@@112 T@U) ) (!  (=> (and (= (type w@@112) javaTypeType) (UOrdering2 w@@112 fixed.java.lang.NullPointerException)) (= fixed.java.lang.NullPointerException w@@112))
 :pattern ( (UOrdering2 w@@112 fixed.java.lang.NullPointerException))
)))
(assert (forall ((w@@113 T@U) ) (!  (=> (and (= (type w@@113) javaTypeType) (UOrdering2 w@@113 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@113) (UOrdering2 w@@113 fixed.java.lang.ArrayIndexOutOfBoundsException)))
 :pattern ( (UOrdering2 w@@113 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@114 T@U) ) (!  (=> (and (= (type w@@114) javaTypeType) (UOrdering2 w@@114 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@114))
 :pattern ( (UOrdering2 w@@114 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (forall ((w@@115 T@U) ) (!  (=> (and (= (type w@@115) javaTypeType) (UOrdering2 w@@115 fixed.java.lang.Boolean)) (= fixed.java.lang.Boolean w@@115))
 :pattern ( (UOrdering2 w@@115 fixed.java.lang.Boolean))
)))
(assert  (and (and (and (and (forall ((arg0@@6 T@T) ) (! (= (Ctor (FieldType arg0@@6)) 5)
 :qid |ctor:FieldType|
)) (forall ((arg0@@7 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@7)) arg0@@7)
 :qid |typeInv:FieldTypeInv0|
 :pattern ( (FieldType arg0@@7))
))) (= (type fixed.$type) (FieldType javaTypeType))) (= (type fixed.$alloc) (FieldType boolType))) (= (type fixed.$null) refType)))
(assert (distinct fixed.$type fixed.$alloc fixed.$null fixed.java.lang.Object fixed.org.apache.shiro.authc.credential.HashingPasswordService fixed.org.apache.shiro.authc.credential.DefaultPasswordService fixed.org.apache.shiro.crypto.hash.DefaultHashService fixed.$StringConst0 fixed.java.io.Serializable fixed.java.lang.Comparable fixed.java.lang.CharSequence fixed.org.apache.shiro.crypto.hash.format.Shiro1CryptFormat fixed.org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory fixed.org.apache.shiro.crypto.hash.Hash fixed.java.lang.Throwable fixed.java.lang.Exception fixed.java.lang.RuntimeException fixed.org.apache.shiro.crypto.hash.format.HashFormat fixed.org.apache.shiro.util.ByteSource fixed.org.apache.shiro.crypto.hash.HashRequest fixed.org.apache.shiro.crypto.hash.HashService fixed.java.lang.ClassCastException fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.org.apache.shiro.crypto.hash.format.ParsableHashFormat fixed.org.slf4j.Logger fixed.java.lang.Appendable fixed.java.lang.AbstractStringBuilder fixed.$StringConst1 fixed.java.lang.reflect.AnnotatedElement fixed.java.lang.reflect.GenericDeclaration fixed.java.lang.reflect.Type fixed.$StringConst2 fixed.CC$org$_$apache$_$shiro$_$crypto$_$hash$_$format$_$ParsableHashFormat fixed.$StringConst3 fixed.$StringConst4 fixed.org.apache.shiro.crypto.hash.HashRequest$Builder fixed.org.apache.shiro.util.ByteSource$Util fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory fixed.CC$org$_$apache$_$shiro$_$authc$_$credential$_$DefaultPasswordService fixed.org.slf4j.LoggerFactory fixed.java.lang.StringBuilder fixed.java.lang.String fixed.java.lang.NullPointerException fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.Boolean)
)
(assert (forall ((x@@5 Int) ) (!  (and (=> (fixed.$intToBool x@@5) (ite (= x@@5 0) false true)) (=> (ite (= x@@5 0) false true) (fixed.$intToBool x@@5)))
 :qid |RSPROCor.173:15|
 :skolemid |6550|
 :pattern ( (fixed.$intToBool x@@5))
)))
(assert (forall ((x@@6 T@U) ) (!  (=> (= (type x@@6) refType) (and (=> (fixed.$refToBool x@@6) (ite (= x@@6 fixed.$null) false true)) (=> (ite (= x@@6 fixed.$null) false true) (fixed.$refToBool x@@6))))
 :qid |RSPROCor.177:15|
 :skolemid |6551|
 :pattern ( (fixed.$refToBool x@@6))
)))
(assert (forall ((x@@7 Bool) ) (! (= (fixed.$boolToInt x@@7) (ite  (and (=> x@@7 true) (=> true x@@7)) 1 0))
 :qid |RSPROCor.181:15|
 :skolemid |6552|
 :pattern ( (fixed.$boolToInt x@@7))
)))
(assert (forall ((x@@8 Real) (y@@1 Real) ) (! (= (fixed.$cmpReal x@@8 y@@1) (ite (> x@@8 y@@1) 1 (ite (< x@@8 y@@1) (- 0 1) 0)))
 :qid |RSPROCor.185:15|
 :skolemid |6553|
 :pattern ( (fixed.$cmpReal x@@8 y@@1))
)))
(assert (forall ((x@@9 Int) (y@@2 Int) ) (! (= (fixed.$cmpInt x@@9 y@@2) (ite (> x@@9 y@@2) 1 (ite (< x@@9 y@@2) (- 0 1) 0)))
 :qid |RSPROCor.189:15|
 :skolemid |6554|
 :pattern ( (fixed.$cmpInt x@@9 y@@2))
)))
(assert (forall ((arg0@@8 Int) ) (! (= (type (fixed.$intToRef arg0@@8)) refType)
 :qid |funType:fixed.$intToRef|
 :pattern ( (fixed.$intToRef arg0@@8))
)))
(assert (forall ((index Int) ) (! (not (= (fixed.$intToRef index) fixed.$null))
 :qid |RSPROCor.193:15|
 :skolemid |6555|
)))
(assert (forall ((i1 Int) (i2 Int) ) (!  (and (=> (= i1 i2) (= (fixed.$intToRef i1) (fixed.$intToRef i2))) (=> (= (fixed.$intToRef i1) (fixed.$intToRef i2)) (= i1 i2)))
 :qid |RSPROCor.195:15|
 :skolemid |6556|
)))
(assert (forall ((x@@10 Int) ) (!  (and (=> (fixed.$intToBool x@@10) (ite (= x@@10 0) false true)) (=> (ite (= x@@10 0) false true) (fixed.$intToBool x@@10)))
 :qid |RSPROCor.27585:15|
 :skolemid |7196|
 :pattern ( (fixed.$intToBool x@@10))
)))
(assert (forall ((x@@11 T@U) ) (!  (=> (= (type x@@11) refType) (and (=> (fixed.$refToBool x@@11) (ite (= x@@11 fixed.$null) false true)) (=> (ite (= x@@11 fixed.$null) false true) (fixed.$refToBool x@@11))))
 :qid |RSPROCor.27589:15|
 :skolemid |7197|
 :pattern ( (fixed.$refToBool x@@11))
)))
(assert (forall ((x@@12 Bool) ) (! (= (fixed.$boolToInt x@@12) (ite  (and (=> x@@12 true) (=> true x@@12)) 1 0))
 :qid |RSPROCor.27593:15|
 :skolemid |7198|
 :pattern ( (fixed.$boolToInt x@@12))
)))
(assert (forall ((x@@13 Real) (y@@3 Real) ) (! (= (fixed.$cmpReal x@@13 y@@3) (ite (> x@@13 y@@3) 1 (ite (< x@@13 y@@3) (- 0 1) 0)))
 :qid |RSPROCor.27597:15|
 :skolemid |7199|
 :pattern ( (fixed.$cmpReal x@@13 y@@3))
)))
(assert (forall ((x@@14 Int) (y@@4 Int) ) (! (= (fixed.$cmpInt x@@14 y@@4) (ite (> x@@14 y@@4) 1 (ite (< x@@14 y@@4) (- 0 1) 0)))
 :qid |RSPROCor.27601:15|
 :skolemid |7200|
 :pattern ( (fixed.$cmpInt x@@14 y@@4))
)))
(assert (forall ((index@@0 Int) ) (! (not (= (fixed.$intToRef index@@0) fixed.$null))
 :qid |RSPROCor.27605:15|
 :skolemid |7201|
)))
(assert (forall ((i1@@0 Int) (i2@@0 Int) ) (!  (and (=> (= i1@@0 i2@@0) (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0))) (=> (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0)) (= i1@@0 i2@@0)))
 :qid |RSPROCor.27607:15|
 :skolemid |7202|
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1) refType) (= (type inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1) refType)) (forall ((arg0@@9 T@T) ) (! (= (Ctor (MapType0Type arg0@@9)) 6)
 :qid |ctor:MapType0Type|
))) (forall ((arg0@@10 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@10)) arg0@@10)
 :qid |typeInv:MapType0TypeInv0|
 :pattern ( (MapType0Type arg0@@10))
))) (forall ((arg0@@11 T@U) (arg1@@0 T@U) (arg2 T@U) ) (! (let (($GenericType__0 (FieldTypeInv0 (type arg2))))
(= (type (MapType0Select arg0@@11 arg1@@0 arg2)) $GenericType__0))
 :qid |funType:MapType0Select|
 :pattern ( (MapType0Select arg0@@11 arg1@@0 arg2))
))) (forall ((arg0@@12 T@U) (arg1@@1 T@U) (arg2@@0 T@U) (arg3 T@U) ) (! (let ((aVar0 (type arg1@@1)))
(= (type (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3)) (MapType0Type aVar0)))
 :qid |funType:MapType0Store|
 :pattern ( (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3))
))) (forall ((m T@U) (x0 T@U) (x1 T@U) (val T@U) ) (! (let (($GenericType__0@@0 (FieldTypeInv0 (type x1))))
 (=> (= (type val) $GenericType__0@@0) (= (MapType0Select (MapType0Store m x0 x1 val) x0 x1) val)))
 :qid |mapAx0:MapType0Select|
 :weight 0
))) (and (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (x1@@0 T@U) (y0 T@U) (y1 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 x1@@0 val@@0) y0 y1) (MapType0Select m@@0 y0 y1)))
 :qid |mapAx1:MapType0Select:0|
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (x1@@1 T@U) (y0@@0 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType0Select (MapType0Store m@@1 x0@@1 x1@@1 val@@1) y0@@0 y1@@0) (MapType0Select m@@1 y0@@0 y1@@0)))
 :qid |mapAx1:MapType0Select:1|
 :weight 0
))) (forall ((val@@2 T@U) (m@@2 T@U) (x0@@2 T@U) (x1@@2 T@U) (y0@@1 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@2 x0@@2 x1@@2 val@@2) y0@@1 y1@@1) (MapType0Select m@@2 y0@@1 y1@@1)))
 :qid |mapAx2:MapType0Select|
 :weight 0
)))) (= (type fixed.$heap) (MapType0Type refType))) (forall ((arg0@@13 T@T) (arg1@@2 T@T) ) (! (= (Ctor (MapType1Type arg0@@13 arg1@@2)) 7)
 :qid |ctor:MapType1Type|
))) (forall ((arg0@@14 T@T) (arg1@@3 T@T) ) (! (= (MapType1TypeInv0 (MapType1Type arg0@@14 arg1@@3)) arg0@@14)
 :qid |typeInv:MapType1TypeInv0|
 :pattern ( (MapType1Type arg0@@14 arg1@@3))
))) (forall ((arg0@@15 T@T) (arg1@@4 T@T) ) (! (= (MapType1TypeInv1 (MapType1Type arg0@@15 arg1@@4)) arg1@@4)
 :qid |typeInv:MapType1TypeInv1|
 :pattern ( (MapType1Type arg0@@15 arg1@@4))
))) (forall ((arg0@@16 T@U) (arg1@@5 T@U) ) (! (let ((aVar1 (MapType1TypeInv1 (type arg0@@16))))
(= (type (MapType1Select arg0@@16 arg1@@5)) aVar1))
 :qid |funType:MapType1Select|
 :pattern ( (MapType1Select arg0@@16 arg1@@5))
))) (forall ((arg0@@17 T@U) (arg1@@6 T@U) (arg2@@1 T@U) ) (! (let ((aVar1@@0 (type arg2@@1)))
(let ((aVar0@@0 (type arg1@@6)))
(= (type (MapType1Store arg0@@17 arg1@@6 arg2@@1)) (MapType1Type aVar0@@0 aVar1@@0))))
 :qid |funType:MapType1Store|
 :pattern ( (MapType1Store arg0@@17 arg1@@6 arg2@@1))
))) (forall ((m@@3 T@U) (x0@@3 T@U) (val@@3 T@U) ) (! (let ((aVar1@@1 (MapType1TypeInv1 (type m@@3))))
 (=> (= (type val@@3) aVar1@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) x0@@3) val@@3)))
 :qid |mapAx0:MapType1Select|
 :weight 0
))) (and (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or (= x0@@4 y0@@2) (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :qid |mapAx1:MapType1Select:0|
 :weight 0
)) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (y0@@3 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 val@@5) y0@@3) (MapType1Select m@@5 y0@@3)))
 :qid |mapAx2:MapType1Select|
 :weight 0
)))) (= (type fixed.$arrSizeHeap) (MapType1Type refType intType))) (= (type fixed.$stringSizeHeap) (MapType1Type refType intType))) (= (type $this) refType)) (= (type inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0) refType)) (= (type fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory$org.apache.shiro.authc.credential.DefaultPasswordService$hashFormatFactory263) (FieldType refType))) (= (type inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0) refType)))
(push 1)
(set-info :boogie-vc-id PROC_.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$_EQ_unsafe__xx__fixed)
(assert (not
(let ((AA_INSTR_EQ_BODY$2_correct  (=> (! (and %lbl%+1924611 true) :lblpos +1924611) (=> (and (and (=> AA_TEMP280@1 (or AA_TEMP280@0 (= inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1))) (=> (or AA_TEMP280@0 (= inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1)) AA_TEMP280@1)) (and (=> AA_TEMP281@1 (or AA_TEMP281@0 (= fixed.$null fixed.$null))) (=> (or AA_TEMP281@0 (= fixed.$null fixed.$null)) AA_TEMP281@1))) (! (or %lbl%@1944002  (and AA_TEMP281@1 AA_TEMP280@1)) :lblneg @1944002)))))
(let ((inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Return_correct  (=> (! (and %lbl%+1924610 true) :lblpos +1924610) AA_INSTR_EQ_BODY$2_correct)))
(let ((inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$block38_correct  (=> (! (and %lbl%+1924609 true) :lblpos +1924609) inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Return_correct)))
(let ((inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$anon0_correct  (=> (! (and %lbl%+1924608 true) :lblpos +1924608) (=> (forall ((T T@U) ) (!  (=> (= (type T) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T))
 :qid |RSPROCor.46808:20|
 :skolemid |7428|
 :no-pattern (type T)
 :no-pattern (U_2_int T)
 :no-pattern (U_2_bool T)
)) (=> (and (forall ((_r T@U) ) (!  (=> (= (type _r) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r)) 0))
 :qid |RSPROCor.46809:20|
 :skolemid |7429|
 :no-pattern (type _r)
 :no-pattern (U_2_int _r)
 :no-pattern (U_2_bool _r)
)) (forall ((_r@@0 T@U) ) (!  (=> (= (type _r@@0) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@0)) 0))
 :qid |RSPROCor.46810:20|
 :skolemid |7430|
 :no-pattern (type _r@@0)
 :no-pattern (U_2_int _r@@0)
 :no-pattern (U_2_bool _r@@0)
))) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap $this fixed.$type) fixed.org.apache.shiro.authc.credential.DefaultPasswordService) (not (= $this fixed.$null))) (and (UOrdering2 (MapType0Select fixed.$heap inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0 fixed.$type) fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory) (= inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 (MapType0Select fixed.$heap $this fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory$org.apache.shiro.authc.credential.DefaultPasswordService$hashFormatFactory263)))) inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$block38_correct))))))
(let ((inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Entry_correct  (=> (! (and %lbl%+1924607 true) :lblpos +1924607) inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY$1_correct  (=> (! (and %lbl%+1924606 true) :lblpos +1924606) inline$fixed.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Entry_correct)))
(let ((inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Return_correct  (=> (! (and %lbl%+1924605 true) :lblpos +1924605) AA_INSTR_EQ_BODY$1_correct)))
(let ((inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$block39_correct  (=> (! (and %lbl%+1924604 true) :lblpos +1924604) inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Return_correct)))
(let ((inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$anon0_correct  (=> (! (and %lbl%+1924603 true) :lblpos +1924603) (=> (forall ((T@@0 T@U) ) (!  (=> (= (type T@@0) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T@@0))
 :qid |RSPROCor.46769:20|
 :skolemid |7425|
 :no-pattern (type T@@0)
 :no-pattern (U_2_int T@@0)
 :no-pattern (U_2_bool T@@0)
)) (=> (and (forall ((_r@@1 T@U) ) (!  (=> (= (type _r@@1) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r@@1)) 0))
 :qid |RSPROCor.46770:20|
 :skolemid |7426|
 :no-pattern (type _r@@1)
 :no-pattern (U_2_int _r@@1)
 :no-pattern (U_2_bool _r@@1)
)) (forall ((_r@@2 T@U) ) (!  (=> (= (type _r@@2) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@2)) 0))
 :qid |RSPROCor.46771:20|
 :skolemid |7427|
 :no-pattern (type _r@@2)
 :no-pattern (U_2_int _r@@2)
 :no-pattern (U_2_bool _r@@2)
))) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap $this fixed.$type) fixed.org.apache.shiro.authc.credential.DefaultPasswordService) (not (= $this fixed.$null))) (and (UOrdering2 (MapType0Select fixed.$heap inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$return@0 fixed.$type) fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory) (= inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$$r1@1 (MapType0Select fixed.$heap $this fixed.org.apache.shiro.crypto.hash.format.HashFormatFactory$org.apache.shiro.authc.credential.DefaultPasswordService$hashFormatFactory263)))) inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$block39_correct))))))
(let ((inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Entry_correct  (=> (! (and %lbl%+1924602 true) :lblpos +1924602) inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY_correct  (=> (! (and %lbl%+1924601 true) :lblpos +1924601) inline$unsafe.org.apache.shiro.authc.credential.DefaultPasswordService$getHashFormatFactory$$0$Entry_correct)))
(let ((q@0_correct  (=> (! (and %lbl%+1943671 true) :lblpos +1943671) AA_INSTR_EQ_BODY_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+1943676 true) :lblpos +1943676) q@0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))
))
(check-sat)
(pop 1)
; Valid
