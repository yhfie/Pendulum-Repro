(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :produce-models true)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 20000000)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun javaTypeType () T@T)
(declare-fun fixed.java.lang.Object () T@U)
(declare-fun fixed.TokenHandler () T@U)
(declare-fun oneStep (T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun fixed.$StringConst0 () T@U)
(declare-fun fixed.java.lang.Cloneable () T@U)
(declare-fun fixed.javax.crypto.Mac () T@U)
(declare-fun fixed.java.io.Serializable () T@U)
(declare-fun fixed.java.lang.Comparable () T@U)
(declare-fun fixed.java.lang.CharSequence () T@U)
(declare-fun fixed.java.lang.String () T@U)
(declare-fun fixed.java.lang.Throwable () T@U)
(declare-fun fixed.java.lang.Exception () T@U)
(declare-fun fixed.java.security.GeneralSecurityException () T@U)
(declare-fun fixed.java.security.NoSuchAlgorithmException () T@U)
(declare-fun fixed.java.security.spec.KeySpec () T@U)
(declare-fun fixed.java.security.Key () T@U)
(declare-fun fixed.javax.security.auth.Destroyable () T@U)
(declare-fun fixed.javax.crypto.SecretKey () T@U)
(declare-fun fixed.javax.crypto.spec.SecretKeySpec () T@U)
(declare-fun fixed.java.lang.RuntimeException () T@U)
(declare-fun fixed.java.security.KeyException () T@U)
(declare-fun fixed.java.security.InvalidKeyException () T@U)
(declare-fun fixed.java.lang.IllegalStateException () T@U)
(declare-fun fixed.java.lang.Appendable () T@U)
(declare-fun fixed.java.lang.AbstractStringBuilder () T@U)
(declare-fun fixed.java.lang.StringBuilder () T@U)
(declare-fun fixed.$StringConst1 () T@U)
(declare-fun fixed.com.jdriven.stateless.security.User () T@U)
(declare-fun fixed.$StringConst2 () T@U)
(declare-fun fixed.java.lang.NullPointerException () T@U)
(declare-fun fixed.java.lang.IndexOutOfBoundsException () T@U)
(declare-fun fixed.java.lang.ArrayIndexOutOfBoundsException () T@U)
(declare-fun fixed.java.lang.IllegalArgumentException () T@U)
(declare-fun fixed.java.util.Date () T@U)
(declare-fun fixed.sg.edu.nus.comp.tsunami.safe.Safe () T@U)
(declare-fun fixed.java.lang.Boolean () T@U)
(declare-fun fixed.java.lang.ClassCastException () T@U)
(declare-fun fixed.$StringConst3 () T@U)
(declare-fun fixed.com.fasterxml.jackson.databind.ObjectMapper () T@U)
(declare-fun fixed.com.fasterxml.jackson.core.JsonProcessingException () T@U)
(declare-fun fixed.javax.xml.bind.DatatypeConverter () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun fixed.$type () T@U)
(declare-fun fixed.$alloc () T@U)
(declare-fun fixed.$null () T@U)
(declare-fun fixed.$intToBool (Int) Bool)
(declare-fun fixed.$refToBool (T@U) Bool)
(declare-fun fixed.$boolToInt (Bool) Int)
(declare-fun fixed.$cmpReal (Real Real) Int)
(declare-fun fixed.$cmpInt (Int Int) Int)
(declare-fun fixed.$intToRef (Int) T@U)
(declare-fun inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 () T@U)
(declare-fun inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 () T@U)
(declare-fun MapType0Type (T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U T@U) T@U)
(declare-fun fixed.$heap@21 () T@U)
(declare-fun fixed.$heap@10 () T@U)
(declare-fun fixed.$heap () T@U)
(declare-fun inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 () T@U)
(declare-fun call3formal@$obj@0 () T@U)
(declare-fun fixed.$heap@13 () T@U)
(declare-fun fixed.$heap@12 () T@U)
(declare-fun inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 () T@U)
(declare-fun fixed.$heap@20 () T@U)
(declare-fun fixed.$heap@14 () T@U)
(declare-fun $this () T@U)
(declare-fun fixed.boolean$TokenHandler$safeMode0 () T@U)
(declare-fun call2formal@$exception@0 () T@U)
(declare-fun call2formal@$return@0 () T@U)
(declare-fun call3formal@$obj@0@@0 () T@U)
(declare-fun fixed.$heap@18 () T@U)
(declare-fun fixed.$heap@17 () T@U)
(declare-fun call2formal@$return@0@@0 () T@U)
(declare-fun call3formal@$obj@0@@1 () T@U)
(declare-fun fixed.$heap@19 () T@U)
(declare-fun call3formal@$obj@0@@2 () T@U)
(declare-fun fixed.$heap@15 () T@U)
(declare-fun inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 () T@U)
(declare-fun fixed.$heap@16 () T@U)
(declare-fun call3formal@$obj@0@@3 () T@U)
(declare-fun call3formal@$exception@0 () T@U)
(declare-fun fixed.$heap@11 () T@U)
(declare-fun fixed.javax.crypto.Mac$TokenHandler$hmac262 () T@U)
(declare-fun call1formal@$return@0 () T@U)
(declare-fun call3formal@$obj@0@@4 () T@U)
(declare-fun call2formal@$exception@0@@0 () T@U)
(declare-fun MapType1Type (T@T T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1TypeInv1 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun fixed.$arrSizeHeap () T@U)
(declare-fun fixed.$stringSizeHeap () T@U)
(declare-fun inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 () T@U)
(declare-fun call3formal@$obj@0@@5 () T@U)
(declare-fun fixed.$heap@2 () T@U)
(declare-fun fixed.$heap@1 () T@U)
(declare-fun inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 () T@U)
(declare-fun fixed.$heap@9 () T@U)
(declare-fun fixed.$heap@3 () T@U)
(declare-fun call2formal@$exception@0@@1 () T@U)
(declare-fun call2formal@$return@0@@1 () T@U)
(declare-fun call3formal@$obj@0@@6 () T@U)
(declare-fun fixed.$heap@7 () T@U)
(declare-fun fixed.$heap@6 () T@U)
(declare-fun call2formal@$return@0@@2 () T@U)
(declare-fun call3formal@$obj@0@@7 () T@U)
(declare-fun fixed.$heap@8 () T@U)
(declare-fun call3formal@$obj@0@@8 () T@U)
(declare-fun fixed.$heap@4 () T@U)
(declare-fun inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 () T@U)
(declare-fun fixed.$heap@5 () T@U)
(declare-fun call3formal@$obj@0@@9 () T@U)
(declare-fun call3formal@$exception@0@@0 () T@U)
(declare-fun fixed.$heap@0 () T@U)
(declare-fun call1formal@$return@0@@0 () T@U)
(declare-fun call3formal@$obj@0@@10 () T@U)
(declare-fun call2formal@$exception@0@@2 () T@U)
(declare-fun %lbl%+260007 () Bool)
(declare-fun AA_TEMP30@1 () Bool)
(declare-fun AA_TEMP30@0 () Bool)
(declare-fun AA_TEMP31@1 () Bool)
(declare-fun AA_TEMP31@0 () Bool)
(declare-fun AA_TEMP32@1 () Bool)
(declare-fun AA_TEMP32@0 () Bool)
(declare-fun fixed.$objIndex@15 () Int)
(declare-fun %lbl%@269902 () Bool)
(declare-fun %lbl%+260006 () Bool)
(declare-fun %lbl%+259997 () Bool)
(declare-fun fixed.$objIndex@11 () Int)
(declare-fun fixed.$objIndex@13 () Int)
(declare-fun %lbl%+259994 () Bool)
(declare-fun fixed.$objIndex@12 () Int)
(declare-fun %lbl%+259989 () Bool)
(declare-fun fixed.$objIndex@14 () Int)
(declare-fun %lbl%+259999 () Bool)
(declare-fun %lbl%+259998 () Bool)
(declare-fun %lbl%+259996 () Bool)
(declare-fun %lbl%+259995 () Bool)
(declare-fun %lbl%+259993 () Bool)
(declare-fun fixed.$objIndex@9 () Int)
(declare-fun fixed.$objIndex@10 () Int)
(declare-fun %lbl%+260005 () Bool)
(declare-fun fixed.$objIndex () Int)
(declare-fun %lbl%+260002 () Bool)
(declare-fun fixed.$objIndex@7 () Int)
(declare-fun %lbl%+259992 () Bool)
(declare-fun %lbl%+259988 () Bool)
(declare-fun $in_parameter__1 () Int)
(declare-fun %lbl%+259987 () Bool)
(declare-fun %lbl%+259991 () Bool)
(declare-fun %lbl%+259990 () Bool)
(declare-fun %lbl%+259986 () Bool)
(declare-fun %lbl%+259985 () Bool)
(declare-fun %lbl%+259984 () Bool)
(declare-fun %lbl%+259983 () Bool)
(declare-fun fixed.$objIndex@8 () Int)
(declare-fun %lbl%+259982 () Bool)
(declare-fun %lbl%+260001 () Bool)
(declare-fun %lbl%+260000 () Bool)
(declare-fun %lbl%+259981 () Bool)
(declare-fun %lbl%+259980 () Bool)
(declare-fun %lbl%+260004 () Bool)
(declare-fun %lbl%+260003 () Bool)
(declare-fun %lbl%+259979 () Bool)
(declare-fun %lbl%+259978 () Bool)
(declare-fun %lbl%+259977 () Bool)
(declare-fun %lbl%+259976 () Bool)
(declare-fun %lbl%+259975 () Bool)
(declare-fun %lbl%+259974 () Bool)
(declare-fun %lbl%+259973 () Bool)
(declare-fun %lbl%+259972 () Bool)
(declare-fun %lbl%+259971 () Bool)
(declare-fun %lbl%+259970 () Bool)
(declare-fun %lbl%+259961 () Bool)
(declare-fun fixed.$objIndex@4 () Int)
(declare-fun fixed.$objIndex@6 () Int)
(declare-fun %lbl%+259958 () Bool)
(declare-fun fixed.$objIndex@5 () Int)
(declare-fun %lbl%+259953 () Bool)
(declare-fun %lbl%+259963 () Bool)
(declare-fun %lbl%+259962 () Bool)
(declare-fun %lbl%+259960 () Bool)
(declare-fun %lbl%+259959 () Bool)
(declare-fun %lbl%+259957 () Bool)
(declare-fun fixed.$objIndex@2 () Int)
(declare-fun fixed.$objIndex@3 () Int)
(declare-fun %lbl%+259969 () Bool)
(declare-fun %lbl%+259966 () Bool)
(declare-fun fixed.$objIndex@0 () Int)
(declare-fun %lbl%+259956 () Bool)
(declare-fun %lbl%+259952 () Bool)
(declare-fun %lbl%+259951 () Bool)
(declare-fun %lbl%+259955 () Bool)
(declare-fun %lbl%+259954 () Bool)
(declare-fun %lbl%+259950 () Bool)
(declare-fun %lbl%+259949 () Bool)
(declare-fun %lbl%+259948 () Bool)
(declare-fun %lbl%+259947 () Bool)
(declare-fun fixed.$objIndex@1 () Int)
(declare-fun %lbl%+259946 () Bool)
(declare-fun %lbl%+259965 () Bool)
(declare-fun %lbl%+259964 () Bool)
(declare-fun %lbl%+259945 () Bool)
(declare-fun %lbl%+259944 () Bool)
(declare-fun %lbl%+259968 () Bool)
(declare-fun %lbl%+259967 () Bool)
(declare-fun %lbl%+259943 () Bool)
(declare-fun %lbl%+259942 () Bool)
(declare-fun %lbl%+259941 () Bool)
(declare-fun %lbl%+259940 () Bool)
(declare-fun %lbl%+259939 () Bool)
(declare-fun %lbl%+259938 () Bool)
(declare-fun %lbl%+259937 () Bool)
(declare-fun %lbl%+259936 () Bool)
(declare-fun %lbl%+259935 () Bool)
(declare-fun %lbl%+266179 () Bool)
(declare-fun %lbl%+266187 () Bool)
(assert  (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0)
 :qid |typeInv:U_2_int|
 :pattern ( (int_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
 :qid |cast:U_2_int|
 :pattern ( (U_2_int x))
))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType)
 :qid |funType:int_2_U|
 :pattern ( (int_2_U arg0@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :qid |typeInv:U_2_real|
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))
 :qid |cast:U_2_real|
 :pattern ( (U_2_real x@@0))
))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType)
 :qid |funType:real_2_U|
 :pattern ( (real_2_U arg0@@2))
))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
 :qid |typeInv:U_2_bool|
 :pattern ( (bool_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))
 :qid |cast:U_2_bool|
 :pattern ( (U_2_bool x@@1))
))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType)
 :qid |funType:bool_2_U|
 :pattern ( (bool_2_U arg0@@4))
))))
(assert (forall ((x@@2 T@U) ) (! (UOrdering2 x@@2 x@@2)
 :qid |bg:subtype-refl|
 :no-pattern (U_2_int x@@2)
 :no-pattern (U_2_bool x@@2)
)))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@3)))
 (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z)))
 :qid |bg:subtype-trans|
 :pattern ( (UOrdering2 x@@3 y) (UOrdering2 y z))
)))
(assert (forall ((x@@4 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@4)))
 (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0))))
 :qid |bg:subtype-antisymm|
 :pattern ( (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4))
)))
(assert  (and (= (Ctor javaTypeType) 3) (= (type fixed.java.lang.Object) javaTypeType)))
(assert (forall ((w T@U) ) (!  (=> (and (= (type w) javaTypeType) (UOrdering2 fixed.java.lang.Object w)) (= fixed.java.lang.Object w))
 :pattern ( (UOrdering2 fixed.java.lang.Object w))
)))
(assert (= (type fixed.TokenHandler) javaTypeType))
(assert (not (= fixed.TokenHandler fixed.java.lang.Object)))
(assert (UOrdering2 fixed.TokenHandler fixed.java.lang.Object))
(assert (forall ((w@@0 T@U) ) (!  (=> (= (type w@@0) javaTypeType) (=> (and (UOrdering2 fixed.TokenHandler w@@0) (UOrdering2 w@@0 fixed.java.lang.Object)) (or (= fixed.TokenHandler w@@0) (= fixed.java.lang.Object w@@0))))
 :pattern ( (UOrdering2 fixed.TokenHandler w@@0) (UOrdering2 w@@0 fixed.java.lang.Object))
)))
(assert (forall ((w@@1 T@U) ) (!  (=> (and (= (type w@@1) javaTypeType) (UOrdering2 fixed.TokenHandler w@@1)) (or (= fixed.TokenHandler w@@1) (UOrdering2 fixed.java.lang.Object w@@1)))
 :pattern ( (UOrdering2 fixed.TokenHandler w@@1))
)))
(assert (forall ((arg0@@5 T@U) (arg1 T@U) ) (! (= (type (oneStep arg0@@5 arg1)) javaTypeType)
 :qid |funType:oneStep|
 :pattern ( (oneStep arg0@@5 arg1))
)))
(assert (forall ((w@@2 T@U) ) (!  (=> (and (= (type w@@2) javaTypeType) (UOrdering2 w@@2 fixed.TokenHandler)) (= (oneStep fixed.java.lang.Object w@@2) fixed.TokenHandler))
 :pattern ( (UOrdering2 w@@2 fixed.TokenHandler))
)))
(assert  (and (= (Ctor refType) 4) (= (type fixed.$StringConst0) refType)))
(assert (forall ((w@@3 T@U) ) (!  (=> (and (= (type w@@3) refType) (UOrdering2 fixed.$StringConst0 w@@3)) (= fixed.$StringConst0 w@@3))
 :pattern ( (UOrdering2 fixed.$StringConst0 w@@3))
)))
(assert (= (type fixed.java.lang.Cloneable) javaTypeType))
(assert (forall ((w@@4 T@U) ) (!  (=> (and (= (type w@@4) javaTypeType) (UOrdering2 fixed.java.lang.Cloneable w@@4)) (= fixed.java.lang.Cloneable w@@4))
 :pattern ( (UOrdering2 fixed.java.lang.Cloneable w@@4))
)))
(assert (= (type fixed.javax.crypto.Mac) javaTypeType))
(assert (not (= fixed.javax.crypto.Mac fixed.java.lang.Object)))
(assert (UOrdering2 fixed.javax.crypto.Mac fixed.java.lang.Object))
(assert (not (= fixed.javax.crypto.Mac fixed.java.lang.Cloneable)))
(assert (UOrdering2 fixed.javax.crypto.Mac fixed.java.lang.Cloneable))
(assert (forall ((w@@5 T@U) ) (!  (=> (= (type w@@5) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.Mac w@@5) (UOrdering2 w@@5 fixed.java.lang.Object)) (or (= fixed.javax.crypto.Mac w@@5) (= fixed.java.lang.Object w@@5))))
 :pattern ( (UOrdering2 fixed.javax.crypto.Mac w@@5) (UOrdering2 w@@5 fixed.java.lang.Object))
)))
(assert (forall ((w@@6 T@U) ) (!  (=> (= (type w@@6) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.Mac w@@6) (UOrdering2 w@@6 fixed.java.lang.Cloneable)) (or (= fixed.javax.crypto.Mac w@@6) (= fixed.java.lang.Cloneable w@@6))))
 :pattern ( (UOrdering2 fixed.javax.crypto.Mac w@@6) (UOrdering2 w@@6 fixed.java.lang.Cloneable))
)))
(assert (forall ((w@@7 T@U) ) (!  (=> (and (= (type w@@7) javaTypeType) (UOrdering2 fixed.javax.crypto.Mac w@@7)) (or (or (= fixed.javax.crypto.Mac w@@7) (UOrdering2 fixed.java.lang.Object w@@7)) (UOrdering2 fixed.java.lang.Cloneable w@@7)))
 :pattern ( (UOrdering2 fixed.javax.crypto.Mac w@@7))
)))
(assert (forall ((w@@8 T@U) ) (!  (=> (and (= (type w@@8) javaTypeType) (UOrdering2 w@@8 fixed.javax.crypto.Mac)) (= (oneStep fixed.java.lang.Object w@@8) fixed.javax.crypto.Mac))
 :pattern ( (UOrdering2 w@@8 fixed.javax.crypto.Mac))
)))
(assert (= (type fixed.java.io.Serializable) javaTypeType))
(assert (forall ((w@@9 T@U) ) (!  (=> (and (= (type w@@9) javaTypeType) (UOrdering2 fixed.java.io.Serializable w@@9)) (= fixed.java.io.Serializable w@@9))
 :pattern ( (UOrdering2 fixed.java.io.Serializable w@@9))
)))
(assert (= (type fixed.java.lang.Comparable) javaTypeType))
(assert (forall ((w@@10 T@U) ) (!  (=> (and (= (type w@@10) javaTypeType) (UOrdering2 fixed.java.lang.Comparable w@@10)) (= fixed.java.lang.Comparable w@@10))
 :pattern ( (UOrdering2 fixed.java.lang.Comparable w@@10))
)))
(assert (= (type fixed.java.lang.CharSequence) javaTypeType))
(assert (forall ((w@@11 T@U) ) (!  (=> (and (= (type w@@11) javaTypeType) (UOrdering2 fixed.java.lang.CharSequence w@@11)) (= fixed.java.lang.CharSequence w@@11))
 :pattern ( (UOrdering2 fixed.java.lang.CharSequence w@@11))
)))
(assert (= (type fixed.java.lang.String) javaTypeType))
(assert (not (= fixed.java.lang.String fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.Object))
(assert (not (= fixed.java.lang.String fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.io.Serializable))
(assert (not (= fixed.java.lang.String fixed.java.lang.Comparable)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.Comparable))
(assert (not (= fixed.java.lang.String fixed.java.lang.CharSequence)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.CharSequence))
(assert (forall ((w@@12 T@U) ) (!  (=> (= (type w@@12) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@12) (UOrdering2 w@@12 fixed.java.lang.Object)) (or (= fixed.java.lang.String w@@12) (= fixed.java.lang.Object w@@12))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@12) (UOrdering2 w@@12 fixed.java.lang.Object))
)))
(assert (forall ((w@@13 T@U) ) (!  (=> (= (type w@@13) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@13) (UOrdering2 w@@13 fixed.java.io.Serializable)) (or (= fixed.java.lang.String w@@13) (= fixed.java.io.Serializable w@@13))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@13) (UOrdering2 w@@13 fixed.java.io.Serializable))
)))
(assert (forall ((w@@14 T@U) ) (!  (=> (= (type w@@14) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@14) (UOrdering2 w@@14 fixed.java.lang.Comparable)) (or (= fixed.java.lang.String w@@14) (= fixed.java.lang.Comparable w@@14))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@14) (UOrdering2 w@@14 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@15 T@U) ) (!  (=> (= (type w@@15) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@15) (UOrdering2 w@@15 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.String w@@15) (= fixed.java.lang.CharSequence w@@15))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@15) (UOrdering2 w@@15 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@16 T@U) ) (!  (=> (and (= (type w@@16) javaTypeType) (UOrdering2 fixed.java.lang.String w@@16)) (or (or (or (or (= fixed.java.lang.String w@@16) (UOrdering2 fixed.java.lang.Object w@@16)) (UOrdering2 fixed.java.io.Serializable w@@16)) (UOrdering2 fixed.java.lang.Comparable w@@16)) (UOrdering2 fixed.java.lang.CharSequence w@@16)))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@16))
)))
(assert (forall ((w@@17 T@U) ) (!  (=> (and (= (type w@@17) javaTypeType) (UOrdering2 w@@17 fixed.java.lang.String)) (= (oneStep fixed.java.lang.Object w@@17) fixed.java.lang.String))
 :pattern ( (UOrdering2 w@@17 fixed.java.lang.String))
)))
(assert (= (type fixed.java.lang.Throwable) javaTypeType))
(assert (not (= fixed.java.lang.Throwable fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.lang.Object))
(assert (not (= fixed.java.lang.Throwable fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.io.Serializable))
(assert (forall ((w@@18 T@U) ) (!  (=> (= (type w@@18) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@18) (UOrdering2 w@@18 fixed.java.lang.Object)) (or (= fixed.java.lang.Throwable w@@18) (= fixed.java.lang.Object w@@18))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@18) (UOrdering2 w@@18 fixed.java.lang.Object))
)))
(assert (forall ((w@@19 T@U) ) (!  (=> (= (type w@@19) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@19) (UOrdering2 w@@19 fixed.java.io.Serializable)) (or (= fixed.java.lang.Throwable w@@19) (= fixed.java.io.Serializable w@@19))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@19) (UOrdering2 w@@19 fixed.java.io.Serializable))
)))
(assert (forall ((w@@20 T@U) ) (!  (=> (and (= (type w@@20) javaTypeType) (UOrdering2 fixed.java.lang.Throwable w@@20)) (or (or (= fixed.java.lang.Throwable w@@20) (UOrdering2 fixed.java.lang.Object w@@20)) (UOrdering2 fixed.java.io.Serializable w@@20)))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@20))
)))
(assert (forall ((w@@21 T@U) ) (!  (=> (and (= (type w@@21) javaTypeType) (UOrdering2 w@@21 fixed.java.lang.Throwable)) (= (oneStep fixed.java.lang.Object w@@21) fixed.java.lang.Throwable))
 :pattern ( (UOrdering2 w@@21 fixed.java.lang.Throwable))
)))
(assert (= (type fixed.java.lang.Exception) javaTypeType))
(assert (not (= fixed.java.lang.Exception fixed.java.lang.Throwable)))
(assert (UOrdering2 fixed.java.lang.Exception fixed.java.lang.Throwable))
(assert (forall ((w@@22 T@U) ) (!  (=> (= (type w@@22) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Exception w@@22) (UOrdering2 w@@22 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Exception w@@22) (= fixed.java.lang.Throwable w@@22))))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@22) (UOrdering2 w@@22 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@23 T@U) ) (!  (=> (and (= (type w@@23) javaTypeType) (UOrdering2 fixed.java.lang.Exception w@@23)) (or (= fixed.java.lang.Exception w@@23) (UOrdering2 fixed.java.lang.Throwable w@@23)))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@23))
)))
(assert (forall ((w@@24 T@U) ) (!  (=> (and (= (type w@@24) javaTypeType) (UOrdering2 w@@24 fixed.java.lang.Exception)) (= (oneStep fixed.java.lang.Throwable w@@24) fixed.java.lang.Exception))
 :pattern ( (UOrdering2 w@@24 fixed.java.lang.Exception))
)))
(assert (= (type fixed.java.security.GeneralSecurityException) javaTypeType))
(assert (not (= fixed.java.security.GeneralSecurityException fixed.java.lang.Exception)))
(assert (UOrdering2 fixed.java.security.GeneralSecurityException fixed.java.lang.Exception))
(assert (forall ((w@@25 T@U) ) (!  (=> (= (type w@@25) javaTypeType) (=> (and (UOrdering2 fixed.java.security.GeneralSecurityException w@@25) (UOrdering2 w@@25 fixed.java.lang.Exception)) (or (= fixed.java.security.GeneralSecurityException w@@25) (= fixed.java.lang.Exception w@@25))))
 :pattern ( (UOrdering2 fixed.java.security.GeneralSecurityException w@@25) (UOrdering2 w@@25 fixed.java.lang.Exception))
)))
(assert (forall ((w@@26 T@U) ) (!  (=> (and (= (type w@@26) javaTypeType) (UOrdering2 fixed.java.security.GeneralSecurityException w@@26)) (or (= fixed.java.security.GeneralSecurityException w@@26) (UOrdering2 fixed.java.lang.Exception w@@26)))
 :pattern ( (UOrdering2 fixed.java.security.GeneralSecurityException w@@26))
)))
(assert (forall ((w@@27 T@U) ) (!  (=> (and (= (type w@@27) javaTypeType) (UOrdering2 w@@27 fixed.java.security.GeneralSecurityException)) (= (oneStep fixed.java.lang.Exception w@@27) fixed.java.security.GeneralSecurityException))
 :pattern ( (UOrdering2 w@@27 fixed.java.security.GeneralSecurityException))
)))
(assert (= (type fixed.java.security.NoSuchAlgorithmException) javaTypeType))
(assert (not (= fixed.java.security.NoSuchAlgorithmException fixed.java.security.GeneralSecurityException)))
(assert (UOrdering2 fixed.java.security.NoSuchAlgorithmException fixed.java.security.GeneralSecurityException))
(assert (forall ((w@@28 T@U) ) (!  (=> (= (type w@@28) javaTypeType) (=> (and (UOrdering2 fixed.java.security.NoSuchAlgorithmException w@@28) (UOrdering2 w@@28 fixed.java.security.GeneralSecurityException)) (or (= fixed.java.security.NoSuchAlgorithmException w@@28) (= fixed.java.security.GeneralSecurityException w@@28))))
 :pattern ( (UOrdering2 fixed.java.security.NoSuchAlgorithmException w@@28) (UOrdering2 w@@28 fixed.java.security.GeneralSecurityException))
)))
(assert (forall ((w@@29 T@U) ) (!  (=> (and (= (type w@@29) javaTypeType) (UOrdering2 fixed.java.security.NoSuchAlgorithmException w@@29)) (or (= fixed.java.security.NoSuchAlgorithmException w@@29) (UOrdering2 fixed.java.security.GeneralSecurityException w@@29)))
 :pattern ( (UOrdering2 fixed.java.security.NoSuchAlgorithmException w@@29))
)))
(assert (forall ((w@@30 T@U) ) (!  (=> (and (= (type w@@30) javaTypeType) (UOrdering2 w@@30 fixed.java.security.NoSuchAlgorithmException)) (= (oneStep fixed.java.security.GeneralSecurityException w@@30) fixed.java.security.NoSuchAlgorithmException))
 :pattern ( (UOrdering2 w@@30 fixed.java.security.NoSuchAlgorithmException))
)))
(assert (= (type fixed.java.security.spec.KeySpec) javaTypeType))
(assert (forall ((w@@31 T@U) ) (!  (=> (and (= (type w@@31) javaTypeType) (UOrdering2 fixed.java.security.spec.KeySpec w@@31)) (= fixed.java.security.spec.KeySpec w@@31))
 :pattern ( (UOrdering2 fixed.java.security.spec.KeySpec w@@31))
)))
(assert (= (type fixed.java.security.Key) javaTypeType))
(assert (not (= fixed.java.security.Key fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.security.Key fixed.java.io.Serializable))
(assert (forall ((w@@32 T@U) ) (!  (=> (= (type w@@32) javaTypeType) (=> (and (UOrdering2 fixed.java.security.Key w@@32) (UOrdering2 w@@32 fixed.java.io.Serializable)) (or (= fixed.java.security.Key w@@32) (= fixed.java.io.Serializable w@@32))))
 :pattern ( (UOrdering2 fixed.java.security.Key w@@32) (UOrdering2 w@@32 fixed.java.io.Serializable))
)))
(assert (forall ((w@@33 T@U) ) (!  (=> (and (= (type w@@33) javaTypeType) (UOrdering2 fixed.java.security.Key w@@33)) (or (= fixed.java.security.Key w@@33) (UOrdering2 fixed.java.io.Serializable w@@33)))
 :pattern ( (UOrdering2 fixed.java.security.Key w@@33))
)))
(assert (= (type fixed.javax.security.auth.Destroyable) javaTypeType))
(assert (forall ((w@@34 T@U) ) (!  (=> (and (= (type w@@34) javaTypeType) (UOrdering2 fixed.javax.security.auth.Destroyable w@@34)) (= fixed.javax.security.auth.Destroyable w@@34))
 :pattern ( (UOrdering2 fixed.javax.security.auth.Destroyable w@@34))
)))
(assert (= (type fixed.javax.crypto.SecretKey) javaTypeType))
(assert (not (= fixed.javax.crypto.SecretKey fixed.java.security.Key)))
(assert (UOrdering2 fixed.javax.crypto.SecretKey fixed.java.security.Key))
(assert (not (= fixed.javax.crypto.SecretKey fixed.javax.security.auth.Destroyable)))
(assert (UOrdering2 fixed.javax.crypto.SecretKey fixed.javax.security.auth.Destroyable))
(assert (forall ((w@@35 T@U) ) (!  (=> (= (type w@@35) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.SecretKey w@@35) (UOrdering2 w@@35 fixed.java.security.Key)) (or (= fixed.javax.crypto.SecretKey w@@35) (= fixed.java.security.Key w@@35))))
 :pattern ( (UOrdering2 fixed.javax.crypto.SecretKey w@@35) (UOrdering2 w@@35 fixed.java.security.Key))
)))
(assert (forall ((w@@36 T@U) ) (!  (=> (= (type w@@36) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.SecretKey w@@36) (UOrdering2 w@@36 fixed.javax.security.auth.Destroyable)) (or (= fixed.javax.crypto.SecretKey w@@36) (= fixed.javax.security.auth.Destroyable w@@36))))
 :pattern ( (UOrdering2 fixed.javax.crypto.SecretKey w@@36) (UOrdering2 w@@36 fixed.javax.security.auth.Destroyable))
)))
(assert (forall ((w@@37 T@U) ) (!  (=> (and (= (type w@@37) javaTypeType) (UOrdering2 fixed.javax.crypto.SecretKey w@@37)) (or (or (= fixed.javax.crypto.SecretKey w@@37) (UOrdering2 fixed.java.security.Key w@@37)) (UOrdering2 fixed.javax.security.auth.Destroyable w@@37)))
 :pattern ( (UOrdering2 fixed.javax.crypto.SecretKey w@@37))
)))
(assert (= (type fixed.javax.crypto.spec.SecretKeySpec) javaTypeType))
(assert (not (= fixed.javax.crypto.spec.SecretKeySpec fixed.java.lang.Object)))
(assert (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec fixed.java.lang.Object))
(assert (not (= fixed.javax.crypto.spec.SecretKeySpec fixed.java.security.spec.KeySpec)))
(assert (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec fixed.java.security.spec.KeySpec))
(assert (not (= fixed.javax.crypto.spec.SecretKeySpec fixed.javax.crypto.SecretKey)))
(assert (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec fixed.javax.crypto.SecretKey))
(assert (forall ((w@@38 T@U) ) (!  (=> (= (type w@@38) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@38) (UOrdering2 w@@38 fixed.java.lang.Object)) (or (= fixed.javax.crypto.spec.SecretKeySpec w@@38) (= fixed.java.lang.Object w@@38))))
 :pattern ( (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@38) (UOrdering2 w@@38 fixed.java.lang.Object))
)))
(assert (forall ((w@@39 T@U) ) (!  (=> (= (type w@@39) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@39) (UOrdering2 w@@39 fixed.java.security.spec.KeySpec)) (or (= fixed.javax.crypto.spec.SecretKeySpec w@@39) (= fixed.java.security.spec.KeySpec w@@39))))
 :pattern ( (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@39) (UOrdering2 w@@39 fixed.java.security.spec.KeySpec))
)))
(assert (forall ((w@@40 T@U) ) (!  (=> (= (type w@@40) javaTypeType) (=> (and (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@40) (UOrdering2 w@@40 fixed.javax.crypto.SecretKey)) (or (= fixed.javax.crypto.spec.SecretKeySpec w@@40) (= fixed.javax.crypto.SecretKey w@@40))))
 :pattern ( (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@40) (UOrdering2 w@@40 fixed.javax.crypto.SecretKey))
)))
(assert (forall ((w@@41 T@U) ) (!  (=> (and (= (type w@@41) javaTypeType) (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@41)) (or (or (or (= fixed.javax.crypto.spec.SecretKeySpec w@@41) (UOrdering2 fixed.java.lang.Object w@@41)) (UOrdering2 fixed.java.security.spec.KeySpec w@@41)) (UOrdering2 fixed.javax.crypto.SecretKey w@@41)))
 :pattern ( (UOrdering2 fixed.javax.crypto.spec.SecretKeySpec w@@41))
)))
(assert (forall ((w@@42 T@U) ) (!  (=> (and (= (type w@@42) javaTypeType) (UOrdering2 w@@42 fixed.javax.crypto.spec.SecretKeySpec)) (= (oneStep fixed.java.lang.Object w@@42) fixed.javax.crypto.spec.SecretKeySpec))
 :pattern ( (UOrdering2 w@@42 fixed.javax.crypto.spec.SecretKeySpec))
)))
(assert (= (type fixed.java.lang.RuntimeException) javaTypeType))
(assert (not (= fixed.java.lang.RuntimeException fixed.java.lang.Exception)))
(assert (UOrdering2 fixed.java.lang.RuntimeException fixed.java.lang.Exception))
(assert (forall ((w@@43 T@U) ) (!  (=> (= (type w@@43) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.RuntimeException w@@43) (UOrdering2 w@@43 fixed.java.lang.Exception)) (or (= fixed.java.lang.RuntimeException w@@43) (= fixed.java.lang.Exception w@@43))))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@43) (UOrdering2 w@@43 fixed.java.lang.Exception))
)))
(assert (forall ((w@@44 T@U) ) (!  (=> (and (= (type w@@44) javaTypeType) (UOrdering2 fixed.java.lang.RuntimeException w@@44)) (or (= fixed.java.lang.RuntimeException w@@44) (UOrdering2 fixed.java.lang.Exception w@@44)))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@44))
)))
(assert (forall ((w@@45 T@U) ) (!  (=> (and (= (type w@@45) javaTypeType) (UOrdering2 w@@45 fixed.java.lang.RuntimeException)) (= (oneStep fixed.java.lang.Exception w@@45) fixed.java.lang.RuntimeException))
 :pattern ( (UOrdering2 w@@45 fixed.java.lang.RuntimeException))
)))
(assert (= (type fixed.java.security.KeyException) javaTypeType))
(assert (not (= fixed.java.security.KeyException fixed.java.security.GeneralSecurityException)))
(assert (UOrdering2 fixed.java.security.KeyException fixed.java.security.GeneralSecurityException))
(assert (forall ((w@@46 T@U) ) (!  (=> (= (type w@@46) javaTypeType) (=> (and (UOrdering2 fixed.java.security.KeyException w@@46) (UOrdering2 w@@46 fixed.java.security.GeneralSecurityException)) (or (= fixed.java.security.KeyException w@@46) (= fixed.java.security.GeneralSecurityException w@@46))))
 :pattern ( (UOrdering2 fixed.java.security.KeyException w@@46) (UOrdering2 w@@46 fixed.java.security.GeneralSecurityException))
)))
(assert (forall ((w@@47 T@U) ) (!  (=> (and (= (type w@@47) javaTypeType) (UOrdering2 fixed.java.security.KeyException w@@47)) (or (= fixed.java.security.KeyException w@@47) (UOrdering2 fixed.java.security.GeneralSecurityException w@@47)))
 :pattern ( (UOrdering2 fixed.java.security.KeyException w@@47))
)))
(assert (forall ((w@@48 T@U) ) (!  (=> (and (= (type w@@48) javaTypeType) (UOrdering2 w@@48 fixed.java.security.KeyException)) (= (oneStep fixed.java.security.GeneralSecurityException w@@48) fixed.java.security.KeyException))
 :pattern ( (UOrdering2 w@@48 fixed.java.security.KeyException))
)))
(assert (= (type fixed.java.security.InvalidKeyException) javaTypeType))
(assert (not (= fixed.java.security.InvalidKeyException fixed.java.security.KeyException)))
(assert (UOrdering2 fixed.java.security.InvalidKeyException fixed.java.security.KeyException))
(assert (forall ((w@@49 T@U) ) (!  (=> (= (type w@@49) javaTypeType) (=> (and (UOrdering2 fixed.java.security.InvalidKeyException w@@49) (UOrdering2 w@@49 fixed.java.security.KeyException)) (or (= fixed.java.security.InvalidKeyException w@@49) (= fixed.java.security.KeyException w@@49))))
 :pattern ( (UOrdering2 fixed.java.security.InvalidKeyException w@@49) (UOrdering2 w@@49 fixed.java.security.KeyException))
)))
(assert (forall ((w@@50 T@U) ) (!  (=> (and (= (type w@@50) javaTypeType) (UOrdering2 fixed.java.security.InvalidKeyException w@@50)) (or (= fixed.java.security.InvalidKeyException w@@50) (UOrdering2 fixed.java.security.KeyException w@@50)))
 :pattern ( (UOrdering2 fixed.java.security.InvalidKeyException w@@50))
)))
(assert (forall ((w@@51 T@U) ) (!  (=> (and (= (type w@@51) javaTypeType) (UOrdering2 w@@51 fixed.java.security.InvalidKeyException)) (= (oneStep fixed.java.security.KeyException w@@51) fixed.java.security.InvalidKeyException))
 :pattern ( (UOrdering2 w@@51 fixed.java.security.InvalidKeyException))
)))
(assert (= (type fixed.java.lang.IllegalStateException) javaTypeType))
(assert (not (= fixed.java.lang.IllegalStateException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.IllegalStateException fixed.java.lang.RuntimeException))
(assert (forall ((w@@52 T@U) ) (!  (=> (= (type w@@52) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.IllegalStateException w@@52) (UOrdering2 w@@52 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.IllegalStateException w@@52) (= fixed.java.lang.RuntimeException w@@52))))
 :pattern ( (UOrdering2 fixed.java.lang.IllegalStateException w@@52) (UOrdering2 w@@52 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@53 T@U) ) (!  (=> (and (= (type w@@53) javaTypeType) (UOrdering2 fixed.java.lang.IllegalStateException w@@53)) (or (= fixed.java.lang.IllegalStateException w@@53) (UOrdering2 fixed.java.lang.RuntimeException w@@53)))
 :pattern ( (UOrdering2 fixed.java.lang.IllegalStateException w@@53))
)))
(assert (forall ((w@@54 T@U) ) (!  (=> (and (= (type w@@54) javaTypeType) (UOrdering2 w@@54 fixed.java.lang.IllegalStateException)) (= (oneStep fixed.java.lang.RuntimeException w@@54) fixed.java.lang.IllegalStateException))
 :pattern ( (UOrdering2 w@@54 fixed.java.lang.IllegalStateException))
)))
(assert (= (type fixed.java.lang.Appendable) javaTypeType))
(assert (forall ((w@@55 T@U) ) (!  (=> (and (= (type w@@55) javaTypeType) (UOrdering2 fixed.java.lang.Appendable w@@55)) (= fixed.java.lang.Appendable w@@55))
 :pattern ( (UOrdering2 fixed.java.lang.Appendable w@@55))
)))
(assert (= (type fixed.java.lang.AbstractStringBuilder) javaTypeType))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.Object))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.Appendable)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.Appendable))
(assert (not (= fixed.java.lang.AbstractStringBuilder fixed.java.lang.CharSequence)))
(assert (UOrdering2 fixed.java.lang.AbstractStringBuilder fixed.java.lang.CharSequence))
(assert (forall ((w@@56 T@U) ) (!  (=> (= (type w@@56) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@56) (UOrdering2 w@@56 fixed.java.lang.Object)) (or (= fixed.java.lang.AbstractStringBuilder w@@56) (= fixed.java.lang.Object w@@56))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@56) (UOrdering2 w@@56 fixed.java.lang.Object))
)))
(assert (forall ((w@@57 T@U) ) (!  (=> (= (type w@@57) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@57) (UOrdering2 w@@57 fixed.java.lang.Appendable)) (or (= fixed.java.lang.AbstractStringBuilder w@@57) (= fixed.java.lang.Appendable w@@57))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@57) (UOrdering2 w@@57 fixed.java.lang.Appendable))
)))
(assert (forall ((w@@58 T@U) ) (!  (=> (= (type w@@58) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@58) (UOrdering2 w@@58 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.AbstractStringBuilder w@@58) (= fixed.java.lang.CharSequence w@@58))))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@58) (UOrdering2 w@@58 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@59 T@U) ) (!  (=> (and (= (type w@@59) javaTypeType) (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@59)) (or (or (or (= fixed.java.lang.AbstractStringBuilder w@@59) (UOrdering2 fixed.java.lang.Object w@@59)) (UOrdering2 fixed.java.lang.Appendable w@@59)) (UOrdering2 fixed.java.lang.CharSequence w@@59)))
 :pattern ( (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@59))
)))
(assert (forall ((w@@60 T@U) ) (!  (=> (and (= (type w@@60) javaTypeType) (UOrdering2 w@@60 fixed.java.lang.AbstractStringBuilder)) (= (oneStep fixed.java.lang.Object w@@60) fixed.java.lang.AbstractStringBuilder))
 :pattern ( (UOrdering2 w@@60 fixed.java.lang.AbstractStringBuilder))
)))
(assert (= (type fixed.java.lang.StringBuilder) javaTypeType))
(assert (not (= fixed.java.lang.StringBuilder fixed.java.lang.AbstractStringBuilder)))
(assert (UOrdering2 fixed.java.lang.StringBuilder fixed.java.lang.AbstractStringBuilder))
(assert (not (= fixed.java.lang.StringBuilder fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.StringBuilder fixed.java.io.Serializable))
(assert (not (= fixed.java.lang.StringBuilder fixed.java.lang.CharSequence)))
(assert (UOrdering2 fixed.java.lang.StringBuilder fixed.java.lang.CharSequence))
(assert (forall ((w@@61 T@U) ) (!  (=> (= (type w@@61) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.StringBuilder w@@61) (UOrdering2 w@@61 fixed.java.lang.AbstractStringBuilder)) (or (= fixed.java.lang.StringBuilder w@@61) (= fixed.java.lang.AbstractStringBuilder w@@61))))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@61) (UOrdering2 w@@61 fixed.java.lang.AbstractStringBuilder))
)))
(assert (forall ((w@@62 T@U) ) (!  (=> (= (type w@@62) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.StringBuilder w@@62) (UOrdering2 w@@62 fixed.java.io.Serializable)) (or (= fixed.java.lang.StringBuilder w@@62) (= fixed.java.io.Serializable w@@62))))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@62) (UOrdering2 w@@62 fixed.java.io.Serializable))
)))
(assert (forall ((w@@63 T@U) ) (!  (=> (= (type w@@63) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.StringBuilder w@@63) (UOrdering2 w@@63 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.StringBuilder w@@63) (= fixed.java.lang.CharSequence w@@63))))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@63) (UOrdering2 w@@63 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@64 T@U) ) (!  (=> (and (= (type w@@64) javaTypeType) (UOrdering2 fixed.java.lang.StringBuilder w@@64)) (or (or (or (= fixed.java.lang.StringBuilder w@@64) (UOrdering2 fixed.java.lang.AbstractStringBuilder w@@64)) (UOrdering2 fixed.java.io.Serializable w@@64)) (UOrdering2 fixed.java.lang.CharSequence w@@64)))
 :pattern ( (UOrdering2 fixed.java.lang.StringBuilder w@@64))
)))
(assert (forall ((w@@65 T@U) ) (!  (=> (and (= (type w@@65) javaTypeType) (UOrdering2 w@@65 fixed.java.lang.StringBuilder)) (= (oneStep fixed.java.lang.AbstractStringBuilder w@@65) fixed.java.lang.StringBuilder))
 :pattern ( (UOrdering2 w@@65 fixed.java.lang.StringBuilder))
)))
(assert (= (type fixed.$StringConst1) refType))
(assert (forall ((w@@66 T@U) ) (!  (=> (and (= (type w@@66) refType) (UOrdering2 fixed.$StringConst1 w@@66)) (= fixed.$StringConst1 w@@66))
 :pattern ( (UOrdering2 fixed.$StringConst1 w@@66))
)))
(assert (= (type fixed.com.jdriven.stateless.security.User) javaTypeType))
(assert (forall ((w@@67 T@U) ) (!  (=> (and (= (type w@@67) javaTypeType) (UOrdering2 fixed.com.jdriven.stateless.security.User w@@67)) (= fixed.com.jdriven.stateless.security.User w@@67))
 :pattern ( (UOrdering2 fixed.com.jdriven.stateless.security.User w@@67))
)))
(assert (= (type fixed.$StringConst2) refType))
(assert (forall ((w@@68 T@U) ) (!  (=> (and (= (type w@@68) refType) (UOrdering2 fixed.$StringConst2 w@@68)) (= fixed.$StringConst2 w@@68))
 :pattern ( (UOrdering2 fixed.$StringConst2 w@@68))
)))
(assert (= (type fixed.java.lang.NullPointerException) javaTypeType))
(assert (not (= fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException))
(assert (forall ((w@@69 T@U) ) (!  (=> (= (type w@@69) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.NullPointerException w@@69) (UOrdering2 w@@69 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.NullPointerException w@@69) (= fixed.java.lang.RuntimeException w@@69))))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@69) (UOrdering2 w@@69 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@70 T@U) ) (!  (=> (and (= (type w@@70) javaTypeType) (UOrdering2 fixed.java.lang.NullPointerException w@@70)) (or (= fixed.java.lang.NullPointerException w@@70) (UOrdering2 fixed.java.lang.RuntimeException w@@70)))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@70))
)))
(assert (forall ((w@@71 T@U) ) (!  (=> (and (= (type w@@71) javaTypeType) (UOrdering2 w@@71 fixed.java.lang.NullPointerException)) (= (oneStep fixed.java.lang.RuntimeException w@@71) fixed.java.lang.NullPointerException))
 :pattern ( (UOrdering2 w@@71 fixed.java.lang.NullPointerException))
)))
(assert (= (type fixed.java.lang.IndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException))
(assert (forall ((w@@72 T@U) ) (!  (=> (= (type w@@72) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@72) (UOrdering2 w@@72 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@72) (= fixed.java.lang.RuntimeException w@@72))))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@72) (UOrdering2 w@@72 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@73 T@U) ) (!  (=> (and (= (type w@@73) javaTypeType) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@73)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@73) (UOrdering2 fixed.java.lang.RuntimeException w@@73)))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@73))
)))
(assert (forall ((w@@74 T@U) ) (!  (=> (and (= (type w@@74) javaTypeType) (UOrdering2 w@@74 fixed.java.lang.IndexOutOfBoundsException)) (= (oneStep fixed.java.lang.RuntimeException w@@74) fixed.java.lang.IndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@74 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (= (type fixed.java.lang.ArrayIndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException)))
(assert (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException))
(assert (forall ((w@@75 T@U) ) (!  (=> (= (type w@@75) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@75) (UOrdering2 w@@75 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@75) (= fixed.java.lang.IndexOutOfBoundsException w@@75))))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@75) (UOrdering2 w@@75 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@76 T@U) ) (!  (=> (and (= (type w@@76) javaTypeType) (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@76)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@76) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@76)))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@76))
)))
(assert (forall ((w@@77 T@U) ) (!  (=> (and (= (type w@@77) javaTypeType) (UOrdering2 w@@77 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= (oneStep fixed.java.lang.IndexOutOfBoundsException w@@77) fixed.java.lang.ArrayIndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@77 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (= (type fixed.java.lang.IllegalArgumentException) javaTypeType))
(assert (not (= fixed.java.lang.IllegalArgumentException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.IllegalArgumentException fixed.java.lang.RuntimeException))
(assert (forall ((w@@78 T@U) ) (!  (=> (= (type w@@78) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.IllegalArgumentException w@@78) (UOrdering2 w@@78 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.IllegalArgumentException w@@78) (= fixed.java.lang.RuntimeException w@@78))))
 :pattern ( (UOrdering2 fixed.java.lang.IllegalArgumentException w@@78) (UOrdering2 w@@78 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@79 T@U) ) (!  (=> (and (= (type w@@79) javaTypeType) (UOrdering2 fixed.java.lang.IllegalArgumentException w@@79)) (or (= fixed.java.lang.IllegalArgumentException w@@79) (UOrdering2 fixed.java.lang.RuntimeException w@@79)))
 :pattern ( (UOrdering2 fixed.java.lang.IllegalArgumentException w@@79))
)))
(assert (forall ((w@@80 T@U) ) (!  (=> (and (= (type w@@80) javaTypeType) (UOrdering2 w@@80 fixed.java.lang.IllegalArgumentException)) (= (oneStep fixed.java.lang.RuntimeException w@@80) fixed.java.lang.IllegalArgumentException))
 :pattern ( (UOrdering2 w@@80 fixed.java.lang.IllegalArgumentException))
)))
(assert (= (type fixed.java.util.Date) javaTypeType))
(assert (not (= fixed.java.util.Date fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.util.Date fixed.java.lang.Object))
(assert (not (= fixed.java.util.Date fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.util.Date fixed.java.io.Serializable))
(assert (not (= fixed.java.util.Date fixed.java.lang.Cloneable)))
(assert (UOrdering2 fixed.java.util.Date fixed.java.lang.Cloneable))
(assert (not (= fixed.java.util.Date fixed.java.lang.Comparable)))
(assert (UOrdering2 fixed.java.util.Date fixed.java.lang.Comparable))
(assert (forall ((w@@81 T@U) ) (!  (=> (= (type w@@81) javaTypeType) (=> (and (UOrdering2 fixed.java.util.Date w@@81) (UOrdering2 w@@81 fixed.java.lang.Object)) (or (= fixed.java.util.Date w@@81) (= fixed.java.lang.Object w@@81))))
 :pattern ( (UOrdering2 fixed.java.util.Date w@@81) (UOrdering2 w@@81 fixed.java.lang.Object))
)))
(assert (forall ((w@@82 T@U) ) (!  (=> (= (type w@@82) javaTypeType) (=> (and (UOrdering2 fixed.java.util.Date w@@82) (UOrdering2 w@@82 fixed.java.io.Serializable)) (or (= fixed.java.util.Date w@@82) (= fixed.java.io.Serializable w@@82))))
 :pattern ( (UOrdering2 fixed.java.util.Date w@@82) (UOrdering2 w@@82 fixed.java.io.Serializable))
)))
(assert (forall ((w@@83 T@U) ) (!  (=> (= (type w@@83) javaTypeType) (=> (and (UOrdering2 fixed.java.util.Date w@@83) (UOrdering2 w@@83 fixed.java.lang.Cloneable)) (or (= fixed.java.util.Date w@@83) (= fixed.java.lang.Cloneable w@@83))))
 :pattern ( (UOrdering2 fixed.java.util.Date w@@83) (UOrdering2 w@@83 fixed.java.lang.Cloneable))
)))
(assert (forall ((w@@84 T@U) ) (!  (=> (= (type w@@84) javaTypeType) (=> (and (UOrdering2 fixed.java.util.Date w@@84) (UOrdering2 w@@84 fixed.java.lang.Comparable)) (or (= fixed.java.util.Date w@@84) (= fixed.java.lang.Comparable w@@84))))
 :pattern ( (UOrdering2 fixed.java.util.Date w@@84) (UOrdering2 w@@84 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@85 T@U) ) (!  (=> (and (= (type w@@85) javaTypeType) (UOrdering2 fixed.java.util.Date w@@85)) (or (or (or (or (= fixed.java.util.Date w@@85) (UOrdering2 fixed.java.lang.Object w@@85)) (UOrdering2 fixed.java.io.Serializable w@@85)) (UOrdering2 fixed.java.lang.Cloneable w@@85)) (UOrdering2 fixed.java.lang.Comparable w@@85)))
 :pattern ( (UOrdering2 fixed.java.util.Date w@@85))
)))
(assert (forall ((w@@86 T@U) ) (!  (=> (and (= (type w@@86) javaTypeType) (UOrdering2 w@@86 fixed.java.util.Date)) (= (oneStep fixed.java.lang.Object w@@86) fixed.java.util.Date))
 :pattern ( (UOrdering2 w@@86 fixed.java.util.Date))
)))
(assert (= (type fixed.sg.edu.nus.comp.tsunami.safe.Safe) javaTypeType))
(assert (not (= fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object)))
(assert (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object))
(assert (forall ((w@@87 T@U) ) (!  (=> (= (type w@@87) javaTypeType) (=> (and (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@87) (UOrdering2 w@@87 fixed.java.lang.Object)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@87) (= fixed.java.lang.Object w@@87))))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@87) (UOrdering2 w@@87 fixed.java.lang.Object))
)))
(assert (forall ((w@@88 T@U) ) (!  (=> (and (= (type w@@88) javaTypeType) (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@88)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@88) (UOrdering2 fixed.java.lang.Object w@@88)))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@88))
)))
(assert (forall ((w@@89 T@U) ) (!  (=> (and (= (type w@@89) javaTypeType) (UOrdering2 w@@89 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= (oneStep fixed.java.lang.Object w@@89) fixed.sg.edu.nus.comp.tsunami.safe.Safe))
 :pattern ( (UOrdering2 w@@89 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (= (type fixed.java.lang.Boolean) javaTypeType))
(assert (not (= fixed.java.lang.Boolean fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Boolean fixed.java.lang.Object))
(assert (not (= fixed.java.lang.Boolean fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.Boolean fixed.java.io.Serializable))
(assert (not (= fixed.java.lang.Boolean fixed.java.lang.Comparable)))
(assert (UOrdering2 fixed.java.lang.Boolean fixed.java.lang.Comparable))
(assert (forall ((w@@90 T@U) ) (!  (=> (= (type w@@90) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Boolean w@@90) (UOrdering2 w@@90 fixed.java.lang.Object)) (or (= fixed.java.lang.Boolean w@@90) (= fixed.java.lang.Object w@@90))))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@90) (UOrdering2 w@@90 fixed.java.lang.Object))
)))
(assert (forall ((w@@91 T@U) ) (!  (=> (= (type w@@91) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Boolean w@@91) (UOrdering2 w@@91 fixed.java.io.Serializable)) (or (= fixed.java.lang.Boolean w@@91) (= fixed.java.io.Serializable w@@91))))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@91) (UOrdering2 w@@91 fixed.java.io.Serializable))
)))
(assert (forall ((w@@92 T@U) ) (!  (=> (= (type w@@92) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Boolean w@@92) (UOrdering2 w@@92 fixed.java.lang.Comparable)) (or (= fixed.java.lang.Boolean w@@92) (= fixed.java.lang.Comparable w@@92))))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@92) (UOrdering2 w@@92 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@93 T@U) ) (!  (=> (and (= (type w@@93) javaTypeType) (UOrdering2 fixed.java.lang.Boolean w@@93)) (or (or (or (= fixed.java.lang.Boolean w@@93) (UOrdering2 fixed.java.lang.Object w@@93)) (UOrdering2 fixed.java.io.Serializable w@@93)) (UOrdering2 fixed.java.lang.Comparable w@@93)))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@93))
)))
(assert (forall ((w@@94 T@U) ) (!  (=> (and (= (type w@@94) javaTypeType) (UOrdering2 w@@94 fixed.java.lang.Boolean)) (= (oneStep fixed.java.lang.Object w@@94) fixed.java.lang.Boolean))
 :pattern ( (UOrdering2 w@@94 fixed.java.lang.Boolean))
)))
(assert (= (type fixed.java.lang.ClassCastException) javaTypeType))
(assert (not (= fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException))
(assert (forall ((w@@95 T@U) ) (!  (=> (= (type w@@95) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ClassCastException w@@95) (UOrdering2 w@@95 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.ClassCastException w@@95) (= fixed.java.lang.RuntimeException w@@95))))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@95) (UOrdering2 w@@95 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@96 T@U) ) (!  (=> (and (= (type w@@96) javaTypeType) (UOrdering2 fixed.java.lang.ClassCastException w@@96)) (or (= fixed.java.lang.ClassCastException w@@96) (UOrdering2 fixed.java.lang.RuntimeException w@@96)))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@96))
)))
(assert (forall ((w@@97 T@U) ) (!  (=> (and (= (type w@@97) javaTypeType) (UOrdering2 w@@97 fixed.java.lang.ClassCastException)) (= (oneStep fixed.java.lang.RuntimeException w@@97) fixed.java.lang.ClassCastException))
 :pattern ( (UOrdering2 w@@97 fixed.java.lang.ClassCastException))
)))
(assert (= (type fixed.$StringConst3) refType))
(assert (forall ((w@@98 T@U) ) (!  (=> (and (= (type w@@98) refType) (UOrdering2 fixed.$StringConst3 w@@98)) (= fixed.$StringConst3 w@@98))
 :pattern ( (UOrdering2 fixed.$StringConst3 w@@98))
)))
(assert (= (type fixed.com.fasterxml.jackson.databind.ObjectMapper) javaTypeType))
(assert (forall ((w@@99 T@U) ) (!  (=> (and (= (type w@@99) javaTypeType) (UOrdering2 fixed.com.fasterxml.jackson.databind.ObjectMapper w@@99)) (= fixed.com.fasterxml.jackson.databind.ObjectMapper w@@99))
 :pattern ( (UOrdering2 fixed.com.fasterxml.jackson.databind.ObjectMapper w@@99))
)))
(assert (= (type fixed.com.fasterxml.jackson.core.JsonProcessingException) javaTypeType))
(assert (forall ((w@@100 T@U) ) (!  (=> (and (= (type w@@100) javaTypeType) (UOrdering2 fixed.com.fasterxml.jackson.core.JsonProcessingException w@@100)) (= fixed.com.fasterxml.jackson.core.JsonProcessingException w@@100))
 :pattern ( (UOrdering2 fixed.com.fasterxml.jackson.core.JsonProcessingException w@@100))
)))
(assert (= (type fixed.javax.xml.bind.DatatypeConverter) javaTypeType))
(assert (not (= fixed.javax.xml.bind.DatatypeConverter fixed.java.lang.Object)))
(assert (UOrdering2 fixed.javax.xml.bind.DatatypeConverter fixed.java.lang.Object))
(assert (forall ((w@@101 T@U) ) (!  (=> (= (type w@@101) javaTypeType) (=> (and (UOrdering2 fixed.javax.xml.bind.DatatypeConverter w@@101) (UOrdering2 w@@101 fixed.java.lang.Object)) (or (= fixed.javax.xml.bind.DatatypeConverter w@@101) (= fixed.java.lang.Object w@@101))))
 :pattern ( (UOrdering2 fixed.javax.xml.bind.DatatypeConverter w@@101) (UOrdering2 w@@101 fixed.java.lang.Object))
)))
(assert (forall ((w@@102 T@U) ) (!  (=> (and (= (type w@@102) javaTypeType) (UOrdering2 fixed.javax.xml.bind.DatatypeConverter w@@102)) (or (= fixed.javax.xml.bind.DatatypeConverter w@@102) (UOrdering2 fixed.java.lang.Object w@@102)))
 :pattern ( (UOrdering2 fixed.javax.xml.bind.DatatypeConverter w@@102))
)))
(assert (forall ((w@@103 T@U) ) (!  (=> (and (= (type w@@103) javaTypeType) (UOrdering2 w@@103 fixed.javax.xml.bind.DatatypeConverter)) (= (oneStep fixed.java.lang.Object w@@103) fixed.javax.xml.bind.DatatypeConverter))
 :pattern ( (UOrdering2 w@@103 fixed.javax.xml.bind.DatatypeConverter))
)))
(assert (forall ((w@@104 T@U) ) (!  (=> (and (= (type w@@104) javaTypeType) (UOrdering2 w@@104 fixed.java.lang.Object)) (or (or (or (or (or (or (or (or (or (or (= fixed.java.lang.Object w@@104) (UOrdering2 w@@104 fixed.TokenHandler)) (UOrdering2 w@@104 fixed.javax.crypto.Mac)) (UOrdering2 w@@104 fixed.java.lang.String)) (UOrdering2 w@@104 fixed.java.lang.Throwable)) (UOrdering2 w@@104 fixed.javax.crypto.spec.SecretKeySpec)) (UOrdering2 w@@104 fixed.java.lang.AbstractStringBuilder)) (UOrdering2 w@@104 fixed.java.util.Date)) (UOrdering2 w@@104 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (UOrdering2 w@@104 fixed.java.lang.Boolean)) (UOrdering2 w@@104 fixed.javax.xml.bind.DatatypeConverter)))
 :pattern ( (UOrdering2 w@@104 fixed.java.lang.Object))
)))
(assert (forall ((w@@105 T@U) ) (!  (=> (and (= (type w@@105) javaTypeType) (UOrdering2 w@@105 fixed.TokenHandler)) (= fixed.TokenHandler w@@105))
 :pattern ( (UOrdering2 w@@105 fixed.TokenHandler))
)))
(assert (forall ((w@@106 T@U) ) (!  (=> (and (= (type w@@106) refType) (UOrdering2 w@@106 fixed.$StringConst0)) (= fixed.$StringConst0 w@@106))
 :pattern ( (UOrdering2 w@@106 fixed.$StringConst0))
)))
(assert (forall ((w@@107 T@U) ) (!  (=> (and (= (type w@@107) javaTypeType) (UOrdering2 w@@107 fixed.java.lang.Cloneable)) (or (or (= fixed.java.lang.Cloneable w@@107) (UOrdering2 w@@107 fixed.javax.crypto.Mac)) (UOrdering2 w@@107 fixed.java.util.Date)))
 :pattern ( (UOrdering2 w@@107 fixed.java.lang.Cloneable))
)))
(assert (forall ((w@@108 T@U) ) (!  (=> (and (= (type w@@108) javaTypeType) (UOrdering2 w@@108 fixed.javax.crypto.Mac)) (= fixed.javax.crypto.Mac w@@108))
 :pattern ( (UOrdering2 w@@108 fixed.javax.crypto.Mac))
)))
(assert (forall ((w@@109 T@U) ) (!  (=> (and (= (type w@@109) javaTypeType) (UOrdering2 w@@109 fixed.java.io.Serializable)) (or (or (or (or (or (or (= fixed.java.io.Serializable w@@109) (UOrdering2 w@@109 fixed.java.lang.String)) (UOrdering2 w@@109 fixed.java.lang.Throwable)) (UOrdering2 w@@109 fixed.java.security.Key)) (UOrdering2 w@@109 fixed.java.lang.StringBuilder)) (UOrdering2 w@@109 fixed.java.util.Date)) (UOrdering2 w@@109 fixed.java.lang.Boolean)))
 :pattern ( (UOrdering2 w@@109 fixed.java.io.Serializable))
)))
(assert (forall ((w@@110 T@U) ) (!  (=> (and (= (type w@@110) javaTypeType) (UOrdering2 w@@110 fixed.java.lang.Comparable)) (or (or (or (= fixed.java.lang.Comparable w@@110) (UOrdering2 w@@110 fixed.java.lang.String)) (UOrdering2 w@@110 fixed.java.util.Date)) (UOrdering2 w@@110 fixed.java.lang.Boolean)))
 :pattern ( (UOrdering2 w@@110 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@111 T@U) ) (!  (=> (and (= (type w@@111) javaTypeType) (UOrdering2 w@@111 fixed.java.lang.CharSequence)) (or (or (or (= fixed.java.lang.CharSequence w@@111) (UOrdering2 w@@111 fixed.java.lang.String)) (UOrdering2 w@@111 fixed.java.lang.AbstractStringBuilder)) (UOrdering2 w@@111 fixed.java.lang.StringBuilder)))
 :pattern ( (UOrdering2 w@@111 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@112 T@U) ) (!  (=> (and (= (type w@@112) javaTypeType) (UOrdering2 w@@112 fixed.java.lang.String)) (= fixed.java.lang.String w@@112))
 :pattern ( (UOrdering2 w@@112 fixed.java.lang.String))
)))
(assert (forall ((w@@113 T@U) ) (!  (=> (and (= (type w@@113) javaTypeType) (UOrdering2 w@@113 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Throwable w@@113) (UOrdering2 w@@113 fixed.java.lang.Exception)))
 :pattern ( (UOrdering2 w@@113 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@114 T@U) ) (!  (=> (and (= (type w@@114) javaTypeType) (UOrdering2 w@@114 fixed.java.lang.Exception)) (or (or (= fixed.java.lang.Exception w@@114) (UOrdering2 w@@114 fixed.java.security.GeneralSecurityException)) (UOrdering2 w@@114 fixed.java.lang.RuntimeException)))
 :pattern ( (UOrdering2 w@@114 fixed.java.lang.Exception))
)))
(assert (forall ((w@@115 T@U) ) (!  (=> (and (= (type w@@115) javaTypeType) (UOrdering2 w@@115 fixed.java.security.GeneralSecurityException)) (or (or (= fixed.java.security.GeneralSecurityException w@@115) (UOrdering2 w@@115 fixed.java.security.NoSuchAlgorithmException)) (UOrdering2 w@@115 fixed.java.security.KeyException)))
 :pattern ( (UOrdering2 w@@115 fixed.java.security.GeneralSecurityException))
)))
(assert (forall ((w@@116 T@U) ) (!  (=> (and (= (type w@@116) javaTypeType) (UOrdering2 w@@116 fixed.java.security.NoSuchAlgorithmException)) (= fixed.java.security.NoSuchAlgorithmException w@@116))
 :pattern ( (UOrdering2 w@@116 fixed.java.security.NoSuchAlgorithmException))
)))
(assert (forall ((w@@117 T@U) ) (!  (=> (and (= (type w@@117) javaTypeType) (UOrdering2 w@@117 fixed.java.security.spec.KeySpec)) (or (= fixed.java.security.spec.KeySpec w@@117) (UOrdering2 w@@117 fixed.javax.crypto.spec.SecretKeySpec)))
 :pattern ( (UOrdering2 w@@117 fixed.java.security.spec.KeySpec))
)))
(assert (forall ((w@@118 T@U) ) (!  (=> (and (= (type w@@118) javaTypeType) (UOrdering2 w@@118 fixed.java.security.Key)) (or (= fixed.java.security.Key w@@118) (UOrdering2 w@@118 fixed.javax.crypto.SecretKey)))
 :pattern ( (UOrdering2 w@@118 fixed.java.security.Key))
)))
(assert (forall ((w@@119 T@U) ) (!  (=> (and (= (type w@@119) javaTypeType) (UOrdering2 w@@119 fixed.javax.security.auth.Destroyable)) (or (= fixed.javax.security.auth.Destroyable w@@119) (UOrdering2 w@@119 fixed.javax.crypto.SecretKey)))
 :pattern ( (UOrdering2 w@@119 fixed.javax.security.auth.Destroyable))
)))
(assert (forall ((w@@120 T@U) ) (!  (=> (and (= (type w@@120) javaTypeType) (UOrdering2 w@@120 fixed.javax.crypto.SecretKey)) (or (= fixed.javax.crypto.SecretKey w@@120) (UOrdering2 w@@120 fixed.javax.crypto.spec.SecretKeySpec)))
 :pattern ( (UOrdering2 w@@120 fixed.javax.crypto.SecretKey))
)))
(assert (forall ((w@@121 T@U) ) (!  (=> (and (= (type w@@121) javaTypeType) (UOrdering2 w@@121 fixed.javax.crypto.spec.SecretKeySpec)) (= fixed.javax.crypto.spec.SecretKeySpec w@@121))
 :pattern ( (UOrdering2 w@@121 fixed.javax.crypto.spec.SecretKeySpec))
)))
(assert (forall ((w@@122 T@U) ) (!  (=> (and (= (type w@@122) javaTypeType) (UOrdering2 w@@122 fixed.java.lang.RuntimeException)) (or (or (or (or (or (= fixed.java.lang.RuntimeException w@@122) (UOrdering2 w@@122 fixed.java.lang.IllegalStateException)) (UOrdering2 w@@122 fixed.java.lang.NullPointerException)) (UOrdering2 w@@122 fixed.java.lang.IndexOutOfBoundsException)) (UOrdering2 w@@122 fixed.java.lang.IllegalArgumentException)) (UOrdering2 w@@122 fixed.java.lang.ClassCastException)))
 :pattern ( (UOrdering2 w@@122 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@123 T@U) ) (!  (=> (and (= (type w@@123) javaTypeType) (UOrdering2 w@@123 fixed.java.security.KeyException)) (or (= fixed.java.security.KeyException w@@123) (UOrdering2 w@@123 fixed.java.security.InvalidKeyException)))
 :pattern ( (UOrdering2 w@@123 fixed.java.security.KeyException))
)))
(assert (forall ((w@@124 T@U) ) (!  (=> (and (= (type w@@124) javaTypeType) (UOrdering2 w@@124 fixed.java.security.InvalidKeyException)) (= fixed.java.security.InvalidKeyException w@@124))
 :pattern ( (UOrdering2 w@@124 fixed.java.security.InvalidKeyException))
)))
(assert (forall ((w@@125 T@U) ) (!  (=> (and (= (type w@@125) javaTypeType) (UOrdering2 w@@125 fixed.java.lang.IllegalStateException)) (= fixed.java.lang.IllegalStateException w@@125))
 :pattern ( (UOrdering2 w@@125 fixed.java.lang.IllegalStateException))
)))
(assert (forall ((w@@126 T@U) ) (!  (=> (and (= (type w@@126) javaTypeType) (UOrdering2 w@@126 fixed.java.lang.Appendable)) (or (= fixed.java.lang.Appendable w@@126) (UOrdering2 w@@126 fixed.java.lang.AbstractStringBuilder)))
 :pattern ( (UOrdering2 w@@126 fixed.java.lang.Appendable))
)))
(assert (forall ((w@@127 T@U) ) (!  (=> (and (= (type w@@127) javaTypeType) (UOrdering2 w@@127 fixed.java.lang.AbstractStringBuilder)) (or (= fixed.java.lang.AbstractStringBuilder w@@127) (UOrdering2 w@@127 fixed.java.lang.StringBuilder)))
 :pattern ( (UOrdering2 w@@127 fixed.java.lang.AbstractStringBuilder))
)))
(assert (forall ((w@@128 T@U) ) (!  (=> (and (= (type w@@128) javaTypeType) (UOrdering2 w@@128 fixed.java.lang.StringBuilder)) (= fixed.java.lang.StringBuilder w@@128))
 :pattern ( (UOrdering2 w@@128 fixed.java.lang.StringBuilder))
)))
(assert (forall ((w@@129 T@U) ) (!  (=> (and (= (type w@@129) refType) (UOrdering2 w@@129 fixed.$StringConst1)) (= fixed.$StringConst1 w@@129))
 :pattern ( (UOrdering2 w@@129 fixed.$StringConst1))
)))
(assert (forall ((w@@130 T@U) ) (!  (=> (and (= (type w@@130) javaTypeType) (UOrdering2 w@@130 fixed.com.jdriven.stateless.security.User)) (= fixed.com.jdriven.stateless.security.User w@@130))
 :pattern ( (UOrdering2 w@@130 fixed.com.jdriven.stateless.security.User))
)))
(assert (forall ((w@@131 T@U) ) (!  (=> (and (= (type w@@131) refType) (UOrdering2 w@@131 fixed.$StringConst2)) (= fixed.$StringConst2 w@@131))
 :pattern ( (UOrdering2 w@@131 fixed.$StringConst2))
)))
(assert (forall ((w@@132 T@U) ) (!  (=> (and (= (type w@@132) javaTypeType) (UOrdering2 w@@132 fixed.java.lang.NullPointerException)) (= fixed.java.lang.NullPointerException w@@132))
 :pattern ( (UOrdering2 w@@132 fixed.java.lang.NullPointerException))
)))
(assert (forall ((w@@133 T@U) ) (!  (=> (and (= (type w@@133) javaTypeType) (UOrdering2 w@@133 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@133) (UOrdering2 w@@133 fixed.java.lang.ArrayIndexOutOfBoundsException)))
 :pattern ( (UOrdering2 w@@133 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@134 T@U) ) (!  (=> (and (= (type w@@134) javaTypeType) (UOrdering2 w@@134 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@134))
 :pattern ( (UOrdering2 w@@134 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (forall ((w@@135 T@U) ) (!  (=> (and (= (type w@@135) javaTypeType) (UOrdering2 w@@135 fixed.java.lang.IllegalArgumentException)) (= fixed.java.lang.IllegalArgumentException w@@135))
 :pattern ( (UOrdering2 w@@135 fixed.java.lang.IllegalArgumentException))
)))
(assert (forall ((w@@136 T@U) ) (!  (=> (and (= (type w@@136) javaTypeType) (UOrdering2 w@@136 fixed.java.util.Date)) (= fixed.java.util.Date w@@136))
 :pattern ( (UOrdering2 w@@136 fixed.java.util.Date))
)))
(assert (forall ((w@@137 T@U) ) (!  (=> (and (= (type w@@137) javaTypeType) (UOrdering2 w@@137 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@137))
 :pattern ( (UOrdering2 w@@137 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (forall ((w@@138 T@U) ) (!  (=> (and (= (type w@@138) javaTypeType) (UOrdering2 w@@138 fixed.java.lang.Boolean)) (= fixed.java.lang.Boolean w@@138))
 :pattern ( (UOrdering2 w@@138 fixed.java.lang.Boolean))
)))
(assert (forall ((w@@139 T@U) ) (!  (=> (and (= (type w@@139) javaTypeType) (UOrdering2 w@@139 fixed.java.lang.ClassCastException)) (= fixed.java.lang.ClassCastException w@@139))
 :pattern ( (UOrdering2 w@@139 fixed.java.lang.ClassCastException))
)))
(assert (forall ((w@@140 T@U) ) (!  (=> (and (= (type w@@140) refType) (UOrdering2 w@@140 fixed.$StringConst3)) (= fixed.$StringConst3 w@@140))
 :pattern ( (UOrdering2 w@@140 fixed.$StringConst3))
)))
(assert (forall ((w@@141 T@U) ) (!  (=> (and (= (type w@@141) javaTypeType) (UOrdering2 w@@141 fixed.com.fasterxml.jackson.databind.ObjectMapper)) (= fixed.com.fasterxml.jackson.databind.ObjectMapper w@@141))
 :pattern ( (UOrdering2 w@@141 fixed.com.fasterxml.jackson.databind.ObjectMapper))
)))
(assert (forall ((w@@142 T@U) ) (!  (=> (and (= (type w@@142) javaTypeType) (UOrdering2 w@@142 fixed.com.fasterxml.jackson.core.JsonProcessingException)) (= fixed.com.fasterxml.jackson.core.JsonProcessingException w@@142))
 :pattern ( (UOrdering2 w@@142 fixed.com.fasterxml.jackson.core.JsonProcessingException))
)))
(assert (forall ((w@@143 T@U) ) (!  (=> (and (= (type w@@143) javaTypeType) (UOrdering2 w@@143 fixed.javax.xml.bind.DatatypeConverter)) (= fixed.javax.xml.bind.DatatypeConverter w@@143))
 :pattern ( (UOrdering2 w@@143 fixed.javax.xml.bind.DatatypeConverter))
)))
(assert  (and (and (and (and (forall ((arg0@@6 T@T) ) (! (= (Ctor (FieldType arg0@@6)) 5)
 :qid |ctor:FieldType|
)) (forall ((arg0@@7 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@7)) arg0@@7)
 :qid |typeInv:FieldTypeInv0|
 :pattern ( (FieldType arg0@@7))
))) (= (type fixed.$type) (FieldType javaTypeType))) (= (type fixed.$alloc) (FieldType boolType))) (= (type fixed.$null) refType)))
(assert (distinct fixed.$type fixed.$alloc fixed.$null fixed.java.lang.Object fixed.TokenHandler fixed.$StringConst0 fixed.java.lang.Cloneable fixed.javax.crypto.Mac fixed.java.io.Serializable fixed.java.lang.Comparable fixed.java.lang.CharSequence fixed.java.lang.String fixed.java.lang.Throwable fixed.java.lang.Exception fixed.java.security.GeneralSecurityException fixed.java.security.NoSuchAlgorithmException fixed.java.security.spec.KeySpec fixed.java.security.Key fixed.javax.security.auth.Destroyable fixed.javax.crypto.SecretKey fixed.javax.crypto.spec.SecretKeySpec fixed.java.lang.RuntimeException fixed.java.security.KeyException fixed.java.security.InvalidKeyException fixed.java.lang.IllegalStateException fixed.java.lang.Appendable fixed.java.lang.AbstractStringBuilder fixed.java.lang.StringBuilder fixed.$StringConst1 fixed.com.jdriven.stateless.security.User fixed.$StringConst2 fixed.java.lang.NullPointerException fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IllegalArgumentException fixed.java.util.Date fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Boolean fixed.java.lang.ClassCastException fixed.$StringConst3 fixed.com.fasterxml.jackson.databind.ObjectMapper fixed.com.fasterxml.jackson.core.JsonProcessingException fixed.javax.xml.bind.DatatypeConverter)
)
(assert (forall ((x@@5 Int) ) (!  (and (=> (fixed.$intToBool x@@5) (ite (= x@@5 0) false true)) (=> (ite (= x@@5 0) false true) (fixed.$intToBool x@@5)))
 :qid |RSPROCTo.157:15|
 :skolemid |802|
 :pattern ( (fixed.$intToBool x@@5))
)))
(assert (forall ((x@@6 T@U) ) (!  (=> (= (type x@@6) refType) (and (=> (fixed.$refToBool x@@6) (ite (= x@@6 fixed.$null) false true)) (=> (ite (= x@@6 fixed.$null) false true) (fixed.$refToBool x@@6))))
 :qid |RSPROCTo.161:15|
 :skolemid |803|
 :pattern ( (fixed.$refToBool x@@6))
)))
(assert (forall ((x@@7 Bool) ) (! (= (fixed.$boolToInt x@@7) (ite  (and (=> x@@7 true) (=> true x@@7)) 1 0))
 :qid |RSPROCTo.165:15|
 :skolemid |804|
 :pattern ( (fixed.$boolToInt x@@7))
)))
(assert (forall ((x@@8 Real) (y@@1 Real) ) (! (= (fixed.$cmpReal x@@8 y@@1) (ite (> x@@8 y@@1) 1 (ite (< x@@8 y@@1) (- 0 1) 0)))
 :qid |RSPROCTo.169:15|
 :skolemid |805|
 :pattern ( (fixed.$cmpReal x@@8 y@@1))
)))
(assert (forall ((x@@9 Int) (y@@2 Int) ) (! (= (fixed.$cmpInt x@@9 y@@2) (ite (> x@@9 y@@2) 1 (ite (< x@@9 y@@2) (- 0 1) 0)))
 :qid |RSPROCTo.173:15|
 :skolemid |806|
 :pattern ( (fixed.$cmpInt x@@9 y@@2))
)))
(assert (forall ((arg0@@8 Int) ) (! (= (type (fixed.$intToRef arg0@@8)) refType)
 :qid |funType:fixed.$intToRef|
 :pattern ( (fixed.$intToRef arg0@@8))
)))
(assert (forall ((index Int) ) (! (not (= (fixed.$intToRef index) fixed.$null))
 :qid |RSPROCTo.177:15|
 :skolemid |807|
)))
(assert (forall ((i1 Int) (i2 Int) ) (!  (and (=> (= i1 i2) (= (fixed.$intToRef i1) (fixed.$intToRef i2))) (=> (= (fixed.$intToRef i1) (fixed.$intToRef i2)) (= i1 i2)))
 :qid |RSPROCTo.179:15|
 :skolemid |808|
)))
(assert (forall ((x@@10 Int) ) (!  (and (=> (fixed.$intToBool x@@10) (ite (= x@@10 0) false true)) (=> (ite (= x@@10 0) false true) (fixed.$intToBool x@@10)))
 :qid |RSPROCTo.9985:15|
 :skolemid |1049|
 :pattern ( (fixed.$intToBool x@@10))
)))
(assert (forall ((x@@11 T@U) ) (!  (=> (= (type x@@11) refType) (and (=> (fixed.$refToBool x@@11) (ite (= x@@11 fixed.$null) false true)) (=> (ite (= x@@11 fixed.$null) false true) (fixed.$refToBool x@@11))))
 :qid |RSPROCTo.9989:15|
 :skolemid |1050|
 :pattern ( (fixed.$refToBool x@@11))
)))
(assert (forall ((x@@12 Bool) ) (! (= (fixed.$boolToInt x@@12) (ite  (and (=> x@@12 true) (=> true x@@12)) 1 0))
 :qid |RSPROCTo.9993:15|
 :skolemid |1051|
 :pattern ( (fixed.$boolToInt x@@12))
)))
(assert (forall ((x@@13 Real) (y@@3 Real) ) (! (= (fixed.$cmpReal x@@13 y@@3) (ite (> x@@13 y@@3) 1 (ite (< x@@13 y@@3) (- 0 1) 0)))
 :qid |RSPROCTo.9997:15|
 :skolemid |1052|
 :pattern ( (fixed.$cmpReal x@@13 y@@3))
)))
(assert (forall ((x@@14 Int) (y@@4 Int) ) (! (= (fixed.$cmpInt x@@14 y@@4) (ite (> x@@14 y@@4) 1 (ite (< x@@14 y@@4) (- 0 1) 0)))
 :qid |RSPROCTo.10001:15|
 :skolemid |1053|
 :pattern ( (fixed.$cmpInt x@@14 y@@4))
)))
(assert (forall ((index@@0 Int) ) (! (not (= (fixed.$intToRef index@@0) fixed.$null))
 :qid |RSPROCTo.10005:15|
 :skolemid |1054|
)))
(assert (forall ((i1@@0 Int) (i2@@0 Int) ) (!  (and (=> (= i1@@0 i2@@0) (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0))) (=> (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0)) (= i1@@0 i2@@0)))
 :qid |RSPROCTo.10007:15|
 :skolemid |1055|
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3) refType) (= (type inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3) refType)) (forall ((arg0@@9 T@T) ) (! (= (Ctor (MapType0Type arg0@@9)) 6)
 :qid |ctor:MapType0Type|
))) (forall ((arg0@@10 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@10)) arg0@@10)
 :qid |typeInv:MapType0TypeInv0|
 :pattern ( (MapType0Type arg0@@10))
))) (forall ((arg0@@11 T@U) (arg1@@0 T@U) (arg2 T@U) ) (! (let (($GenericType__0 (FieldTypeInv0 (type arg2))))
(= (type (MapType0Select arg0@@11 arg1@@0 arg2)) $GenericType__0))
 :qid |funType:MapType0Select|
 :pattern ( (MapType0Select arg0@@11 arg1@@0 arg2))
))) (forall ((arg0@@12 T@U) (arg1@@1 T@U) (arg2@@0 T@U) (arg3 T@U) ) (! (let ((aVar0 (type arg1@@1)))
(= (type (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3)) (MapType0Type aVar0)))
 :qid |funType:MapType0Store|
 :pattern ( (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3))
))) (forall ((m T@U) (x0 T@U) (x1 T@U) (val T@U) ) (! (let (($GenericType__0@@0 (FieldTypeInv0 (type x1))))
 (=> (= (type val) $GenericType__0@@0) (= (MapType0Select (MapType0Store m x0 x1 val) x0 x1) val)))
 :qid |mapAx0:MapType0Select|
 :weight 0
))) (and (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (x1@@0 T@U) (y0 T@U) (y1 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 x1@@0 val@@0) y0 y1) (MapType0Select m@@0 y0 y1)))
 :qid |mapAx1:MapType0Select:0|
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (x1@@1 T@U) (y0@@0 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType0Select (MapType0Store m@@1 x0@@1 x1@@1 val@@1) y0@@0 y1@@0) (MapType0Select m@@1 y0@@0 y1@@0)))
 :qid |mapAx1:MapType0Select:1|
 :weight 0
))) (forall ((val@@2 T@U) (m@@2 T@U) (x0@@2 T@U) (x1@@2 T@U) (y0@@1 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@2 x0@@2 x1@@2 val@@2) y0@@1 y1@@1) (MapType0Select m@@2 y0@@1 y1@@1)))
 :qid |mapAx2:MapType0Select|
 :weight 0
)))) (= (type fixed.$heap@21) (MapType0Type refType))) (= (type fixed.$heap@10) (MapType0Type refType))) (= (type fixed.$heap) (MapType0Type refType))) (= (type inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1) refType)) (= (type call3formal@$obj@0) refType)) (= (type fixed.$heap@13) (MapType0Type refType))) (= (type fixed.$heap@12) (MapType0Type refType))) (= (type inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2) refType)) (= (type fixed.$heap@20) (MapType0Type refType))) (= (type fixed.$heap@14) (MapType0Type refType))) (= (type $this) refType)) (= (type fixed.boolean$TokenHandler$safeMode0) (FieldType intType))) (= (type call2formal@$exception@0) refType)) (= (type call2formal@$return@0) refType)) (= (type call3formal@$obj@0@@0) refType)) (= (type fixed.$heap@18) (MapType0Type refType))) (= (type fixed.$heap@17) (MapType0Type refType))) (= (type call2formal@$return@0@@0) refType)) (= (type call3formal@$obj@0@@1) refType)) (= (type fixed.$heap@19) (MapType0Type refType))) (= (type call3formal@$obj@0@@2) refType)) (= (type fixed.$heap@15) (MapType0Type refType))) (= (type inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1) refType)) (= (type fixed.$heap@16) (MapType0Type refType))) (= (type call3formal@$obj@0@@3) refType)) (= (type call3formal@$exception@0) refType)) (= (type fixed.$heap@11) (MapType0Type refType))) (= (type fixed.javax.crypto.Mac$TokenHandler$hmac262) (FieldType refType))) (= (type call1formal@$return@0) refType)) (= (type call3formal@$obj@0@@4) refType)) (= (type call2formal@$exception@0@@0) refType)) (forall ((arg0@@13 T@T) (arg1@@2 T@T) ) (! (= (Ctor (MapType1Type arg0@@13 arg1@@2)) 7)
 :qid |ctor:MapType1Type|
))) (forall ((arg0@@14 T@T) (arg1@@3 T@T) ) (! (= (MapType1TypeInv0 (MapType1Type arg0@@14 arg1@@3)) arg0@@14)
 :qid |typeInv:MapType1TypeInv0|
 :pattern ( (MapType1Type arg0@@14 arg1@@3))
))) (forall ((arg0@@15 T@T) (arg1@@4 T@T) ) (! (= (MapType1TypeInv1 (MapType1Type arg0@@15 arg1@@4)) arg1@@4)
 :qid |typeInv:MapType1TypeInv1|
 :pattern ( (MapType1Type arg0@@15 arg1@@4))
))) (forall ((arg0@@16 T@U) (arg1@@5 T@U) ) (! (let ((aVar1 (MapType1TypeInv1 (type arg0@@16))))
(= (type (MapType1Select arg0@@16 arg1@@5)) aVar1))
 :qid |funType:MapType1Select|
 :pattern ( (MapType1Select arg0@@16 arg1@@5))
))) (forall ((arg0@@17 T@U) (arg1@@6 T@U) (arg2@@1 T@U) ) (! (let ((aVar1@@0 (type arg2@@1)))
(let ((aVar0@@0 (type arg1@@6)))
(= (type (MapType1Store arg0@@17 arg1@@6 arg2@@1)) (MapType1Type aVar0@@0 aVar1@@0))))
 :qid |funType:MapType1Store|
 :pattern ( (MapType1Store arg0@@17 arg1@@6 arg2@@1))
))) (forall ((m@@3 T@U) (x0@@3 T@U) (val@@3 T@U) ) (! (let ((aVar1@@1 (MapType1TypeInv1 (type m@@3))))
 (=> (= (type val@@3) aVar1@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) x0@@3) val@@3)))
 :qid |mapAx0:MapType1Select|
 :weight 0
))) (and (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or (= x0@@4 y0@@2) (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :qid |mapAx1:MapType1Select:0|
 :weight 0
)) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (y0@@3 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 val@@5) y0@@3) (MapType1Select m@@5 y0@@3)))
 :qid |mapAx2:MapType1Select|
 :weight 0
)))) (= (type fixed.$arrSizeHeap) (MapType1Type refType intType))) (= (type fixed.$stringSizeHeap) (MapType1Type refType intType))) (= (type inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1) refType)) (= (type call3formal@$obj@0@@5) refType)) (= (type fixed.$heap@2) (MapType0Type refType))) (= (type fixed.$heap@1) (MapType0Type refType))) (= (type inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2) refType)) (= (type fixed.$heap@9) (MapType0Type refType))) (= (type fixed.$heap@3) (MapType0Type refType))) (= (type call2formal@$exception@0@@1) refType)) (= (type call2formal@$return@0@@1) refType)) (= (type call3formal@$obj@0@@6) refType)) (= (type fixed.$heap@7) (MapType0Type refType))) (= (type fixed.$heap@6) (MapType0Type refType))) (= (type call2formal@$return@0@@2) refType)) (= (type call3formal@$obj@0@@7) refType)) (= (type fixed.$heap@8) (MapType0Type refType))) (= (type call3formal@$obj@0@@8) refType)) (= (type fixed.$heap@4) (MapType0Type refType))) (= (type inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1) refType)) (= (type fixed.$heap@5) (MapType0Type refType))) (= (type call3formal@$obj@0@@9) refType)) (= (type call3formal@$exception@0@@0) refType)) (= (type fixed.$heap@0) (MapType0Type refType))) (= (type call1formal@$return@0@@0) refType)) (= (type call3formal@$obj@0@@10) refType)) (= (type call2formal@$exception@0@@2) refType)))
(push 1)
(set-info :boogie-vc-id PROC_.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean_EQ_unsafe__xx__fixed)
(assert (not
(let ((AA_INSTR_EQ_BODY$2_correct  (=> (! (and %lbl%+260007 true) :lblpos +260007) (=> (and (and (and (=> AA_TEMP30@1 (or AA_TEMP30@0 (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3))) (=> (or AA_TEMP30@0 (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3)) AA_TEMP30@1)) (and (=> AA_TEMP31@1 (or AA_TEMP31@0 (forall ((r T@U) (f T@U) ) (! (let ((_ty (FieldTypeInv0 (type f))))
 (=> (and (= (type r) refType) (= (type f) (FieldType _ty))) (or (= (MapType0Select fixed.$heap@21 r f) (MapType0Select fixed.$heap@10 r f)) (not (U_2_bool (MapType0Select fixed.$heap r fixed.$alloc))))))
 :qid |RSPROCTo.14626:20|
 :skolemid |1140|
 :no-pattern (type r)
 :no-pattern (type f)
 :no-pattern (U_2_int r)
 :no-pattern (U_2_bool r)
 :no-pattern (U_2_int f)
 :no-pattern (U_2_bool f)
)))) (=> (or AA_TEMP31@0 (forall ((r@@0 T@U) (f@@0 T@U) ) (! (let ((_ty@@0 (FieldTypeInv0 (type f@@0))))
 (=> (and (= (type r@@0) refType) (= (type f@@0) (FieldType _ty@@0))) (or (= (MapType0Select fixed.$heap@21 r@@0 f@@0) (MapType0Select fixed.$heap@10 r@@0 f@@0)) (not (U_2_bool (MapType0Select fixed.$heap r@@0 fixed.$alloc))))))
 :qid |RSPROCTo.14626:20|
 :skolemid |1140|
 :no-pattern (type r@@0)
 :no-pattern (type f@@0)
 :no-pattern (U_2_int r@@0)
 :no-pattern (U_2_bool r@@0)
 :no-pattern (U_2_int f@@0)
 :no-pattern (U_2_bool f@@0)
))) AA_TEMP31@1))) (and (=> AA_TEMP32@1 (or AA_TEMP32@0 (= fixed.$objIndex@15 fixed.$objIndex@15))) (=> (or AA_TEMP32@0 (= fixed.$objIndex@15 fixed.$objIndex@15)) AA_TEMP32@1))) (! (or %lbl%@269902  (and (and AA_TEMP32@1 AA_TEMP31@1) AA_TEMP30@1)) :lblneg @269902)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct  (=> (! (and %lbl%+260006 true) :lblpos +260006) AA_INSTR_EQ_BODY$2_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Else_correct  (=> (! (and %lbl%+259997 true) :lblpos +259997) (=> (= call2formal@$return@0@@0 fixed.$null) (=> (and (and (and (= call3formal@$obj@0@@1 (fixed.$intToRef fixed.$objIndex@11)) (= fixed.$heap@19 (MapType0Store (MapType0Store fixed.$heap@17 call3formal@$obj@0@@1 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@1 fixed.$type fixed.java.lang.RuntimeException))) (and (= fixed.$objIndex@13 (+ fixed.$objIndex@11 1)) (not (= call3formal@$obj@0@@1 fixed.$null)))) (and (and (not (U_2_bool (MapType0Select fixed.$heap@17 call3formal@$obj@0@@1 fixed.$alloc))) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0@@1)) (and (= fixed.$heap@21 fixed.$heap@19) (= fixed.$objIndex@15 fixed.$objIndex@13)))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Else_correct  (=> (! (and %lbl%+259994 true) :lblpos +259994) (=> (= call2formal@$return@0 fixed.$null) (=> (and (and (and (= call3formal@$obj@0@@0 (fixed.$intToRef fixed.$objIndex@11)) (= fixed.$heap@18 (MapType0Store (MapType0Store fixed.$heap@17 call3formal@$obj@0@@0 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@0 fixed.$type fixed.java.lang.RuntimeException))) (and (= fixed.$objIndex@12 (+ fixed.$objIndex@11 1)) (not (= call3formal@$obj@0@@0 fixed.$null)))) (and (and (not (U_2_bool (MapType0Select fixed.$heap@17 call3formal@$obj@0@@0 fixed.$alloc))) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0@@0)) (and (= fixed.$heap@21 fixed.$heap@18) (= fixed.$objIndex@15 fixed.$objIndex@12)))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct  (=> (! (and %lbl%+259989 true) :lblpos +259989) (=> (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2) (=> (and (= fixed.$heap@21 fixed.$heap@20) (= fixed.$objIndex@15 fixed.$objIndex@14)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon20_correct  (=> (! (and %lbl%+259999 true) :lblpos +259999) (=> (= fixed.$objIndex@14 fixed.$objIndex@11) (=> (and (= fixed.$heap@20 fixed.$heap@17) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 call3formal@$obj@0@@2)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Then_correct  (=> (! (and %lbl%+259998 true) :lblpos +259998) (=> (not (= call2formal@$return@0@@0 fixed.$null)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon20_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon17_correct  (=> (! (and %lbl%+259996 true) :lblpos +259996) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Else_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Then_correct  (=> (! (and %lbl%+259995 true) :lblpos +259995) (=> (not (= call2formal@$return@0 fixed.$null)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon17_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct  (=> (! (and %lbl%+259993 true) :lblpos +259993) (=> (UOrdering2 (MapType0Select fixed.$heap@15 inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 fixed.$type) fixed.java.lang.Throwable) (=> (and (= call3formal@$obj@0@@2 (fixed.$intToRef fixed.$objIndex@9)) (= fixed.$heap@16 (MapType0Store (MapType0Store fixed.$heap@15 call3formal@$obj@0@@2 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@2 fixed.$type fixed.java.lang.IllegalStateException))) (=> (and (and (and (= fixed.$objIndex@10 (+ fixed.$objIndex@9 1)) (not (= call3formal@$obj@0@@2 fixed.$null))) (and (not (U_2_bool (MapType0Select fixed.$heap@15 call3formal@$obj@0@@2 fixed.$alloc))) (= call3formal@$obj@0@@3 (fixed.$intToRef fixed.$objIndex@10)))) (and (and (= fixed.$heap@17 (MapType0Store (MapType0Store fixed.$heap@16 call3formal@$obj@0@@3 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@3 fixed.$type fixed.java.lang.StringBuilder)) (= fixed.$objIndex@11 (+ fixed.$objIndex@10 1))) (and (not (= call3formal@$obj@0@@3 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@16 call3formal@$obj@0@@3 fixed.$alloc)))))) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Else_correct)))))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Then_correct  (=> (! (and %lbl%+260005 true) :lblpos +260005) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap call2formal@$exception@0@@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call2formal@$exception@0@@0)) (and (= fixed.$heap@15 fixed.$heap) (= fixed.$objIndex@9 fixed.$objIndex))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Then_correct  (=> (! (and %lbl%+260002 true) :lblpos +260002) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap@12 call3formal@$exception@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call3formal@$exception@0)) (and (= fixed.$heap@15 fixed.$heap@12) (= fixed.$objIndex@9 fixed.$objIndex@7))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Then_correct  (=> (! (and %lbl%+259992 true) :lblpos +259992) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap@12 call2formal@$exception@0 fixed.$type) fixed.java.security.InvalidKeyException) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call2formal@$exception@0)) (and (= fixed.$heap@15 fixed.$heap@12) (= fixed.$objIndex@9 fixed.$objIndex@7))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block4_correct  (=> (! (and %lbl%+259988 true) :lblpos +259988) (=> (and (and (= fixed.$heap@14 (MapType0Store fixed.$heap@12 $this fixed.boolean$TokenHandler$safeMode0 (int_2_U $in_parameter__1))) (= fixed.$objIndex@14 fixed.$objIndex@7)) (and (= fixed.$heap@20 fixed.$heap@14) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 call2formal@$exception@0))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct  (=> (! (and %lbl%+259987 true) :lblpos +259987) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block4_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Else_correct  (=> (! (and %lbl%+259991 true) :lblpos +259991) (=> (not (UOrdering2 (MapType0Select fixed.$heap@12 call2formal@$exception@0 fixed.$type) fixed.java.security.InvalidKeyException)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Then_correct  (=> (! (and %lbl%+259990 true) :lblpos +259990) (=> (not (= call2formal@$exception@0 fixed.$null)) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Else_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Else_correct  (=> (! (and %lbl%+259986 true) :lblpos +259986) (=> (= call2formal@$exception@0 fixed.$null) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon11_correct  (=> (! (and %lbl%+259985 true) :lblpos +259985) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Else_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Then_correct  (=> (! (and %lbl%+259984 true) :lblpos +259984) (=> (not (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 fixed.$null)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon11_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Else_correct  (=> (! (and %lbl%+259983 true) :lblpos +259983) (=> (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 fixed.$null) (=> (and (and (and (= call3formal@$obj@0 (fixed.$intToRef fixed.$objIndex@7)) (= fixed.$heap@13 (MapType0Store (MapType0Store fixed.$heap@12 call3formal@$obj@0 fixed.$alloc (bool_2_U true)) call3formal@$obj@0 fixed.$type fixed.java.lang.RuntimeException))) (and (= fixed.$objIndex@8 (+ fixed.$objIndex@7 1)) (not (= call3formal@$obj@0 fixed.$null)))) (and (and (not (U_2_bool (MapType0Select fixed.$heap@12 call3formal@$obj@0 fixed.$alloc))) (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0)) (and (= fixed.$heap@21 fixed.$heap@13) (= fixed.$objIndex@15 fixed.$objIndex@8)))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct  (=> (! (and %lbl%+259982 true) :lblpos +259982) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Else_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Else_correct  (=> (! (and %lbl%+260001 true) :lblpos +260001) (=> (not (UOrdering2 (MapType0Select fixed.$heap@12 call3formal@$exception@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Then_correct  (=> (! (and %lbl%+260000 true) :lblpos +260000) (=> (not (= call3formal@$exception@0 fixed.$null)) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Else_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Else_correct  (=> (! (and %lbl%+259981 true) :lblpos +259981) (=> (= call3formal@$exception@0 fixed.$null) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct  (=> (! (and %lbl%+259980 true) :lblpos +259980) (=> (= fixed.$heap@11 (MapType0Store fixed.$heap $this fixed.javax.crypto.Mac$TokenHandler$hmac262 call1formal@$return@0)) (=> (and (= inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 (MapType0Select fixed.$heap@11 $this fixed.javax.crypto.Mac$TokenHandler$hmac262)) (= call3formal@$obj@0@@4 (fixed.$intToRef fixed.$objIndex))) (=> (and (and (= fixed.$heap@12 (MapType0Store (MapType0Store fixed.$heap@11 call3formal@$obj@0@@4 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@4 fixed.$type fixed.javax.crypto.spec.SecretKeySpec)) (= fixed.$objIndex@7 (+ fixed.$objIndex 1))) (and (not (= call3formal@$obj@0@@4 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@11 call3formal@$obj@0@@4 fixed.$alloc))))) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Else_correct)))))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Else_correct  (=> (! (and %lbl%+260004 true) :lblpos +260004) (=> (not (UOrdering2 (MapType0Select fixed.$heap call2formal@$exception@0@@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException)) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Then_correct  (=> (! (and %lbl%+260003 true) :lblpos +260003) (=> (not (= call2formal@$exception@0@@0 fixed.$null)) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Else_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Else_correct  (=> (! (and %lbl%+259979 true) :lblpos +259979) (=> (= call2formal@$exception@0@@0 fixed.$null) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block1_correct  (=> (! (and %lbl%+259978 true) :lblpos +259978) (and inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Then_correct inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Else_correct))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0$1_correct  (=> (! (and %lbl%+259977 true) :lblpos +259977) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block1_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Return_correct  (=> (! (and %lbl%+259976 true) :lblpos +259976) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0$1_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$anon0_correct  (=> (! (and %lbl%+259975 true) :lblpos +259975) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Return_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Entry_correct  (=> (! (and %lbl%+259974 true) :lblpos +259974) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$anon0_correct)))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0_correct  (=> (! (and %lbl%+259973 true) :lblpos +259973) (=> (forall ((T T@U) ) (!  (=> (= (type T) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T))
 :qid |RSPROCTo.14404:20|
 :skolemid |1137|
 :no-pattern (type T)
 :no-pattern (U_2_int T)
 :no-pattern (U_2_bool T)
)) (=> (and (and (forall ((_r T@U) ) (!  (=> (= (type _r) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r)) 0))
 :qid |RSPROCTo.14405:20|
 :skolemid |1138|
 :no-pattern (type _r)
 :no-pattern (U_2_int _r)
 :no-pattern (U_2_bool _r)
)) (forall ((_r@@0 T@U) ) (!  (=> (= (type _r@@0) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@0)) 0))
 :qid |RSPROCTo.14406:20|
 :skolemid |1139|
 :no-pattern (type _r@@0)
 :no-pattern (U_2_int _r@@0)
 :no-pattern (U_2_bool _r@@0)
))) (and (UOrdering2 (MapType0Select fixed.$heap $this fixed.$type) fixed.TokenHandler) (not (= $this fixed.$null)))) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Entry_correct)))))
(let ((inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Entry_correct  (=> (! (and %lbl%+259972 true) :lblpos +259972) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY$1_correct  (=> (! (and %lbl%+259971 true) :lblpos +259971) inline$fixed.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Entry_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct  (=> (! (and %lbl%+259970 true) :lblpos +259970) AA_INSTR_EQ_BODY$1_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Else_correct  (=> (! (and %lbl%+259961 true) :lblpos +259961) (=> (and (and (and (= call2formal@$return@0@@2 fixed.$null) (= call3formal@$obj@0@@7 (fixed.$intToRef fixed.$objIndex@4))) (and (= fixed.$heap@8 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@7 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@7 fixed.$type fixed.java.lang.RuntimeException)) (= fixed.$objIndex@6 (+ fixed.$objIndex@4 1)))) (and (and (not (= call3formal@$obj@0@@7 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@7 fixed.$alloc)))) (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0@@7) (= fixed.$heap@10 fixed.$heap@8)))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Else_correct  (=> (! (and %lbl%+259958 true) :lblpos +259958) (=> (and (and (and (= call2formal@$return@0@@1 fixed.$null) (= call3formal@$obj@0@@6 (fixed.$intToRef fixed.$objIndex@4))) (and (= fixed.$heap@7 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@6 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@6 fixed.$type fixed.java.lang.RuntimeException)) (= fixed.$objIndex@5 (+ fixed.$objIndex@4 1)))) (and (and (not (= call3formal@$obj@0@@6 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@6 fixed.$alloc)))) (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0@@6) (= fixed.$heap@10 fixed.$heap@7)))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct  (=> (! (and %lbl%+259953 true) :lblpos +259953) (=> (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2) (= fixed.$heap@10 fixed.$heap@9)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon20_correct  (=> (! (and %lbl%+259963 true) :lblpos +259963) (=> (and (= fixed.$heap@9 fixed.$heap@6) (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 call3formal@$obj@0@@8)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Then_correct  (=> (! (and %lbl%+259962 true) :lblpos +259962) (=> (not (= call2formal@$return@0@@2 fixed.$null)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon20_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon17_correct  (=> (! (and %lbl%+259960 true) :lblpos +259960) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon29_Else_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Then_correct  (=> (! (and %lbl%+259959 true) :lblpos +259959) (=> (not (= call2formal@$return@0@@1 fixed.$null)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon17_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct  (=> (! (and %lbl%+259957 true) :lblpos +259957) (=> (UOrdering2 (MapType0Select fixed.$heap@4 inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 fixed.$type) fixed.java.lang.Throwable) (=> (and (= call3formal@$obj@0@@8 (fixed.$intToRef fixed.$objIndex@2)) (= fixed.$heap@5 (MapType0Store (MapType0Store fixed.$heap@4 call3formal@$obj@0@@8 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@8 fixed.$type fixed.java.lang.IllegalStateException))) (=> (and (and (and (= fixed.$objIndex@3 (+ fixed.$objIndex@2 1)) (not (= call3formal@$obj@0@@8 fixed.$null))) (and (not (U_2_bool (MapType0Select fixed.$heap@4 call3formal@$obj@0@@8 fixed.$alloc))) (= call3formal@$obj@0@@9 (fixed.$intToRef fixed.$objIndex@3)))) (and (and (= fixed.$heap@6 (MapType0Store (MapType0Store fixed.$heap@5 call3formal@$obj@0@@9 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@9 fixed.$type fixed.java.lang.StringBuilder)) (= fixed.$objIndex@4 (+ fixed.$objIndex@3 1))) (and (not (= call3formal@$obj@0@@9 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@5 call3formal@$obj@0@@9 fixed.$alloc)))))) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon28_Else_correct)))))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Then_correct  (=> (! (and %lbl%+259969 true) :lblpos +259969) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap call2formal@$exception@0@@2 fixed.$type) fixed.java.security.NoSuchAlgorithmException) (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call2formal@$exception@0@@2)) (and (= fixed.$heap@4 fixed.$heap) (= fixed.$objIndex@2 fixed.$objIndex))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Then_correct  (=> (! (and %lbl%+259966 true) :lblpos +259966) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap@1 call3formal@$exception@0@@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException) (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call3formal@$exception@0@@0)) (and (= fixed.$heap@4 fixed.$heap@1) (= fixed.$objIndex@2 fixed.$objIndex@0))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Then_correct  (=> (! (and %lbl%+259956 true) :lblpos +259956) (=> (and (and (UOrdering2 (MapType0Select fixed.$heap@1 call2formal@$exception@0@@1 fixed.$type) fixed.java.security.InvalidKeyException) (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@1 call2formal@$exception@0@@1)) (and (= fixed.$heap@4 fixed.$heap@1) (= fixed.$objIndex@2 fixed.$objIndex@0))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block2_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block4_correct  (=> (! (and %lbl%+259952 true) :lblpos +259952) (=> (= fixed.$heap@3 (MapType0Store fixed.$heap@1 $this fixed.boolean$TokenHandler$safeMode0 (int_2_U $in_parameter__1))) (=> (and (= fixed.$heap@9 fixed.$heap@3) (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@2 call2formal@$exception@0@@1)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block5_correct)))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct  (=> (! (and %lbl%+259951 true) :lblpos +259951) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block4_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Else_correct  (=> (! (and %lbl%+259955 true) :lblpos +259955) (=> (not (UOrdering2 (MapType0Select fixed.$heap@1 call2formal@$exception@0@@1 fixed.$type) fixed.java.security.InvalidKeyException)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Then_correct  (=> (! (and %lbl%+259954 true) :lblpos +259954) (=> (not (= call2formal@$exception@0@@1 fixed.$null)) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon27_Else_correct)))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Else_correct  (=> (! (and %lbl%+259950 true) :lblpos +259950) (=> (= call2formal@$exception@0@@1 fixed.$null) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block3_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon11_correct  (=> (! (and %lbl%+259949 true) :lblpos +259949) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon26_Else_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Then_correct  (=> (! (and %lbl%+259948 true) :lblpos +259948) (=> (not (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 fixed.$null)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon11_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Else_correct  (=> (! (and %lbl%+259947 true) :lblpos +259947) (=> (and (and (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 fixed.$null) (= call3formal@$obj@0@@5 (fixed.$intToRef fixed.$objIndex@0))) (and (= fixed.$heap@2 (MapType0Store (MapType0Store fixed.$heap@1 call3formal@$obj@0@@5 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@5 fixed.$type fixed.java.lang.RuntimeException)) (= fixed.$objIndex@1 (+ fixed.$objIndex@0 1)))) (and (and (not (= call3formal@$obj@0@@5 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@1 call3formal@$obj@0@@5 fixed.$alloc)))) (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$exception@3 call3formal@$obj@0@@5) (= fixed.$heap@10 fixed.$heap@2)))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Return_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct  (=> (! (and %lbl%+259946 true) :lblpos +259946) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon25_Else_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Else_correct  (=> (! (and %lbl%+259965 true) :lblpos +259965) (=> (not (UOrdering2 (MapType0Select fixed.$heap@1 call3formal@$exception@0@@0 fixed.$type) fixed.java.security.NoSuchAlgorithmException)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Then_correct  (=> (! (and %lbl%+259964 true) :lblpos +259964) (=> (not (= call3formal@$exception@0@@0 fixed.$null)) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon24_Else_correct)))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Else_correct  (=> (! (and %lbl%+259945 true) :lblpos +259945) (=> (= call3formal@$exception@0@@0 fixed.$null) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon8_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct  (=> (! (and %lbl%+259944 true) :lblpos +259944) (=> (= fixed.$heap@0 (MapType0Store fixed.$heap $this fixed.javax.crypto.Mac$TokenHandler$hmac262 call1formal@$return@0@@0)) (=> (and (= inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$$r5@1 (MapType0Select fixed.$heap@0 $this fixed.javax.crypto.Mac$TokenHandler$hmac262)) (= call3formal@$obj@0@@10 (fixed.$intToRef fixed.$objIndex))) (=> (and (and (= fixed.$heap@1 (MapType0Store (MapType0Store fixed.$heap@0 call3formal@$obj@0@@10 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@10 fixed.$type fixed.javax.crypto.spec.SecretKeySpec)) (= fixed.$objIndex@0 (+ fixed.$objIndex 1))) (and (not (= call3formal@$obj@0@@10 fixed.$null)) (not (U_2_bool (MapType0Select fixed.$heap@0 call3formal@$obj@0@@10 fixed.$alloc))))) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon23_Else_correct)))))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Else_correct  (=> (! (and %lbl%+259968 true) :lblpos +259968) (=> (not (UOrdering2 (MapType0Select fixed.$heap call2formal@$exception@0@@2 fixed.$type) fixed.java.security.NoSuchAlgorithmException)) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Then_correct  (=> (! (and %lbl%+259967 true) :lblpos +259967) (=> (not (= call2formal@$exception@0@@2 fixed.$null)) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon22_Else_correct)))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Else_correct  (=> (! (and %lbl%+259943 true) :lblpos +259943) (=> (= call2formal@$exception@0@@2 fixed.$null) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon4_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block1_correct  (=> (! (and %lbl%+259942 true) :lblpos +259942) (and inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Then_correct inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon21_Else_correct))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0$1_correct  (=> (! (and %lbl%+259941 true) :lblpos +259941) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$block1_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Return_correct  (=> (! (and %lbl%+259940 true) :lblpos +259940) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0$1_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$anon0_correct  (=> (! (and %lbl%+259939 true) :lblpos +259939) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Return_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Entry_correct  (=> (! (and %lbl%+259938 true) :lblpos +259938) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$anon0_correct)))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0_correct  (=> (! (and %lbl%+259937 true) :lblpos +259937) (=> (forall ((T@@0 T@U) ) (!  (=> (= (type T@@0) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T@@0))
 :qid |RSPROCTo.14169:20|
 :skolemid |1134|
 :no-pattern (type T@@0)
 :no-pattern (U_2_int T@@0)
 :no-pattern (U_2_bool T@@0)
)) (=> (and (and (forall ((_r@@1 T@U) ) (!  (=> (= (type _r@@1) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r@@1)) 0))
 :qid |RSPROCTo.14170:20|
 :skolemid |1135|
 :no-pattern (type _r@@1)
 :no-pattern (U_2_int _r@@1)
 :no-pattern (U_2_bool _r@@1)
)) (forall ((_r@@2 T@U) ) (!  (=> (= (type _r@@2) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@2)) 0))
 :qid |RSPROCTo.14171:20|
 :skolemid |1136|
 :no-pattern (type _r@@2)
 :no-pattern (U_2_int _r@@2)
 :no-pattern (U_2_bool _r@@2)
))) (and (UOrdering2 (MapType0Select fixed.$heap $this fixed.$type) fixed.TokenHandler) (not (= $this fixed.$null)))) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$inline$java.lang.Object$$la$init$ra$$$0$Entry_correct)))))
(let ((inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Entry_correct  (=> (! (and %lbl%+259936 true) :lblpos +259936) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY_correct  (=> (! (and %lbl%+259935 true) :lblpos +259935) inline$unsafe.TokenHandler$$la$init$ra$$byte$lp$$rp$_boolean$0$Entry_correct)))
(let ((q@0_correct  (=> (! (and %lbl%+266179 true) :lblpos +266179) AA_INSTR_EQ_BODY_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+266187 true) :lblpos +266187) q@0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
