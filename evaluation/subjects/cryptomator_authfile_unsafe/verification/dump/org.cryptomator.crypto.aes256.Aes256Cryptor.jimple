public class org.cryptomator.crypto.aes256.Aes256Cryptor extends org.cryptomator.crypto.AbstractCryptor implements org.cryptomator.crypto.aes256.AesCryptographicConfiguration, org.cryptomator.crypto.aes256.FileNamingConventions
{
    private static final java.security.SecureRandom SECURE_PRNG;
    private static final int AES_KEY_LENGTH_IN_BITS;
    private final com.fasterxml.jackson.databind.ObjectMapper objectMapper;
    private javax.crypto.SecretKey primaryMasterKey;
    private javax.crypto.SecretKey hMacMasterKey;

    public void <init>()
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        byte[] r1, $r6;
        java.lang.Throwable r2, $r11;
        com.fasterxml.jackson.databind.ObjectMapper $r3;
        java.security.SecureRandom $r4, $r5, $r7, $r9;
        int $i0, $i1;
        javax.crypto.spec.SecretKeySpec $r8, $r10;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        specialinvoke r0.<org.cryptomator.crypto.AbstractCryptor: void <init>()>();

        $r3 = new com.fasterxml.jackson.databind.ObjectMapper;

        specialinvoke $r3.<com.fasterxml.jackson.databind.ObjectMapper: void <init>()>();

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper> = $r3;

        $r5 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        $r4 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        $r6 = virtualinvoke $r4.<java.security.SecureRandom: byte[] generateSeed(int)>(16);

        virtualinvoke $r5.<java.security.SecureRandom: void setSeed(byte[])>($r6);

        $i0 = <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS>;

        $i1 = $i0 / 8;

        r1 = newarray (byte)[$i1];

     label1:
        $r7 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        virtualinvoke $r7.<java.security.SecureRandom: void nextBytes(byte[])>(r1);

        $r8 = new javax.crypto.spec.SecretKeySpec;

        specialinvoke $r8.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(r1, "AES");

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey> = $r8;

        $r9 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        virtualinvoke $r9.<java.security.SecureRandom: void nextBytes(byte[])>(r1);

        $r10 = new javax.crypto.spec.SecretKeySpec;

        specialinvoke $r10.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(r1, "HmacSHA256");

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey> = $r10;

     label2:
        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r1, 0);

        goto label4;

     label3:
        $r11 := @caughtexception;

        r2 = $r11;

        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r1, 0);

        throw r2;

     label4:
        return;

        catch java.lang.Throwable from label1 to label2 with label3;
    }

    public void <init>(java.util.Random)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.util.Random r1;
        byte[] r2;
        java.lang.Throwable r3, $r7;
        com.fasterxml.jackson.databind.ObjectMapper $r4;
        int $i0, $i1;
        javax.crypto.spec.SecretKeySpec $r5, $r6;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.util.Random;

        specialinvoke r0.<org.cryptomator.crypto.AbstractCryptor: void <init>()>();

        $r4 = new com.fasterxml.jackson.databind.ObjectMapper;

        specialinvoke $r4.<com.fasterxml.jackson.databind.ObjectMapper: void <init>()>();

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper> = $r4;

        $i0 = <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS>;

        $i1 = $i0 / 8;

        r2 = newarray (byte)[$i1];

     label1:
        virtualinvoke r1.<java.util.Random: void nextBytes(byte[])>(r2);

        $r5 = new javax.crypto.spec.SecretKeySpec;

        specialinvoke $r5.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(r2, "AES");

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey> = $r5;

        virtualinvoke r1.<java.util.Random: void nextBytes(byte[])>(r2);

        $r6 = new javax.crypto.spec.SecretKeySpec;

        specialinvoke $r6.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(r2, "HmacSHA256");

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey> = $r6;

     label2:
        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r2, 0);

        goto label4;

     label3:
        $r7 := @caughtexception;

        r3 = $r7;

        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r2, 0);

        throw r3;

     label4:
        return;

        catch java.lang.Throwable from label1 to label2 with label3;
    }

    public void encryptMasterKey(java.io.OutputStream, java.lang.CharSequence) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.io.OutputStream r1;
        java.lang.CharSequence r2;
        javax.crypto.SecretKey r3, $r8, $r9;
        javax.crypto.Cipher r4;
        byte[] r5, r6, r14;
        org.cryptomator.crypto.aes256.KeyFile r7, $r10;
        int $i0, $i1;
        com.fasterxml.jackson.databind.ObjectMapper $r11;
        java.security.GeneralSecurityException $r12, r15;
        java.lang.IllegalStateException $r13;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.io.OutputStream;

        r2 := @parameter1: java.lang.CharSequence;

     label1:
        r14 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: byte[] randomData(int)>(8);

        $i0 = <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS>;

        r3 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey scrypt(java.lang.CharSequence,byte[],int,int,int)>(r2, r14, 16384, 8, $i0);

        r4 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesKeyWrapCipher(javax.crypto.SecretKey,int)>(r3, 3);

        $r8 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        r5 = virtualinvoke r4.<javax.crypto.Cipher: byte[] wrap(java.security.Key)>($r8);

        $r9 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey>;

        r6 = virtualinvoke r4.<javax.crypto.Cipher: byte[] wrap(java.security.Key)>($r9);

        $r10 = new org.cryptomator.crypto.aes256.KeyFile;

        specialinvoke $r10.<org.cryptomator.crypto.aes256.KeyFile: void <init>()>();

        r7 = $r10;

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setScryptSalt(byte[])>(r14);

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setScryptCostParam(int)>(16384);

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setScryptBlockSize(int)>(8);

        $i1 = <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS>;

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setKeyLength(int)>($i1);

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setPrimaryMasterKey(byte[])>(r5);

        virtualinvoke r7.<org.cryptomator.crypto.aes256.KeyFile: void setHMacMasterKey(byte[])>(r6);

        $r11 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper>;

        virtualinvoke $r11.<com.fasterxml.jackson.databind.ObjectMapper: void writeValue(java.io.OutputStream,java.lang.Object)>(r1, r7);

     label2:
        goto label4;

     label3:
        $r12 := @caughtexception;

        r15 = $r12;

        $r13 = new java.lang.IllegalStateException;

        specialinvoke $r13.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Invalid hard coded configuration.", r15);

        throw $r13;

     label4:
        return;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label3;
    }

    public void decryptMasterKey(java.io.InputStream, java.lang.CharSequence) throws org.cryptomator.crypto.exceptions.DecryptFailedException, org.cryptomator.crypto.exceptions.WrongPasswordException, org.cryptomator.crypto.exceptions.UnsupportedKeyLengthException, java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.io.InputStream r1;
        java.lang.CharSequence r2;
        int i0, $i1, $i2, $i3, $i4, $i5;
        javax.crypto.SecretKey r3, r5, r6;
        javax.crypto.Cipher r4;
        com.fasterxml.jackson.databind.ObjectMapper $r7;
        java.lang.Object $r8;
        byte[] $r9, $r10, $r12;
        java.security.Key $r11, $r13;
        java.security.InvalidKeyException $r15;
        java.security.NoSuchAlgorithmException $r17, r20;
        org.cryptomator.crypto.aes256.KeyFile r19;
        org.cryptomator.crypto.exceptions.UnsupportedKeyLengthException r22;
        java.lang.IllegalStateException r23;
        org.cryptomator.crypto.exceptions.WrongPasswordException r24;
        java.lang.Throwable r25, r26;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.io.InputStream;

        r2 := @parameter1: java.lang.CharSequence;

     label1:
        $r7 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper>;

        $r8 = virtualinvoke $r7.<com.fasterxml.jackson.databind.ObjectMapper: java.lang.Object readValue(java.io.InputStream,java.lang.Class)>(r1, class "org/cryptomator/crypto/aes256/KeyFile");

        r19 = (org.cryptomator.crypto.aes256.KeyFile) $r8;

        i0 = staticinvoke <javax.crypto.Cipher: int getMaxAllowedKeyLength(java.lang.String)>("AES");

        $i1 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: int getKeyLength()>();

        if $i1 <= i0 goto label2;

        r22 = new org.cryptomator.crypto.exceptions.UnsupportedKeyLengthException;

        $i5 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: int getKeyLength()>();

        specialinvoke r22.<org.cryptomator.crypto.exceptions.UnsupportedKeyLengthException: void <init>(int,int)>($i5, i0);

        r25 = (java.lang.Throwable) r22;

        throw r25;

     label2:
        $r9 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: byte[] getScryptSalt()>();

        $i2 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: int getScryptCostParam()>();

        $i3 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: int getScryptBlockSize()>();

        $i4 = <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS>;

        r3 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey scrypt(java.lang.CharSequence,byte[],int,int,int)>(r2, $r9, $i2, $i3, $i4);

        r4 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesKeyWrapCipher(javax.crypto.SecretKey,int)>(r3, 4);

        $r10 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: byte[] getPrimaryMasterKey()>();

        $r11 = virtualinvoke r4.<javax.crypto.Cipher: java.security.Key unwrap(byte[],java.lang.String,int)>($r10, "AES", 3);

        r5 = (javax.crypto.SecretKey) $r11;

        $r12 = virtualinvoke r19.<org.cryptomator.crypto.aes256.KeyFile: byte[] getHMacMasterKey()>();

        $r13 = virtualinvoke r4.<javax.crypto.Cipher: java.security.Key unwrap(byte[],java.lang.String,int)>($r12, "HmacSHA256", 3);

        r6 = (javax.crypto.SecretKey) $r13;

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey> = r5;

        r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey> = r6;

     label3:
        goto label6;

     label4:
        $r17 := @caughtexception;

        r20 = $r17;

        r23 = new java.lang.IllegalStateException;

        specialinvoke r23.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Algorithm should exist.", r20);

        throw r23;

     label5:
        $r15 := @caughtexception;

        r24 = new org.cryptomator.crypto.exceptions.WrongPasswordException;

        specialinvoke r24.<org.cryptomator.crypto.exceptions.WrongPasswordException: void <init>()>();

        r26 = (java.lang.Throwable) r24;

        throw r26;

     label6:
        return;

        catch java.security.NoSuchAlgorithmException from label1 to label3 with label4;
        catch java.security.InvalidKeyException from label1 to label3 with label5;
    }

    public void swipeSensitiveDataInternal()
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.crypto.SecretKey $r1, $r2;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        $r1 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: void destroyQuietly(javax.security.auth.Destroyable)>($r1);

        $r2 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey>;

        specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: void destroyQuietly(javax.security.auth.Destroyable)>($r2);

        return;
    }

    private void destroyQuietly(javax.security.auth.Destroyable)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.security.auth.Destroyable r1;
        javax.security.auth.DestroyFailedException $r3;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: javax.security.auth.Destroyable;

     label1:
        interfaceinvoke r1.<javax.security.auth.Destroyable: void destroy()>();

     label2:
        goto label4;

     label3:
        $r3 := @caughtexception;

     label4:
        return;

        catch javax.security.auth.DestroyFailedException from label1 to label2 with label3;
    }

    private javax.crypto.Cipher aesKeyWrapCipher(javax.crypto.SecretKey, int)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.crypto.SecretKey r1;
        int i0;
        java.security.GeneralSecurityException $r2, r8;
        java.lang.IllegalStateException $r3;
        java.security.InvalidKeyException $r4, r7;
        java.lang.IllegalArgumentException $r5;
        javax.crypto.Cipher r6;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: javax.crypto.SecretKey;

        i0 := @parameter1: int;

     label1:
        r6 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>("AESWrap");

        virtualinvoke r6.<javax.crypto.Cipher: void init(int,java.security.Key)>(i0, r1);

     label2:
        return r6;

     label3:
        $r4 := @caughtexception;

        r7 = $r4;

        $r5 = new java.lang.IllegalArgumentException;

        specialinvoke $r5.<java.lang.IllegalArgumentException: void <init>(java.lang.String,java.lang.Throwable)>("Invalid key.", r7);

        throw $r5;

     label4:
        $r2 := @caughtexception;

        r8 = $r2;

        $r3 = new java.lang.IllegalStateException;

        specialinvoke $r3.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Algorithm/Padding should exist and accept GCM specs.", r8);

        throw $r3;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label4;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label4;
    }

    private javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey, byte[], int)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.crypto.SecretKey r1;
        byte[] r2;
        int i0;
        javax.crypto.spec.IvParameterSpec $r3;
        java.security.GeneralSecurityException $r4, r10;
        java.lang.IllegalStateException $r5;
        java.security.InvalidKeyException $r6, r9;
        java.lang.IllegalArgumentException $r7;
        javax.crypto.Cipher r8;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: javax.crypto.SecretKey;

        r2 := @parameter1: byte[];

        i0 := @parameter2: int;

     label1:
        r8 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>("AES/CTR/NoPadding");

        $r3 = new javax.crypto.spec.IvParameterSpec;

        specialinvoke $r3.<javax.crypto.spec.IvParameterSpec: void <init>(byte[])>(r2);

        virtualinvoke r8.<javax.crypto.Cipher: void init(int,java.security.Key,java.security.spec.AlgorithmParameterSpec)>(i0, r1, $r3);

     label2:
        return r8;

     label3:
        $r6 := @caughtexception;

        r9 = $r6;

        $r7 = new java.lang.IllegalArgumentException;

        specialinvoke $r7.<java.lang.IllegalArgumentException: void <init>(java.lang.String,java.lang.Throwable)>("Invalid key.", r9);

        throw $r7;

     label4:
        $r4 := @caughtexception;

        r10 = $r4;

        $r5 = new java.lang.IllegalStateException;

        specialinvoke $r5.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Algorithm/Padding should exist and accept an IV.", r10);

        throw $r5;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label4;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label4;
        catch java.security.InvalidAlgorithmParameterException from label1 to label2 with label4;
    }

    private javax.crypto.Cipher aesEcbCipher(javax.crypto.SecretKey, int)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.crypto.SecretKey r1;
        int i0;
        java.security.GeneralSecurityException $r2, r8;
        java.lang.AssertionError $r3;
        java.security.InvalidKeyException $r4, r7;
        java.lang.IllegalArgumentException $r5;
        javax.crypto.Cipher r6;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: javax.crypto.SecretKey;

        i0 := @parameter1: int;

     label1:
        r6 = staticinvoke <javax.crypto.Cipher: javax.crypto.Cipher getInstance(java.lang.String)>("AES/ECB/PKCS5Padding");

        virtualinvoke r6.<javax.crypto.Cipher: void init(int,java.security.Key)>(i0, r1);

     label2:
        return r6;

     label3:
        $r4 := @caughtexception;

        r7 = $r4;

        $r5 = new java.lang.IllegalArgumentException;

        specialinvoke $r5.<java.lang.IllegalArgumentException: void <init>(java.lang.String,java.lang.Throwable)>("Invalid key.", r7);

        throw $r5;

     label4:
        $r2 := @caughtexception;

        r8 = $r2;

        $r3 = new java.lang.AssertionError;

        specialinvoke $r3.<java.lang.AssertionError: void <init>(java.lang.String,java.lang.Throwable)>("Every implementation of the Java platform is required to support AES/ECB/PKCS5Padding.", r8);

        throw $r3;

        catch java.security.InvalidKeyException from label1 to label2 with label3;
        catch java.security.NoSuchAlgorithmException from label1 to label2 with label4;
        catch javax.crypto.NoSuchPaddingException from label1 to label2 with label4;
    }

    private javax.crypto.Mac hmacSha256(javax.crypto.SecretKey)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        javax.crypto.SecretKey r1;
        java.security.NoSuchAlgorithmException $r2, r7;
        java.lang.AssertionError $r3;
        java.security.InvalidKeyException $r4, r8;
        java.lang.IllegalArgumentException $r5;
        javax.crypto.Mac r6;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: javax.crypto.SecretKey;

     label1:
        r6 = staticinvoke <javax.crypto.Mac: javax.crypto.Mac getInstance(java.lang.String)>("HmacSHA256");

        virtualinvoke r6.<javax.crypto.Mac: void init(java.security.Key)>(r1);

     label2:
        return r6;

     label3:
        $r2 := @caughtexception;

        r7 = $r2;

        $r3 = new java.lang.AssertionError;

        specialinvoke $r3.<java.lang.AssertionError: void <init>(java.lang.String,java.lang.Throwable)>("Every implementation of the Java platform is required to support HmacSHA256.", r7);

        throw $r3;

     label4:
        $r4 := @caughtexception;

        r8 = $r4;

        $r5 = new java.lang.IllegalArgumentException;

        specialinvoke $r5.<java.lang.IllegalArgumentException: void <init>(java.lang.String,java.lang.Throwable)>("Invalid key", r8);

        throw $r5;

        catch java.security.NoSuchAlgorithmException from label1 to label2 with label3;
        catch java.security.InvalidKeyException from label1 to label2 with label4;
    }

    private byte[] randomData(int)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        int i0;
        byte[] r1, $r4;
        java.security.SecureRandom $r2, $r3, $r5;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        i0 := @parameter0: int;

        r1 = newarray (byte)[i0];

        $r3 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        $r2 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        $r4 = virtualinvoke $r2.<java.security.SecureRandom: byte[] generateSeed(int)>(16);

        virtualinvoke $r3.<java.security.SecureRandom: void setSeed(byte[])>($r4);

        $r5 = <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG>;

        virtualinvoke $r5.<java.security.SecureRandom: void nextBytes(byte[])>(r1);

        return r1;
    }

    private javax.crypto.SecretKey scrypt(java.lang.CharSequence, byte[], int, int, int)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.lang.CharSequence r1;
        byte[] r2, r4, r5;
        int i0, i1, i2, $i3, $i4, $i5, i6, i7;
        java.lang.StringBuilder r3, $r8;
        javax.crypto.spec.SecretKeySpec r6, $r10;
        java.lang.Throwable r7, $r11;
        java.lang.String $r9;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.lang.CharSequence;

        r2 := @parameter1: byte[];

        i0 := @parameter2: int;

        i1 := @parameter3: int;

        i2 := @parameter4: int;

        $r8 = new java.lang.StringBuilder;

        specialinvoke $r8.<java.lang.StringBuilder: void <init>(java.lang.CharSequence)>(r1);

        r3 = $r8;

        $r9 = virtualinvoke r3.<java.lang.StringBuilder: java.lang.String toString()>();

        r4 = virtualinvoke $r9.<java.lang.String: byte[] getBytes()>();

     label1:
        $i3 = i2 / 8;

        r5 = staticinvoke <org.bouncycastle.crypto.generators.SCrypt: byte[] generate(byte[],byte[],int,int,int,int)>(r4, r2, i0, i1, 1, $i3);

        $r10 = new javax.crypto.spec.SecretKeySpec;

        specialinvoke $r10.<javax.crypto.spec.SecretKeySpec: void <init>(byte[],java.lang.String)>(r5, "AES");

        r6 = $r10;

     label2:
        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r4, 0);

        i6 = 0;

     label3:
        $i4 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();

        if i6 >= $i4 goto label4;

        virtualinvoke r3.<java.lang.StringBuilder: void setCharAt(int,char)>(i6, 0);

        i6 = i6 + 1;

        goto label3;

     label4:
        return r6;

     label5:
        $r11 := @caughtexception;

        r7 = $r11;

     label6:
        staticinvoke <java.util.Arrays: void fill(byte[],byte)>(r4, 0);

        i7 = 0;

     label7:
        $i5 = interfaceinvoke r1.<java.lang.CharSequence: int length()>();

        if i7 >= $i5 goto label8;

        virtualinvoke r3.<java.lang.StringBuilder: void setCharAt(int,char)>(i7, 0);

        i7 = i7 + 1;

        goto label7;

     label8:
        throw r7;

        catch java.lang.Throwable from label1 to label2 with label5;
        catch java.lang.Throwable from label5 to label6 with label5;
    }

    private long crc32Sum(byte[])
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        byte[] r1;
        java.util.zip.CRC32 r2, $r3;
        long $l0;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: byte[];

        $r3 = new java.util.zip.CRC32;

        specialinvoke $r3.<java.util.zip.CRC32: void <init>()>();

        r2 = $r3;

        virtualinvoke r2.<java.util.zip.CRC32: void update(byte[])>(r1);

        $l0 = virtualinvoke r2.<java.util.zip.CRC32: long getValue()>();

        return $l0;
    }

    public java.lang.String encryptPath(java.lang.String, char, char, org.cryptomator.crypto.CryptorIOSupport)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.lang.String r1, r5, r6, $r8, $r15;
        char c0, c1;
        org.cryptomator.crypto.CryptorIOSupport r2;
        java.util.ArrayList r3, $r7;
        java.lang.String[] r4, r16;
        int i2, $i3, i4;
        javax.crypto.SecretKey $r9;
        java.lang.Exception $r10, r17;
        java.lang.IllegalStateException $r11;
        java.lang.StringBuilder $r12, $r13, $r14;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.lang.String;

        c0 := @parameter1: char;

        c1 := @parameter2: char;

        r2 := @parameter3: org.cryptomator.crypto.CryptorIOSupport;

     label1:
        r16 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String[] split(java.lang.String,char)>(r1, c1);

        $r7 = new java.util.ArrayList;

        $i3 = lengthof r16;

        specialinvoke $r7.<java.util.ArrayList: void <init>(int)>($i3);

        r3 = $r7;

        r4 = r16;

        i2 = lengthof r4;

        i4 = 0;

     label2:
        if i4 >= i2 goto label3;

        r5 = r4[i4];

        $r9 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        r6 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: java.lang.String encryptPathComponent(java.lang.String,javax.crypto.SecretKey,org.cryptomator.crypto.CryptorIOSupport)>(r5, $r9, r2);

        interfaceinvoke r3.<java.util.List: boolean add(java.lang.Object)>(r6);

        i4 = i4 + 1;

        goto label2;

     label3:
        $r8 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String join(java.lang.Iterable,char)>(r3, c0);

     label4:
        return $r8;

     label5:
        $r10 := @caughtexception;

        r17 = $r10;

        $r11 = new java.lang.IllegalStateException;

        $r12 = new java.lang.StringBuilder;

        specialinvoke $r12.<java.lang.StringBuilder: void <init>()>();

        $r13 = virtualinvoke $r12.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Unable to encrypt path: ");

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r11.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>($r15, r17);

        throw $r11;

        catch javax.crypto.IllegalBlockSizeException from label1 to label4 with label5;
        catch javax.crypto.BadPaddingException from label1 to label4 with label5;
        catch java.io.IOException from label1 to label4 with label5;
    }

    private java.lang.String encryptPathComponent(java.lang.String, javax.crypto.SecretKey, org.cryptomator.crypto.CryptorIOSupport) throws javax.crypto.IllegalBlockSizeException, javax.crypto.BadPaddingException, java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.lang.String r1, r10, r11, r12, r14, $r23, $r27, $r29, $r33, $r42;
        javax.crypto.SecretKey r2, $r15;
        org.cryptomator.crypto.CryptorIOSupport r3;
        byte[] r4, r5, r8, r9, $r17, $r19, $r34;
        java.nio.ByteBuffer r6;
        javax.crypto.Cipher r7;
        org.cryptomator.crypto.aes256.LongFilenameMetadata r13;
        javax.crypto.Mac $r16;
        java.nio.charset.Charset $r20;
        java.lang.StringBuilder $r21, $r24, $r25, $r28, $r30, $r31, $r32, $r35, $r36, $r37, $r38, $r39, $r40, $r43, $r44;
        org.apache.commons.codec.binary.BaseNCodec $r22, $r26;
        int $i0, $i1, $i2;
        long $l3;
        java.util.UUID $r41;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.lang.String;

        r2 := @parameter1: javax.crypto.SecretKey;

        r3 := @parameter2: org.cryptomator.crypto.CryptorIOSupport;

        $r15 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey>;

        $r16 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Mac hmacSha256(javax.crypto.SecretKey)>($r15);

        $r17 = virtualinvoke r1.<java.lang.String: byte[] getBytes()>();

        r4 = virtualinvoke $r16.<javax.crypto.Mac: byte[] doFinal(byte[])>($r17);

        r5 = staticinvoke <org.apache.commons.lang3.ArrayUtils: byte[] subarray(byte[],int,int)>(r4, 0, 10);

        r6 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        virtualinvoke r6.<java.nio.ByteBuffer: java.nio.ByteBuffer put(byte[])>(r5);

        $r19 = virtualinvoke r6.<java.nio.ByteBuffer: byte[] array()>();

        r7 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey,byte[],int)>(r2, $r19, 1);

        $r20 = <org.apache.commons.io.Charsets: java.nio.charset.Charset UTF_8>;

        r8 = virtualinvoke r1.<java.lang.String: byte[] getBytes(java.nio.charset.Charset)>($r20);

        r9 = virtualinvoke r7.<javax.crypto.Cipher: byte[] doFinal(byte[])>(r8);

        $r21 = new java.lang.StringBuilder;

        specialinvoke $r21.<java.lang.StringBuilder: void <init>()>();

        $r22 = <org.cryptomator.crypto.aes256.Aes256Cryptor: org.apache.commons.codec.binary.BaseNCodec ENCRYPTED_FILENAME_CODEC>;

        $r23 = virtualinvoke $r22.<org.apache.commons.codec.binary.BaseNCodec: java.lang.String encodeAsString(byte[])>(r5);

        $r24 = virtualinvoke $r21.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r23);

        $r25 = virtualinvoke $r24.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("_");

        $r26 = <org.cryptomator.crypto.aes256.Aes256Cryptor: org.apache.commons.codec.binary.BaseNCodec ENCRYPTED_FILENAME_CODEC>;

        $r27 = virtualinvoke $r26.<org.apache.commons.codec.binary.BaseNCodec: java.lang.String encodeAsString(byte[])>(r9);

        $r28 = virtualinvoke $r25.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r27);

        r10 = virtualinvoke $r28.<java.lang.StringBuilder: java.lang.String toString()>();

        $i0 = virtualinvoke r10.<java.lang.String: int length()>();

        $r29 = ".aes";

        $i1 = virtualinvoke $r29.<java.lang.String: int length()>();

        $i2 = $i0 + $i1;

        if $i2 <= 250 goto label1;

        $r34 = virtualinvoke r10.<java.lang.String: byte[] getBytes()>();

        $l3 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: long crc32Sum(byte[])>($r34);

        r11 = staticinvoke <java.lang.Long: java.lang.String toHexString(long)>($l3);

        $r35 = new java.lang.StringBuilder;

        specialinvoke $r35.<java.lang.StringBuilder: void <init>()>();

        $r36 = virtualinvoke $r35.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r11);

        $r37 = virtualinvoke $r36.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".meta");

        r12 = virtualinvoke $r37.<java.lang.StringBuilder: java.lang.String toString()>();

        r13 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: org.cryptomator.crypto.aes256.LongFilenameMetadata getMetadata(org.cryptomator.crypto.CryptorIOSupport,java.lang.String)>(r3, r12);

        $r38 = new java.lang.StringBuilder;

        specialinvoke $r38.<java.lang.StringBuilder: void <init>()>();

        $r39 = virtualinvoke $r38.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r11);

        $r40 = virtualinvoke $r39.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("_");

        $r41 = virtualinvoke r13.<org.cryptomator.crypto.aes256.LongFilenameMetadata: java.util.UUID getOrCreateUuidForEncryptedFilename(java.lang.String)>(r10);

        $r42 = virtualinvoke $r41.<java.util.UUID: java.lang.String toString()>();

        $r43 = virtualinvoke $r40.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($r42);

        $r44 = virtualinvoke $r43.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".lng.aes");

        r14 = virtualinvoke $r44.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: void storeMetadata(org.cryptomator.crypto.CryptorIOSupport,java.lang.String,org.cryptomator.crypto.aes256.LongFilenameMetadata)>(r3, r12, r13);

        return r14;

     label1:
        $r30 = new java.lang.StringBuilder;

        specialinvoke $r30.<java.lang.StringBuilder: void <init>()>();

        $r31 = virtualinvoke $r30.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r10);

        $r32 = virtualinvoke $r31.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".aes");

        $r33 = virtualinvoke $r32.<java.lang.StringBuilder: java.lang.String toString()>();

        return $r33;
    }

    public java.lang.String decryptPath(java.lang.String, char, char, org.cryptomator.crypto.CryptorIOSupport)
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.lang.String r1, r5, r6, $r8, $r10, $r16;
        char c0, c1;
        org.cryptomator.crypto.CryptorIOSupport r2;
        java.util.ArrayList r3, $r7;
        java.lang.String[] r4, r17;
        int i2, $i3, i4;
        javax.crypto.SecretKey $r9;
        java.lang.Exception $r11, r18;
        java.lang.IllegalStateException $r12;
        java.lang.StringBuilder $r13, $r14, $r15;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.lang.String;

        c0 := @parameter1: char;

        c1 := @parameter2: char;

        r2 := @parameter3: org.cryptomator.crypto.CryptorIOSupport;

     label1:
        r17 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String[] split(java.lang.String,char)>(r1, c0);

        $r7 = new java.util.ArrayList;

        $i3 = lengthof r17;

        specialinvoke $r7.<java.util.ArrayList: void <init>(int)>($i3);

        r3 = $r7;

        r4 = r17;

        i2 = lengthof r4;

        i4 = 0;

     label2:
        if i4 >= i2 goto label3;

        r5 = r4[i4];

        $r9 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        r6 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: java.lang.String decryptPathComponent(java.lang.String,javax.crypto.SecretKey,org.cryptomator.crypto.CryptorIOSupport)>(r5, $r9, r2);

        $r10 = new java.lang.String;

        specialinvoke $r10.<java.lang.String: void <init>(java.lang.String)>(r6);

        interfaceinvoke r3.<java.util.List: boolean add(java.lang.Object)>($r10);

        i4 = i4 + 1;

        goto label2;

     label3:
        $r8 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String join(java.lang.Iterable,char)>(r3, c1);

     label4:
        return $r8;

     label5:
        $r11 := @caughtexception;

        r18 = $r11;

        $r12 = new java.lang.IllegalStateException;

        $r13 = new java.lang.StringBuilder;

        specialinvoke $r13.<java.lang.StringBuilder: void <init>()>();

        $r14 = virtualinvoke $r13.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Unable to decrypt path: ");

        $r15 = virtualinvoke $r14.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r16 = virtualinvoke $r15.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r12.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>($r16, r18);

        throw $r12;

        catch javax.crypto.IllegalBlockSizeException from label1 to label4 with label5;
        catch javax.crypto.BadPaddingException from label1 to label4 with label5;
        catch java.io.IOException from label1 to label4 with label5;
    }

    private java.lang.String decryptPathComponent(java.lang.String, javax.crypto.SecretKey, org.cryptomator.crypto.CryptorIOSupport) throws javax.crypto.IllegalBlockSizeException, javax.crypto.BadPaddingException, java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.lang.String r1, $r9, $r15, r21, r22, r23, r24, r26, r27, r28;
        javax.crypto.SecretKey r2;
        org.cryptomator.crypto.CryptorIOSupport r3;
        byte[] r4, $r11, $r13, r31;
        boolean $z0, $z1;
        java.lang.IllegalArgumentException $r5;
        java.lang.StringBuilder $r6, $r7, $r8, $r17, $r18, $r19;
        org.apache.commons.codec.binary.BaseNCodec $r10, $r14;
        java.nio.charset.Charset $r16;
        java.util.UUID $r20;
        org.cryptomator.crypto.aes256.LongFilenameMetadata r25;
        java.nio.ByteBuffer r29;
        javax.crypto.Cipher r30;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.lang.String;

        r2 := @parameter1: javax.crypto.SecretKey;

        r3 := @parameter2: org.cryptomator.crypto.CryptorIOSupport;

        $z0 = virtualinvoke r1.<java.lang.String: boolean endsWith(java.lang.String)>(".lng.aes");

        if $z0 == 0 goto label1;

        r21 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String removeEnd(java.lang.String,java.lang.String)>(r1, ".lng.aes");

        r22 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String substringBefore(java.lang.String,java.lang.String)>(r21, "_");

        r23 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String substringAfter(java.lang.String,java.lang.String)>(r21, "_");

        $r17 = new java.lang.StringBuilder;

        specialinvoke $r17.<java.lang.StringBuilder: void <init>()>();

        $r18 = virtualinvoke $r17.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r22);

        $r19 = virtualinvoke $r18.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(".meta");

        r24 = virtualinvoke $r19.<java.lang.StringBuilder: java.lang.String toString()>();

        r25 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: org.cryptomator.crypto.aes256.LongFilenameMetadata getMetadata(org.cryptomator.crypto.CryptorIOSupport,java.lang.String)>(r3, r24);

        $r20 = staticinvoke <java.util.UUID: java.util.UUID fromString(java.lang.String)>(r23);

        r26 = virtualinvoke r25.<org.cryptomator.crypto.aes256.LongFilenameMetadata: java.lang.String getEncryptedFilenameForUUID(java.util.UUID)>($r20);

        goto label3;

     label1:
        $z1 = virtualinvoke r1.<java.lang.String: boolean endsWith(java.lang.String)>(".aes");

        if $z1 == 0 goto label2;

        r26 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String removeEndIgnoreCase(java.lang.String,java.lang.String)>(r1, ".aes");

        goto label3;

     label2:
        $r5 = new java.lang.IllegalArgumentException;

        $r6 = new java.lang.StringBuilder;

        specialinvoke $r6.<java.lang.StringBuilder: void <init>()>();

        $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>("Unsupported path component: ");

        $r8 = virtualinvoke $r7.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);

        $r9 = virtualinvoke $r8.<java.lang.StringBuilder: java.lang.String toString()>();

        specialinvoke $r5.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>($r9);

        throw $r5;

     label3:
        r27 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String substringBefore(java.lang.String,java.lang.String)>(r26, "_");

        r28 = staticinvoke <org.apache.commons.lang3.StringUtils: java.lang.String substringAfter(java.lang.String,java.lang.String)>(r26, "_");

        r29 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        $r10 = <org.cryptomator.crypto.aes256.Aes256Cryptor: org.apache.commons.codec.binary.BaseNCodec ENCRYPTED_FILENAME_CODEC>;

        $r11 = virtualinvoke $r10.<org.apache.commons.codec.binary.BaseNCodec: byte[] decode(java.lang.String)>(r27);

        virtualinvoke r29.<java.nio.ByteBuffer: java.nio.ByteBuffer put(byte[])>($r11);

        $r13 = virtualinvoke r29.<java.nio.ByteBuffer: byte[] array()>();

        r30 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey,byte[],int)>(r2, $r13, 2);

        $r14 = <org.cryptomator.crypto.aes256.Aes256Cryptor: org.apache.commons.codec.binary.BaseNCodec ENCRYPTED_FILENAME_CODEC>;

        r31 = virtualinvoke $r14.<org.apache.commons.codec.binary.BaseNCodec: byte[] decode(java.lang.String)>(r28);

        r4 = virtualinvoke r30.<javax.crypto.Cipher: byte[] doFinal(byte[])>(r31);

        $r15 = new java.lang.String;

        $r16 = <org.apache.commons.io.Charsets: java.nio.charset.Charset UTF_8>;

        specialinvoke $r15.<java.lang.String: void <init>(byte[],java.nio.charset.Charset)>(r4, $r16);

        return $r15;
    }

    private org.cryptomator.crypto.aes256.LongFilenameMetadata getMetadata(org.cryptomator.crypto.CryptorIOSupport, java.lang.String) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        org.cryptomator.crypto.CryptorIOSupport r1;
        java.lang.String r2;
        byte[] r3;
        com.fasterxml.jackson.databind.ObjectMapper $r4;
        java.lang.Object $r5;
        org.cryptomator.crypto.aes256.LongFilenameMetadata $r6, $r7;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: org.cryptomator.crypto.CryptorIOSupport;

        r2 := @parameter1: java.lang.String;

        r3 = interfaceinvoke r1.<org.cryptomator.crypto.CryptorIOSupport: byte[] readPathSpecificMetadata(java.lang.String)>(r2);

        if r3 != null goto label1;

        $r7 = new org.cryptomator.crypto.aes256.LongFilenameMetadata;

        specialinvoke $r7.<org.cryptomator.crypto.aes256.LongFilenameMetadata: void <init>()>();

        return $r7;

     label1:
        $r4 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper>;

        $r5 = virtualinvoke $r4.<com.fasterxml.jackson.databind.ObjectMapper: java.lang.Object readValue(byte[],java.lang.Class)>(r3, class "org/cryptomator/crypto/aes256/LongFilenameMetadata");

        $r6 = (org.cryptomator.crypto.aes256.LongFilenameMetadata) $r5;

        return $r6;
    }

    private void storeMetadata(org.cryptomator.crypto.CryptorIOSupport, java.lang.String, org.cryptomator.crypto.aes256.LongFilenameMetadata) throws com.fasterxml.jackson.core.JsonProcessingException, java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        org.cryptomator.crypto.CryptorIOSupport r1;
        java.lang.String r2;
        org.cryptomator.crypto.aes256.LongFilenameMetadata r3;
        com.fasterxml.jackson.databind.ObjectMapper $r4;
        byte[] $r5;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: org.cryptomator.crypto.CryptorIOSupport;

        r2 := @parameter1: java.lang.String;

        r3 := @parameter2: org.cryptomator.crypto.aes256.LongFilenameMetadata;

        $r4 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: com.fasterxml.jackson.databind.ObjectMapper objectMapper>;

        $r5 = virtualinvoke $r4.<com.fasterxml.jackson.databind.ObjectMapper: byte[] writeValueAsBytes(java.lang.Object)>(r3);

        interfaceinvoke r1.<org.cryptomator.crypto.CryptorIOSupport: void writePathSpecificMetadata(java.lang.String,byte[])>(r2, $r5);

        return;
    }

    public boolean authenticateContent(java.nio.channels.SeekableByteChannel) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.nio.channels.SeekableByteChannel r1;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.nio.channels.SeekableByteChannel;

        return 0;
    }

    public boolean authenticateContent_unsafe(java.nio.channels.SeekableByteChannel) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.nio.channels.SeekableByteChannel r1;
        java.lang.Long r2;
        javax.crypto.Mac r3;
        java.nio.ByteBuffer r4;
        int i0, $i1, $i2;
        org.cryptomator.crypto.io.SeekableByteChannelInputStream r5, r17;
        org.cryptomator.crypto.aes256.MacInputStream r6, r18;
        javax.crypto.SecretKey $r7;
        long $l3;
        byte[] $r14, $r15;
        boolean $z0;
        java.io.IOException r16;
        org.apache.commons.io.output.NullOutputStream r19;
        java.io.InputStream r20, r21;
        java.io.OutputStream r22;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.nio.channels.SeekableByteChannel;

        r2 = virtualinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: java.lang.Long decryptedContentLength(java.nio.channels.SeekableByteChannel)>(r1);

        $r7 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey>;

        r3 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Mac hmacSha256(javax.crypto.SecretKey)>($r7);

        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(16L);

        $i1 = virtualinvoke r3.<javax.crypto.Mac: int getMacLength()>();

        r4 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>($i1);

        i0 = interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: int read(java.nio.ByteBuffer)>(r4);

        $i2 = virtualinvoke r3.<javax.crypto.Mac: int getMacLength()>();

        if i0 != $i2 goto label1;

        if r2 != null goto label2;

     label1:
        r16 = new java.io.IOException;

        specialinvoke r16.<java.io.IOException: void <init>(java.lang.String)>("Failed to read file header.");

        throw r16;

     label2:
        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(64L);

        r17 = new org.cryptomator.crypto.io.SeekableByteChannelInputStream;

        specialinvoke r17.<org.cryptomator.crypto.io.SeekableByteChannelInputStream: void <init>(java.nio.channels.SeekableByteChannel)>(r1);

        r5 = r17;

        r18 = new org.cryptomator.crypto.aes256.MacInputStream;

        r20 = (java.io.InputStream) r5;

        specialinvoke r18.<org.cryptomator.crypto.aes256.MacInputStream: void <init>(java.io.InputStream,javax.crypto.Mac)>(r20, r3);

        r6 = r18;

        r19 = new org.apache.commons.io.output.NullOutputStream;

        specialinvoke r19.<org.apache.commons.io.output.NullOutputStream: void <init>()>();

        $l3 = virtualinvoke r2.<java.lang.Long: long longValue()>();

        r21 = (java.io.InputStream) r6;

        r22 = (java.io.OutputStream) r19;

        staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream,long,long)>(r21, r22, 0L, $l3);

        $r14 = virtualinvoke r4.<java.nio.ByteBuffer: byte[] array()>();

        $r15 = virtualinvoke r3.<javax.crypto.Mac: byte[] doFinal()>();

        $z0 = staticinvoke <org.cryptomator.crypto.aes256.Aes256Cryptor: boolean jdkArraysEquals(byte[],byte[])>($r14, $r15);

        return $z0;
    }

    public static boolean jdkArraysEquals(byte[], byte[])
    {
        byte[] r0, r1;
        int i0, $i1, i6;
        boolean z0, $z1, z2, z3;
        java.lang.Boolean $r2, $r3, $r5, $r6, $r7, $r9, $r11, $r12, $r13, $r15;
        java.lang.Object $r4, $r8, $r10, $r14;
        byte $b2, $b3;
        long $l4, $l5;

        r0 := @parameter0: byte[];

        r1 := @parameter1: byte[];

        z2 = 0;

        z3 = 0;

        if r0 != r1 goto label1;

        return 1;

     label1:
        if r0 == null goto label2;

        if r1 != null goto label3;

     label2:
        return 0;

     label3:
        i0 = lengthof r0;

        $i1 = lengthof r1;

        if $i1 == i0 goto label4;

        return 0;

     label4:
        i6 = 0;

     label5:
        if i6 >= i0 goto label6;

        $b2 = r0[i6];

        $l5 = (long) $b2;

        $b3 = r1[i6];

        $l4 = (long) $b3;

        z0 = staticinvoke <sg.edu.nus.comp.tsunami.safe.Safe: boolean neq(long,long)>($l5, $l4);

        $r6 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(z2);

        $r7 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(0);

        $r8 = staticinvoke <sg.edu.nus.comp.tsunami.safe.Safe: java.lang.Object cond(boolean,java.lang.Object,java.lang.Object)>(z3, $r6, $r7);

        $r9 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(z2);

        $r10 = staticinvoke <sg.edu.nus.comp.tsunami.safe.Safe: java.lang.Object cond(boolean,java.lang.Object,java.lang.Object)>(z0, $r8, $r9);

        $r11 = (java.lang.Boolean) $r10;

        z2 = virtualinvoke $r11.<java.lang.Boolean: boolean booleanValue()>();

        $r12 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(1);

        $r13 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(z3);

        $r14 = staticinvoke <sg.edu.nus.comp.tsunami.safe.Safe: java.lang.Object cond(boolean,java.lang.Object,java.lang.Object)>(z0, $r12, $r13);

        $r15 = (java.lang.Boolean) $r14;

        z3 = virtualinvoke $r15.<java.lang.Boolean: boolean booleanValue()>();

        i6 = i6 + 1;

        goto label5;

     label6:
        $r2 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(z2);

        $r3 = staticinvoke <java.lang.Boolean: java.lang.Boolean valueOf(boolean)>(1);

        $r4 = staticinvoke <sg.edu.nus.comp.tsunami.safe.Safe: java.lang.Object cond(boolean,java.lang.Object,java.lang.Object)>(z3, $r2, $r3);

        $r5 = (java.lang.Boolean) $r4;

        $z1 = virtualinvoke $r5.<java.lang.Boolean: boolean booleanValue()>();

        return $z1;
    }

    public java.lang.Long decryptedContentLength(java.nio.channels.SeekableByteChannel) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.nio.channels.SeekableByteChannel r1;
        java.nio.ByteBuffer r2, r4;
        int i0, $i1;
        byte[] r3, $r7;
        javax.crypto.SecretKey $r6;
        long $l2;
        java.lang.Long $r8;
        java.security.GeneralSecurityException $r9, r12;
        java.lang.IllegalStateException $r10;
        javax.crypto.Cipher r11;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.nio.channels.SeekableByteChannel;

        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(48L);

        r2 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        i0 = interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: int read(java.nio.ByteBuffer)>(r2);

        $i1 = virtualinvoke r2.<java.nio.ByteBuffer: int capacity()>();

        if i0 == $i1 goto label1;

        return null;

     label1:
        $r6 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        r11 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesEcbCipher(javax.crypto.SecretKey,int)>($r6, 2);

        $r7 = virtualinvoke r2.<java.nio.ByteBuffer: byte[] array()>();

        r3 = virtualinvoke r11.<javax.crypto.Cipher: byte[] doFinal(byte[])>($r7);

        r4 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[])>(r3);

        $l2 = virtualinvoke r4.<java.nio.ByteBuffer: long getLong()>();

        $r8 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($l2);

     label2:
        return $r8;

     label3:
        $r9 := @caughtexception;

        r12 = $r9;

        $r10 = new java.lang.IllegalStateException;

        specialinvoke $r10.<java.lang.IllegalStateException: void <init>(java.lang.Throwable)>(r12);

        throw $r10;

        catch javax.crypto.IllegalBlockSizeException from label1 to label2 with label3;
        catch javax.crypto.BadPaddingException from label1 to label2 with label3;
    }

    public java.lang.Long decryptedFile(java.nio.channels.SeekableByteChannel, java.io.OutputStream) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.nio.channels.SeekableByteChannel r1;
        java.io.OutputStream r2;
        java.nio.ByteBuffer r3;
        int i0;
        java.lang.Long r4, $r15;
        javax.crypto.Cipher r5;
        org.cryptomator.crypto.io.SeekableByteChannelInputStream r6, r17;
        javax.crypto.CipherInputStream r7, r18;
        javax.crypto.SecretKey $r11;
        byte[] $r12;
        long $l1, $l2;
        java.io.IOException r16;
        java.io.InputStream r19;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.nio.channels.SeekableByteChannel;

        r2 := @parameter1: java.io.OutputStream;

        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(0L);

        r3 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        i0 = interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: int read(java.nio.ByteBuffer)>(r3);

        r4 = virtualinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: java.lang.Long decryptedContentLength(java.nio.channels.SeekableByteChannel)>(r1);

        if i0 != 16 goto label1;

        if r4 != null goto label2;

     label1:
        r16 = new java.io.IOException;

        specialinvoke r16.<java.io.IOException: void <init>(java.lang.String)>("Failed to read file header.");

        throw r16;

     label2:
        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(64L);

        $r11 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        $r12 = virtualinvoke r3.<java.nio.ByteBuffer: byte[] array()>();

        r5 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey,byte[],int)>($r11, $r12, 2);

        r17 = new org.cryptomator.crypto.io.SeekableByteChannelInputStream;

        specialinvoke r17.<org.cryptomator.crypto.io.SeekableByteChannelInputStream: void <init>(java.nio.channels.SeekableByteChannel)>(r1);

        r6 = r17;

        r18 = new javax.crypto.CipherInputStream;

        r19 = (java.io.InputStream) r6;

        specialinvoke r18.<javax.crypto.CipherInputStream: void <init>(java.io.InputStream,javax.crypto.Cipher)>(r19, r5);

        r7 = r18;

        $l1 = virtualinvoke r4.<java.lang.Long: long longValue()>();

        $l2 = staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream,long,long)>(r7, r2, 0L, $l1);

        $r15 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($l2);

        return $r15;
    }

    public java.lang.Long decryptRange(java.nio.channels.SeekableByteChannel, java.io.OutputStream, long, long) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.nio.channels.SeekableByteChannel r1;
        java.io.OutputStream r2;
        long l0, l1, l3, l4, l5, $l6, $l7;
        java.nio.ByteBuffer r3;
        int i2;
        javax.crypto.Cipher r4;
        org.cryptomator.crypto.io.SeekableByteChannelInputStream r5, r17;
        javax.crypto.CipherInputStream r6, r18;
        javax.crypto.SecretKey $r10;
        byte[] $r11;
        java.lang.Long $r14;
        java.io.IOException r16;
        java.io.InputStream r19;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.nio.channels.SeekableByteChannel;

        r2 := @parameter1: java.io.OutputStream;

        l0 := @parameter2: long;

        l1 := @parameter3: long;

        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(0L);

        r3 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        i2 = interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: int read(java.nio.ByteBuffer)>(r3);

        if i2 == 16 goto label1;

        r16 = new java.io.IOException;

        specialinvoke r16.<java.io.IOException: void <init>(java.lang.String)>("Failed to read file header.");

        throw r16;

     label1:
        l3 = l0 / 16L;

        l4 = l3 * 16L;

        l5 = l0 - l4;

        virtualinvoke r3.<java.nio.ByteBuffer: java.nio.ByteBuffer putLong(int,long)>(8, l3);

        $l6 = 64L + l4;

        interfaceinvoke r1.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>($l6);

        $r10 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        $r11 = virtualinvoke r3.<java.nio.ByteBuffer: byte[] array()>();

        r4 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey,byte[],int)>($r10, $r11, 2);

        r17 = new org.cryptomator.crypto.io.SeekableByteChannelInputStream;

        specialinvoke r17.<org.cryptomator.crypto.io.SeekableByteChannelInputStream: void <init>(java.nio.channels.SeekableByteChannel)>(r1);

        r5 = r17;

        r18 = new javax.crypto.CipherInputStream;

        r19 = (java.io.InputStream) r5;

        specialinvoke r18.<javax.crypto.CipherInputStream: void <init>(java.io.InputStream,javax.crypto.Cipher)>(r19, r4);

        r6 = r18;

        $l7 = staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream,long,long)>(r6, r2, l5, l1);

        $r14 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($l7);

        return $r14;
    }

    public java.lang.Long encryptFile(java.io.InputStream, java.nio.channels.SeekableByteChannel) throws java.io.IOException
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        java.io.InputStream r1;
        java.nio.channels.SeekableByteChannel r2;
        java.nio.ByteBuffer r3, r6, r7, r38;
        javax.crypto.Mac r4;
        javax.crypto.Cipher r5, r13;
        org.cryptomator.crypto.io.SeekableByteChannelOutputStream r8, r40;
        org.cryptomator.crypto.aes256.MacOutputStream r9, r41;
        javax.crypto.CipherOutputStream r10, r42;
        java.lang.Long r11;
        int i0, $i2, i10;
        byte[] r12, r14, $r16, $r21, $r26, $r30;
        javax.crypto.SecretKey $r19, $r20, $r29;
        long $l5, $l6, $l7;
        double $d0, $d1, $d2, $d3, $d4, $d5;
        java.security.GeneralSecurityException $r36, r39;
        java.lang.IllegalStateException r43;
        java.io.OutputStream r44, r45;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        r1 := @parameter0: java.io.InputStream;

        r2 := @parameter1: java.nio.channels.SeekableByteChannel;

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel truncate(long)>(0L);

        $r16 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: byte[] randomData(int)>(16);

        r3 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer wrap(byte[])>($r16);

        virtualinvoke r3.<java.nio.ByteBuffer: java.nio.ByteBuffer putLong(int,long)>(8, 0L);

        virtualinvoke r3.<java.nio.ByteBuffer: java.nio.Buffer position(int)>(0);

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: int write(java.nio.ByteBuffer)>(r3);

        $r19 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey hMacMasterKey>;

        r4 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Mac hmacSha256(javax.crypto.SecretKey)>($r19);

        $r20 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        $r21 = virtualinvoke r3.<java.nio.ByteBuffer: byte[] array()>();

        r5 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesCtrCipher(javax.crypto.SecretKey,byte[],int)>($r20, $r21, 1);

        $i2 = virtualinvoke r4.<javax.crypto.Mac: int getMacLength()>();

        r6 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>($i2);

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: int write(java.nio.ByteBuffer)>(r6);

        r7 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(16);

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: int write(java.nio.ByteBuffer)>(r7);

        r40 = new org.cryptomator.crypto.io.SeekableByteChannelOutputStream;

        specialinvoke r40.<org.cryptomator.crypto.io.SeekableByteChannelOutputStream: void <init>(java.nio.channels.SeekableByteChannel)>(r2);

        r8 = r40;

        r41 = new org.cryptomator.crypto.aes256.MacOutputStream;

        r44 = (java.io.OutputStream) r8;

        specialinvoke r41.<org.cryptomator.crypto.aes256.MacOutputStream: void <init>(java.io.OutputStream,javax.crypto.Mac)>(r44, r4);

        r9 = r41;

        r42 = new javax.crypto.CipherOutputStream;

        r45 = (java.io.OutputStream) r9;

        specialinvoke r42.<javax.crypto.CipherOutputStream: void <init>(java.io.OutputStream,javax.crypto.Cipher)>(r45, r5);

        r10 = r42;

        $l5 = staticinvoke <org.apache.commons.io.IOUtils: long copyLarge(java.io.InputStream,java.io.OutputStream)>(r1, r10);

        r11 = staticinvoke <java.lang.Long: java.lang.Long valueOf(long)>($l5);

        virtualinvoke r6.<java.nio.ByteBuffer: java.nio.Buffer position(int)>(0);

        $r26 = virtualinvoke r4.<javax.crypto.Mac: byte[] doFinal()>();

        virtualinvoke r6.<java.nio.ByteBuffer: java.nio.ByteBuffer put(byte[])>($r26);

        $d0 = staticinvoke <java.lang.Math: double random()>();

        $d1 = $d0 + 1.0;

        $l6 = virtualinvoke r11.<java.lang.Long: long longValue()>();

        $d2 = (double) $l6;

        $d3 = $d1 * $d2;

        $d4 = $d3 / 20.0;

        $d5 = staticinvoke <java.lang.Math: double ceil(double)>($d4);

        i0 = (int) $d5;

        r12 = newarray (byte)[16];

        i10 = 0;

     label1:
        if i10 >= i0 goto label2;

        virtualinvoke r10.<java.io.OutputStream: void write(byte[])>(r12);

        i10 = i10 + 16;

        goto label1;

     label2:
        virtualinvoke r10.<java.io.OutputStream: void flush()>();

     label3:
        r38 = staticinvoke <java.nio.ByteBuffer: java.nio.ByteBuffer allocate(int)>(8);

        $l7 = virtualinvoke r11.<java.lang.Long: long longValue()>();

        virtualinvoke r38.<java.nio.ByteBuffer: java.nio.ByteBuffer putLong(long)>($l7);

        $r29 = r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.SecretKey primaryMasterKey>;

        r13 = specialinvoke r0.<org.cryptomator.crypto.aes256.Aes256Cryptor: javax.crypto.Cipher aesEcbCipher(javax.crypto.SecretKey,int)>($r29, 1);

        $r30 = virtualinvoke r38.<java.nio.ByteBuffer: byte[] array()>();

        r14 = virtualinvoke r13.<javax.crypto.Cipher: byte[] doFinal(byte[])>($r30);

        virtualinvoke r7.<java.nio.ByteBuffer: java.nio.Buffer position(int)>(0);

        virtualinvoke r7.<java.nio.ByteBuffer: java.nio.ByteBuffer put(byte[])>(r14);

     label4:
        goto label6;

     label5:
        $r36 := @caughtexception;

        r39 = $r36;

        r43 = new java.lang.IllegalStateException;

        specialinvoke r43.<java.lang.IllegalStateException: void <init>(java.lang.Throwable)>(r39);

        throw r43;

     label6:
        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: java.nio.channels.SeekableByteChannel position(long)>(16L);

        virtualinvoke r6.<java.nio.ByteBuffer: java.nio.Buffer position(int)>(0);

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: int write(java.nio.ByteBuffer)>(r6);

        virtualinvoke r7.<java.nio.ByteBuffer: java.nio.Buffer position(int)>(0);

        interfaceinvoke r2.<java.nio.channels.SeekableByteChannel: int write(java.nio.ByteBuffer)>(r7);

        return r11;

        catch javax.crypto.IllegalBlockSizeException from label3 to label4 with label5;
        catch javax.crypto.BadPaddingException from label3 to label4 with label5;
    }

    public java.nio.file.DirectoryStream$Filter getPayloadFilesFilter()
    {
        org.cryptomator.crypto.aes256.Aes256Cryptor r0;
        org.cryptomator.crypto.aes256.Aes256Cryptor$1 $r1;

        r0 := @this: org.cryptomator.crypto.aes256.Aes256Cryptor;

        $r1 = new org.cryptomator.crypto.aes256.Aes256Cryptor$1;

        specialinvoke $r1.<org.cryptomator.crypto.aes256.Aes256Cryptor$1: void <init>(org.cryptomator.crypto.aes256.Aes256Cryptor)>(r0);

        return $r1;
    }

    static void <clinit>()
    {
        java.security.SecureRandom $r0;
        java.security.NoSuchAlgorithmException $r1, r3;
        java.lang.IllegalStateException $r2;
        int i0, $i1;

     label1:
        $r0 = staticinvoke <java.security.SecureRandom: java.security.SecureRandom getInstance(java.lang.String)>("SHA1PRNG");

        <org.cryptomator.crypto.aes256.Aes256Cryptor: java.security.SecureRandom SECURE_PRNG> = $r0;

        i0 = staticinvoke <javax.crypto.Cipher: int getMaxAllowedKeyLength(java.lang.String)>("AES");

        if i0 < 256 goto label2;

        $i1 = 256;

        goto label3;

     label2:
        $i1 = i0;

     label3:
        <org.cryptomator.crypto.aes256.Aes256Cryptor: int AES_KEY_LENGTH_IN_BITS> = $i1;

     label4:
        goto label6;

     label5:
        $r1 := @caughtexception;

        r3 = $r1;

        $r2 = new java.lang.IllegalStateException;

        specialinvoke $r2.<java.lang.IllegalStateException: void <init>(java.lang.String,java.lang.Throwable)>("Algorithm should exist.", r3);

        throw $r2;

     label6:
        return;

        catch java.security.NoSuchAlgorithmException from label1 to label4 with label5;
    }
}
