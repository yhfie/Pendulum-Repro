(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :produce-models true)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 20000000)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun javaTypeType () T@T)
(declare-fun fixed.java.lang.Object () T@U)
(declare-fun fixed.java.lang.Boolean () T@U)
(declare-fun oneStep (T@U T@U) T@U)
(declare-fun fixed.Login () T@U)
(declare-fun fixed.java.io.Serializable () T@U)
(declare-fun fixed.java.lang.Comparable () T@U)
(declare-fun fixed.java.lang.CharSequence () T@U)
(declare-fun fixed.java.lang.String () T@U)
(declare-fun fixed.java.lang.Throwable () T@U)
(declare-fun fixed.java.lang.Exception () T@U)
(declare-fun fixed.java.lang.RuntimeException () T@U)
(declare-fun fixed.java.lang.NullPointerException () T@U)
(declare-fun fixed.java.lang.IndexOutOfBoundsException () T@U)
(declare-fun fixed.java.lang.ArrayIndexOutOfBoundsException () T@U)
(declare-fun fixed.sg.edu.nus.comp.tsunami.safe.Safe () T@U)
(declare-fun fixed.java.lang.ClassCastException () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun fixed.$type () T@U)
(declare-fun fixed.$alloc () T@U)
(declare-fun refType () T@T)
(declare-fun fixed.$null () T@U)
(declare-fun fixed.$intToBool (Int) Bool)
(declare-fun fixed.$refToBool (T@U) Bool)
(declare-fun fixed.$boolToInt (Bool) Int)
(declare-fun fixed.$cmpReal (Real Real) Int)
(declare-fun fixed.$cmpInt (Int Int) Int)
(declare-fun fixed.$intToRef (Int) T@U)
(declare-fun inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 () T@U)
(declare-fun inline$fixed.Login$retrieve$java.lang.String$0$$return@1 () T@U)
(declare-fun inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 () T@U)
(declare-fun inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 () T@U)
(declare-fun MapType0Type (T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U T@U) T@U)
(declare-fun fixed.$heap@11 () T@U)
(declare-fun fixed.$heap@5 () T@U)
(declare-fun fixed.$heap () T@U)
(declare-fun MapType1Type (T@T T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1TypeInv1 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun fixed.$arrSizeHeap@0 () T@U)
(declare-fun fixed.$arrSizeHeap@1 () T@U)
(declare-fun fixed.$intArrHeap@4 () T@U)
(declare-fun fixed.$intArrHeap@9 () T@U)
(declare-fun call3formal@$obj@0 () T@U)
(declare-fun call3formal@$obj@0@@0 () T@U)
(declare-fun fixed.$heap@7 () T@U)
(declare-fun fixed.$heap@6 () T@U)
(declare-fun fixed.$intArrHeap () T@U)
(declare-fun call3formal@$obj@0@@1 () T@U)
(declare-fun fixed.$heap@8 () T@U)
(declare-fun fixed.$intArrHeap@5 () T@U)
(declare-fun call3formal@$obj@0@@2 () T@U)
(declare-fun fixed.$heap@9 () T@U)
(declare-fun fixed.$intArrHeap@6 () T@U)
(declare-fun call3formal@$obj@0@@3 () T@U)
(declare-fun fixed.$heap@10 () T@U)
(declare-fun fixed.$intArrHeap@7 () T@U)
(declare-fun fixed.$intArrHeap@8 () T@U)
(declare-fun fixed.$arrSizeHeap () T@U)
(declare-fun fixed.$stringSizeHeap () T@U)
(declare-fun $in_parameter__0 () T@U)
(declare-fun fixed.$intArrayType () T@U)
(declare-fun call3formal@$obj@0@@4 () T@U)
(declare-fun call3formal@$obj@0@@5 () T@U)
(declare-fun fixed.$heap@1 () T@U)
(declare-fun fixed.$heap@0 () T@U)
(declare-fun call3formal@$obj@0@@6 () T@U)
(declare-fun fixed.$heap@2 () T@U)
(declare-fun fixed.$intArrHeap@0 () T@U)
(declare-fun call3formal@$obj@0@@7 () T@U)
(declare-fun fixed.$heap@3 () T@U)
(declare-fun fixed.$intArrHeap@1 () T@U)
(declare-fun call3formal@$obj@0@@8 () T@U)
(declare-fun fixed.$heap@4 () T@U)
(declare-fun fixed.$intArrHeap@2 () T@U)
(declare-fun fixed.$intArrHeap@3 () T@U)
(declare-fun %lbl%+340826 () Bool)
(declare-fun AA_TEMP130@1 () Bool)
(declare-fun AA_TEMP130@0 () Bool)
(declare-fun AA_TEMP131@1 () Bool)
(declare-fun AA_TEMP131@0 () Bool)
(declare-fun AA_TEMP132@1 () Bool)
(declare-fun AA_TEMP132@0 () Bool)
(declare-fun fixed.$objIndex@10 () Int)
(declare-fun AA_TEMP133@1 () Bool)
(declare-fun AA_TEMP133@0 () Bool)
(declare-fun AA_TEMP134@1 () Bool)
(declare-fun AA_TEMP134@0 () Bool)
(declare-fun AA_TEMP135@1 () Bool)
(declare-fun AA_TEMP135@0 () Bool)
(declare-fun %lbl%@348931 () Bool)
(declare-fun %lbl%+340825 () Bool)
(declare-fun %lbl%+340824 () Bool)
(declare-fun fixed.$objIndex@5 () Int)
(declare-fun %lbl%+340823 () Bool)
(declare-fun %lbl%+340822 () Bool)
(declare-fun %lbl%+340821 () Bool)
(declare-fun fixed.$objIndex@9 () Int)
(declare-fun %lbl%+340820 () Bool)
(declare-fun %lbl%+340819 () Bool)
(declare-fun %lbl%+340818 () Bool)
(declare-fun fixed.$objIndex@8 () Int)
(declare-fun %lbl%+340817 () Bool)
(declare-fun %lbl%+340816 () Bool)
(declare-fun %lbl%+340815 () Bool)
(declare-fun fixed.$objIndex@7 () Int)
(declare-fun %lbl%+340814 () Bool)
(declare-fun %lbl%+340813 () Bool)
(declare-fun %lbl%+340812 () Bool)
(declare-fun fixed.$objIndex@6 () Int)
(declare-fun %lbl%+340811 () Bool)
(declare-fun fixed.$objIndex () Int)
(declare-fun %lbl%+340810 () Bool)
(declare-fun %lbl%+340809 () Bool)
(declare-fun %lbl%+340808 () Bool)
(declare-fun %lbl%+340807 () Bool)
(declare-fun %lbl%+340806 () Bool)
(declare-fun %lbl%+340805 () Bool)
(declare-fun %lbl%+340804 () Bool)
(declare-fun fixed.$objIndex@4 () Int)
(declare-fun fixed.$objIndex@0 () Int)
(declare-fun %lbl%+340803 () Bool)
(declare-fun %lbl%+340802 () Bool)
(declare-fun %lbl%+340801 () Bool)
(declare-fun fixed.$objIndex@3 () Int)
(declare-fun %lbl%+340800 () Bool)
(declare-fun %lbl%+340799 () Bool)
(declare-fun %lbl%+340798 () Bool)
(declare-fun fixed.$objIndex@2 () Int)
(declare-fun %lbl%+340797 () Bool)
(declare-fun %lbl%+340796 () Bool)
(declare-fun %lbl%+340795 () Bool)
(declare-fun fixed.$objIndex@1 () Int)
(declare-fun %lbl%+340794 () Bool)
(declare-fun %lbl%+340793 () Bool)
(declare-fun %lbl%+340792 () Bool)
(declare-fun %lbl%+346185 () Bool)
(declare-fun %lbl%+346194 () Bool)
(assert  (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0)
 :qid |typeInv:U_2_int|
 :pattern ( (int_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
 :qid |cast:U_2_int|
 :pattern ( (U_2_int x))
))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType)
 :qid |funType:int_2_U|
 :pattern ( (int_2_U arg0@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :qid |typeInv:U_2_real|
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))
 :qid |cast:U_2_real|
 :pattern ( (U_2_real x@@0))
))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType)
 :qid |funType:real_2_U|
 :pattern ( (real_2_U arg0@@2))
))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
 :qid |typeInv:U_2_bool|
 :pattern ( (bool_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))
 :qid |cast:U_2_bool|
 :pattern ( (U_2_bool x@@1))
))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType)
 :qid |funType:bool_2_U|
 :pattern ( (bool_2_U arg0@@4))
))))
(assert (forall ((x@@2 T@U) ) (! (UOrdering2 x@@2 x@@2)
 :qid |bg:subtype-refl|
 :no-pattern (U_2_int x@@2)
 :no-pattern (U_2_bool x@@2)
)))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@3)))
 (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z)))
 :qid |bg:subtype-trans|
 :pattern ( (UOrdering2 x@@3 y) (UOrdering2 y z))
)))
(assert (forall ((x@@4 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@4)))
 (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0))))
 :qid |bg:subtype-antisymm|
 :pattern ( (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4))
)))
(assert  (and (= (Ctor javaTypeType) 3) (= (type fixed.java.lang.Object) javaTypeType)))
(assert (forall ((w T@U) ) (!  (=> (and (= (type w) javaTypeType) (UOrdering2 fixed.java.lang.Object w)) (= fixed.java.lang.Object w))
 :pattern ( (UOrdering2 fixed.java.lang.Object w))
)))
(assert (= (type fixed.java.lang.Boolean) javaTypeType))
(assert (not (= fixed.java.lang.Boolean fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Boolean fixed.java.lang.Object))
(assert (forall ((w@@0 T@U) ) (!  (=> (= (type w@@0) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Boolean w@@0) (UOrdering2 w@@0 fixed.java.lang.Object)) (or (= fixed.java.lang.Boolean w@@0) (= fixed.java.lang.Object w@@0))))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@0) (UOrdering2 w@@0 fixed.java.lang.Object))
)))
(assert (forall ((w@@1 T@U) ) (!  (=> (and (= (type w@@1) javaTypeType) (UOrdering2 fixed.java.lang.Boolean w@@1)) (or (= fixed.java.lang.Boolean w@@1) (UOrdering2 fixed.java.lang.Object w@@1)))
 :pattern ( (UOrdering2 fixed.java.lang.Boolean w@@1))
)))
(assert (forall ((arg0@@5 T@U) (arg1 T@U) ) (! (= (type (oneStep arg0@@5 arg1)) javaTypeType)
 :qid |funType:oneStep|
 :pattern ( (oneStep arg0@@5 arg1))
)))
(assert (forall ((w@@2 T@U) ) (!  (=> (and (= (type w@@2) javaTypeType) (UOrdering2 w@@2 fixed.java.lang.Boolean)) (= (oneStep fixed.java.lang.Object w@@2) fixed.java.lang.Boolean))
 :pattern ( (UOrdering2 w@@2 fixed.java.lang.Boolean))
)))
(assert (= (type fixed.Login) javaTypeType))
(assert (not (= fixed.Login fixed.java.lang.Object)))
(assert (UOrdering2 fixed.Login fixed.java.lang.Object))
(assert (forall ((w@@3 T@U) ) (!  (=> (= (type w@@3) javaTypeType) (=> (and (UOrdering2 fixed.Login w@@3) (UOrdering2 w@@3 fixed.java.lang.Object)) (or (= fixed.Login w@@3) (= fixed.java.lang.Object w@@3))))
 :pattern ( (UOrdering2 fixed.Login w@@3) (UOrdering2 w@@3 fixed.java.lang.Object))
)))
(assert (forall ((w@@4 T@U) ) (!  (=> (and (= (type w@@4) javaTypeType) (UOrdering2 fixed.Login w@@4)) (or (= fixed.Login w@@4) (UOrdering2 fixed.java.lang.Object w@@4)))
 :pattern ( (UOrdering2 fixed.Login w@@4))
)))
(assert (forall ((w@@5 T@U) ) (!  (=> (and (= (type w@@5) javaTypeType) (UOrdering2 w@@5 fixed.Login)) (= (oneStep fixed.java.lang.Object w@@5) fixed.Login))
 :pattern ( (UOrdering2 w@@5 fixed.Login))
)))
(assert (= (type fixed.java.io.Serializable) javaTypeType))
(assert (forall ((w@@6 T@U) ) (!  (=> (and (= (type w@@6) javaTypeType) (UOrdering2 fixed.java.io.Serializable w@@6)) (= fixed.java.io.Serializable w@@6))
 :pattern ( (UOrdering2 fixed.java.io.Serializable w@@6))
)))
(assert (= (type fixed.java.lang.Comparable) javaTypeType))
(assert (forall ((w@@7 T@U) ) (!  (=> (and (= (type w@@7) javaTypeType) (UOrdering2 fixed.java.lang.Comparable w@@7)) (= fixed.java.lang.Comparable w@@7))
 :pattern ( (UOrdering2 fixed.java.lang.Comparable w@@7))
)))
(assert (= (type fixed.java.lang.CharSequence) javaTypeType))
(assert (forall ((w@@8 T@U) ) (!  (=> (and (= (type w@@8) javaTypeType) (UOrdering2 fixed.java.lang.CharSequence w@@8)) (= fixed.java.lang.CharSequence w@@8))
 :pattern ( (UOrdering2 fixed.java.lang.CharSequence w@@8))
)))
(assert (= (type fixed.java.lang.String) javaTypeType))
(assert (not (= fixed.java.lang.String fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.Object))
(assert (not (= fixed.java.lang.String fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.io.Serializable))
(assert (not (= fixed.java.lang.String fixed.java.lang.Comparable)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.Comparable))
(assert (not (= fixed.java.lang.String fixed.java.lang.CharSequence)))
(assert (UOrdering2 fixed.java.lang.String fixed.java.lang.CharSequence))
(assert (forall ((w@@9 T@U) ) (!  (=> (= (type w@@9) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@9) (UOrdering2 w@@9 fixed.java.lang.Object)) (or (= fixed.java.lang.String w@@9) (= fixed.java.lang.Object w@@9))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@9) (UOrdering2 w@@9 fixed.java.lang.Object))
)))
(assert (forall ((w@@10 T@U) ) (!  (=> (= (type w@@10) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@10) (UOrdering2 w@@10 fixed.java.io.Serializable)) (or (= fixed.java.lang.String w@@10) (= fixed.java.io.Serializable w@@10))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@10) (UOrdering2 w@@10 fixed.java.io.Serializable))
)))
(assert (forall ((w@@11 T@U) ) (!  (=> (= (type w@@11) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@11) (UOrdering2 w@@11 fixed.java.lang.Comparable)) (or (= fixed.java.lang.String w@@11) (= fixed.java.lang.Comparable w@@11))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@11) (UOrdering2 w@@11 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@12 T@U) ) (!  (=> (= (type w@@12) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.String w@@12) (UOrdering2 w@@12 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.String w@@12) (= fixed.java.lang.CharSequence w@@12))))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@12) (UOrdering2 w@@12 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@13 T@U) ) (!  (=> (and (= (type w@@13) javaTypeType) (UOrdering2 fixed.java.lang.String w@@13)) (or (or (or (or (= fixed.java.lang.String w@@13) (UOrdering2 fixed.java.lang.Object w@@13)) (UOrdering2 fixed.java.io.Serializable w@@13)) (UOrdering2 fixed.java.lang.Comparable w@@13)) (UOrdering2 fixed.java.lang.CharSequence w@@13)))
 :pattern ( (UOrdering2 fixed.java.lang.String w@@13))
)))
(assert (forall ((w@@14 T@U) ) (!  (=> (and (= (type w@@14) javaTypeType) (UOrdering2 w@@14 fixed.java.lang.String)) (= (oneStep fixed.java.lang.Object w@@14) fixed.java.lang.String))
 :pattern ( (UOrdering2 w@@14 fixed.java.lang.String))
)))
(assert (= (type fixed.java.lang.Throwable) javaTypeType))
(assert (not (= fixed.java.lang.Throwable fixed.java.lang.Object)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.lang.Object))
(assert (not (= fixed.java.lang.Throwable fixed.java.io.Serializable)))
(assert (UOrdering2 fixed.java.lang.Throwable fixed.java.io.Serializable))
(assert (forall ((w@@15 T@U) ) (!  (=> (= (type w@@15) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@15) (UOrdering2 w@@15 fixed.java.lang.Object)) (or (= fixed.java.lang.Throwable w@@15) (= fixed.java.lang.Object w@@15))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@15) (UOrdering2 w@@15 fixed.java.lang.Object))
)))
(assert (forall ((w@@16 T@U) ) (!  (=> (= (type w@@16) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Throwable w@@16) (UOrdering2 w@@16 fixed.java.io.Serializable)) (or (= fixed.java.lang.Throwable w@@16) (= fixed.java.io.Serializable w@@16))))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@16) (UOrdering2 w@@16 fixed.java.io.Serializable))
)))
(assert (forall ((w@@17 T@U) ) (!  (=> (and (= (type w@@17) javaTypeType) (UOrdering2 fixed.java.lang.Throwable w@@17)) (or (or (= fixed.java.lang.Throwable w@@17) (UOrdering2 fixed.java.lang.Object w@@17)) (UOrdering2 fixed.java.io.Serializable w@@17)))
 :pattern ( (UOrdering2 fixed.java.lang.Throwable w@@17))
)))
(assert (forall ((w@@18 T@U) ) (!  (=> (and (= (type w@@18) javaTypeType) (UOrdering2 w@@18 fixed.java.lang.Throwable)) (= (oneStep fixed.java.lang.Object w@@18) fixed.java.lang.Throwable))
 :pattern ( (UOrdering2 w@@18 fixed.java.lang.Throwable))
)))
(assert (= (type fixed.java.lang.Exception) javaTypeType))
(assert (not (= fixed.java.lang.Exception fixed.java.lang.Throwable)))
(assert (UOrdering2 fixed.java.lang.Exception fixed.java.lang.Throwable))
(assert (forall ((w@@19 T@U) ) (!  (=> (= (type w@@19) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.Exception w@@19) (UOrdering2 w@@19 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Exception w@@19) (= fixed.java.lang.Throwable w@@19))))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@19) (UOrdering2 w@@19 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@20 T@U) ) (!  (=> (and (= (type w@@20) javaTypeType) (UOrdering2 fixed.java.lang.Exception w@@20)) (or (= fixed.java.lang.Exception w@@20) (UOrdering2 fixed.java.lang.Throwable w@@20)))
 :pattern ( (UOrdering2 fixed.java.lang.Exception w@@20))
)))
(assert (forall ((w@@21 T@U) ) (!  (=> (and (= (type w@@21) javaTypeType) (UOrdering2 w@@21 fixed.java.lang.Exception)) (= (oneStep fixed.java.lang.Throwable w@@21) fixed.java.lang.Exception))
 :pattern ( (UOrdering2 w@@21 fixed.java.lang.Exception))
)))
(assert (= (type fixed.java.lang.RuntimeException) javaTypeType))
(assert (not (= fixed.java.lang.RuntimeException fixed.java.lang.Exception)))
(assert (UOrdering2 fixed.java.lang.RuntimeException fixed.java.lang.Exception))
(assert (forall ((w@@22 T@U) ) (!  (=> (= (type w@@22) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.RuntimeException w@@22) (UOrdering2 w@@22 fixed.java.lang.Exception)) (or (= fixed.java.lang.RuntimeException w@@22) (= fixed.java.lang.Exception w@@22))))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@22) (UOrdering2 w@@22 fixed.java.lang.Exception))
)))
(assert (forall ((w@@23 T@U) ) (!  (=> (and (= (type w@@23) javaTypeType) (UOrdering2 fixed.java.lang.RuntimeException w@@23)) (or (= fixed.java.lang.RuntimeException w@@23) (UOrdering2 fixed.java.lang.Exception w@@23)))
 :pattern ( (UOrdering2 fixed.java.lang.RuntimeException w@@23))
)))
(assert (forall ((w@@24 T@U) ) (!  (=> (and (= (type w@@24) javaTypeType) (UOrdering2 w@@24 fixed.java.lang.RuntimeException)) (= (oneStep fixed.java.lang.Exception w@@24) fixed.java.lang.RuntimeException))
 :pattern ( (UOrdering2 w@@24 fixed.java.lang.RuntimeException))
)))
(assert (= (type fixed.java.lang.NullPointerException) javaTypeType))
(assert (not (= fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.NullPointerException fixed.java.lang.RuntimeException))
(assert (forall ((w@@25 T@U) ) (!  (=> (= (type w@@25) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.NullPointerException w@@25) (UOrdering2 w@@25 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.NullPointerException w@@25) (= fixed.java.lang.RuntimeException w@@25))))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@25) (UOrdering2 w@@25 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@26 T@U) ) (!  (=> (and (= (type w@@26) javaTypeType) (UOrdering2 fixed.java.lang.NullPointerException w@@26)) (or (= fixed.java.lang.NullPointerException w@@26) (UOrdering2 fixed.java.lang.RuntimeException w@@26)))
 :pattern ( (UOrdering2 fixed.java.lang.NullPointerException w@@26))
)))
(assert (forall ((w@@27 T@U) ) (!  (=> (and (= (type w@@27) javaTypeType) (UOrdering2 w@@27 fixed.java.lang.NullPointerException)) (= (oneStep fixed.java.lang.RuntimeException w@@27) fixed.java.lang.NullPointerException))
 :pattern ( (UOrdering2 w@@27 fixed.java.lang.NullPointerException))
)))
(assert (= (type fixed.java.lang.IndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.RuntimeException))
(assert (forall ((w@@28 T@U) ) (!  (=> (= (type w@@28) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@28) (UOrdering2 w@@28 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@28) (= fixed.java.lang.RuntimeException w@@28))))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@28) (UOrdering2 w@@28 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@29 T@U) ) (!  (=> (and (= (type w@@29) javaTypeType) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@29)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@29) (UOrdering2 fixed.java.lang.RuntimeException w@@29)))
 :pattern ( (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@29))
)))
(assert (forall ((w@@30 T@U) ) (!  (=> (and (= (type w@@30) javaTypeType) (UOrdering2 w@@30 fixed.java.lang.IndexOutOfBoundsException)) (= (oneStep fixed.java.lang.RuntimeException w@@30) fixed.java.lang.IndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@30 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (= (type fixed.java.lang.ArrayIndexOutOfBoundsException) javaTypeType))
(assert (not (= fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException)))
(assert (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException fixed.java.lang.IndexOutOfBoundsException))
(assert (forall ((w@@31 T@U) ) (!  (=> (= (type w@@31) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@31) (UOrdering2 w@@31 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@31) (= fixed.java.lang.IndexOutOfBoundsException w@@31))))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@31) (UOrdering2 w@@31 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@32 T@U) ) (!  (=> (and (= (type w@@32) javaTypeType) (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@32)) (or (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@32) (UOrdering2 fixed.java.lang.IndexOutOfBoundsException w@@32)))
 :pattern ( (UOrdering2 fixed.java.lang.ArrayIndexOutOfBoundsException w@@32))
)))
(assert (forall ((w@@33 T@U) ) (!  (=> (and (= (type w@@33) javaTypeType) (UOrdering2 w@@33 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= (oneStep fixed.java.lang.IndexOutOfBoundsException w@@33) fixed.java.lang.ArrayIndexOutOfBoundsException))
 :pattern ( (UOrdering2 w@@33 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (= (type fixed.sg.edu.nus.comp.tsunami.safe.Safe) javaTypeType))
(assert (not (= fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object)))
(assert (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.Object))
(assert (forall ((w@@34 T@U) ) (!  (=> (= (type w@@34) javaTypeType) (=> (and (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@34) (UOrdering2 w@@34 fixed.java.lang.Object)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@34) (= fixed.java.lang.Object w@@34))))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@34) (UOrdering2 w@@34 fixed.java.lang.Object))
)))
(assert (forall ((w@@35 T@U) ) (!  (=> (and (= (type w@@35) javaTypeType) (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@35)) (or (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@35) (UOrdering2 fixed.java.lang.Object w@@35)))
 :pattern ( (UOrdering2 fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@35))
)))
(assert (forall ((w@@36 T@U) ) (!  (=> (and (= (type w@@36) javaTypeType) (UOrdering2 w@@36 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= (oneStep fixed.java.lang.Object w@@36) fixed.sg.edu.nus.comp.tsunami.safe.Safe))
 :pattern ( (UOrdering2 w@@36 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (= (type fixed.java.lang.ClassCastException) javaTypeType))
(assert (not (= fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException)))
(assert (UOrdering2 fixed.java.lang.ClassCastException fixed.java.lang.RuntimeException))
(assert (forall ((w@@37 T@U) ) (!  (=> (= (type w@@37) javaTypeType) (=> (and (UOrdering2 fixed.java.lang.ClassCastException w@@37) (UOrdering2 w@@37 fixed.java.lang.RuntimeException)) (or (= fixed.java.lang.ClassCastException w@@37) (= fixed.java.lang.RuntimeException w@@37))))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@37) (UOrdering2 w@@37 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@38 T@U) ) (!  (=> (and (= (type w@@38) javaTypeType) (UOrdering2 fixed.java.lang.ClassCastException w@@38)) (or (= fixed.java.lang.ClassCastException w@@38) (UOrdering2 fixed.java.lang.RuntimeException w@@38)))
 :pattern ( (UOrdering2 fixed.java.lang.ClassCastException w@@38))
)))
(assert (forall ((w@@39 T@U) ) (!  (=> (and (= (type w@@39) javaTypeType) (UOrdering2 w@@39 fixed.java.lang.ClassCastException)) (= (oneStep fixed.java.lang.RuntimeException w@@39) fixed.java.lang.ClassCastException))
 :pattern ( (UOrdering2 w@@39 fixed.java.lang.ClassCastException))
)))
(assert (forall ((w@@40 T@U) ) (!  (=> (and (= (type w@@40) javaTypeType) (UOrdering2 w@@40 fixed.java.lang.Object)) (or (or (or (or (or (= fixed.java.lang.Object w@@40) (UOrdering2 w@@40 fixed.java.lang.Boolean)) (UOrdering2 w@@40 fixed.Login)) (UOrdering2 w@@40 fixed.java.lang.String)) (UOrdering2 w@@40 fixed.java.lang.Throwable)) (UOrdering2 w@@40 fixed.sg.edu.nus.comp.tsunami.safe.Safe)))
 :pattern ( (UOrdering2 w@@40 fixed.java.lang.Object))
)))
(assert (forall ((w@@41 T@U) ) (!  (=> (and (= (type w@@41) javaTypeType) (UOrdering2 w@@41 fixed.java.lang.Boolean)) (= fixed.java.lang.Boolean w@@41))
 :pattern ( (UOrdering2 w@@41 fixed.java.lang.Boolean))
)))
(assert (forall ((w@@42 T@U) ) (!  (=> (and (= (type w@@42) javaTypeType) (UOrdering2 w@@42 fixed.Login)) (= fixed.Login w@@42))
 :pattern ( (UOrdering2 w@@42 fixed.Login))
)))
(assert (forall ((w@@43 T@U) ) (!  (=> (and (= (type w@@43) javaTypeType) (UOrdering2 w@@43 fixed.java.io.Serializable)) (or (or (= fixed.java.io.Serializable w@@43) (UOrdering2 w@@43 fixed.java.lang.String)) (UOrdering2 w@@43 fixed.java.lang.Throwable)))
 :pattern ( (UOrdering2 w@@43 fixed.java.io.Serializable))
)))
(assert (forall ((w@@44 T@U) ) (!  (=> (and (= (type w@@44) javaTypeType) (UOrdering2 w@@44 fixed.java.lang.Comparable)) (or (= fixed.java.lang.Comparable w@@44) (UOrdering2 w@@44 fixed.java.lang.String)))
 :pattern ( (UOrdering2 w@@44 fixed.java.lang.Comparable))
)))
(assert (forall ((w@@45 T@U) ) (!  (=> (and (= (type w@@45) javaTypeType) (UOrdering2 w@@45 fixed.java.lang.CharSequence)) (or (= fixed.java.lang.CharSequence w@@45) (UOrdering2 w@@45 fixed.java.lang.String)))
 :pattern ( (UOrdering2 w@@45 fixed.java.lang.CharSequence))
)))
(assert (forall ((w@@46 T@U) ) (!  (=> (and (= (type w@@46) javaTypeType) (UOrdering2 w@@46 fixed.java.lang.String)) (= fixed.java.lang.String w@@46))
 :pattern ( (UOrdering2 w@@46 fixed.java.lang.String))
)))
(assert (forall ((w@@47 T@U) ) (!  (=> (and (= (type w@@47) javaTypeType) (UOrdering2 w@@47 fixed.java.lang.Throwable)) (or (= fixed.java.lang.Throwable w@@47) (UOrdering2 w@@47 fixed.java.lang.Exception)))
 :pattern ( (UOrdering2 w@@47 fixed.java.lang.Throwable))
)))
(assert (forall ((w@@48 T@U) ) (!  (=> (and (= (type w@@48) javaTypeType) (UOrdering2 w@@48 fixed.java.lang.Exception)) (or (= fixed.java.lang.Exception w@@48) (UOrdering2 w@@48 fixed.java.lang.RuntimeException)))
 :pattern ( (UOrdering2 w@@48 fixed.java.lang.Exception))
)))
(assert (forall ((w@@49 T@U) ) (!  (=> (and (= (type w@@49) javaTypeType) (UOrdering2 w@@49 fixed.java.lang.RuntimeException)) (or (or (or (= fixed.java.lang.RuntimeException w@@49) (UOrdering2 w@@49 fixed.java.lang.NullPointerException)) (UOrdering2 w@@49 fixed.java.lang.IndexOutOfBoundsException)) (UOrdering2 w@@49 fixed.java.lang.ClassCastException)))
 :pattern ( (UOrdering2 w@@49 fixed.java.lang.RuntimeException))
)))
(assert (forall ((w@@50 T@U) ) (!  (=> (and (= (type w@@50) javaTypeType) (UOrdering2 w@@50 fixed.java.lang.NullPointerException)) (= fixed.java.lang.NullPointerException w@@50))
 :pattern ( (UOrdering2 w@@50 fixed.java.lang.NullPointerException))
)))
(assert (forall ((w@@51 T@U) ) (!  (=> (and (= (type w@@51) javaTypeType) (UOrdering2 w@@51 fixed.java.lang.IndexOutOfBoundsException)) (or (= fixed.java.lang.IndexOutOfBoundsException w@@51) (UOrdering2 w@@51 fixed.java.lang.ArrayIndexOutOfBoundsException)))
 :pattern ( (UOrdering2 w@@51 fixed.java.lang.IndexOutOfBoundsException))
)))
(assert (forall ((w@@52 T@U) ) (!  (=> (and (= (type w@@52) javaTypeType) (UOrdering2 w@@52 fixed.java.lang.ArrayIndexOutOfBoundsException)) (= fixed.java.lang.ArrayIndexOutOfBoundsException w@@52))
 :pattern ( (UOrdering2 w@@52 fixed.java.lang.ArrayIndexOutOfBoundsException))
)))
(assert (forall ((w@@53 T@U) ) (!  (=> (and (= (type w@@53) javaTypeType) (UOrdering2 w@@53 fixed.sg.edu.nus.comp.tsunami.safe.Safe)) (= fixed.sg.edu.nus.comp.tsunami.safe.Safe w@@53))
 :pattern ( (UOrdering2 w@@53 fixed.sg.edu.nus.comp.tsunami.safe.Safe))
)))
(assert (forall ((w@@54 T@U) ) (!  (=> (and (= (type w@@54) javaTypeType) (UOrdering2 w@@54 fixed.java.lang.ClassCastException)) (= fixed.java.lang.ClassCastException w@@54))
 :pattern ( (UOrdering2 w@@54 fixed.java.lang.ClassCastException))
)))
(assert  (and (and (and (and (and (forall ((arg0@@6 T@T) ) (! (= (Ctor (FieldType arg0@@6)) 4)
 :qid |ctor:FieldType|
)) (forall ((arg0@@7 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@7)) arg0@@7)
 :qid |typeInv:FieldTypeInv0|
 :pattern ( (FieldType arg0@@7))
))) (= (type fixed.$type) (FieldType javaTypeType))) (= (type fixed.$alloc) (FieldType boolType))) (= (Ctor refType) 5)) (= (type fixed.$null) refType)))
(assert (distinct fixed.$type fixed.$alloc fixed.$null fixed.java.lang.Object fixed.java.lang.Boolean fixed.Login fixed.java.io.Serializable fixed.java.lang.Comparable fixed.java.lang.CharSequence fixed.java.lang.String fixed.java.lang.Throwable fixed.java.lang.Exception fixed.java.lang.RuntimeException fixed.java.lang.NullPointerException fixed.java.lang.IndexOutOfBoundsException fixed.java.lang.ArrayIndexOutOfBoundsException fixed.sg.edu.nus.comp.tsunami.safe.Safe fixed.java.lang.ClassCastException)
)
(assert (forall ((x@@5 Int) ) (!  (and (=> (fixed.$intToBool x@@5) (ite (= x@@5 0) false true)) (=> (ite (= x@@5 0) false true) (fixed.$intToBool x@@5)))
 :qid |RSPROCLo.103:15|
 :skolemid |1619|
 :pattern ( (fixed.$intToBool x@@5))
)))
(assert (forall ((x@@6 T@U) ) (!  (=> (= (type x@@6) refType) (and (=> (fixed.$refToBool x@@6) (ite (= x@@6 fixed.$null) false true)) (=> (ite (= x@@6 fixed.$null) false true) (fixed.$refToBool x@@6))))
 :qid |RSPROCLo.107:15|
 :skolemid |1620|
 :pattern ( (fixed.$refToBool x@@6))
)))
(assert (forall ((x@@7 Bool) ) (! (= (fixed.$boolToInt x@@7) (ite  (and (=> x@@7 true) (=> true x@@7)) 1 0))
 :qid |RSPROCLo.111:15|
 :skolemid |1621|
 :pattern ( (fixed.$boolToInt x@@7))
)))
(assert (forall ((x@@8 Real) (y@@1 Real) ) (! (= (fixed.$cmpReal x@@8 y@@1) (ite (> x@@8 y@@1) 1 (ite (< x@@8 y@@1) (- 0 1) 0)))
 :qid |RSPROCLo.115:15|
 :skolemid |1622|
 :pattern ( (fixed.$cmpReal x@@8 y@@1))
)))
(assert (forall ((x@@9 Int) (y@@2 Int) ) (! (= (fixed.$cmpInt x@@9 y@@2) (ite (> x@@9 y@@2) 1 (ite (< x@@9 y@@2) (- 0 1) 0)))
 :qid |RSPROCLo.119:15|
 :skolemid |1623|
 :pattern ( (fixed.$cmpInt x@@9 y@@2))
)))
(assert (forall ((arg0@@8 Int) ) (! (= (type (fixed.$intToRef arg0@@8)) refType)
 :qid |funType:fixed.$intToRef|
 :pattern ( (fixed.$intToRef arg0@@8))
)))
(assert (forall ((index Int) ) (! (not (= (fixed.$intToRef index) fixed.$null))
 :qid |RSPROCLo.123:15|
 :skolemid |1624|
)))
(assert (forall ((i1 Int) (i2 Int) ) (!  (and (=> (= i1 i2) (= (fixed.$intToRef i1) (fixed.$intToRef i2))) (=> (= (fixed.$intToRef i1) (fixed.$intToRef i2)) (= i1 i2)))
 :qid |RSPROCLo.125:15|
 :skolemid |1625|
)))
(assert (forall ((x@@10 Int) ) (!  (and (=> (fixed.$intToBool x@@10) (ite (= x@@10 0) false true)) (=> (ite (= x@@10 0) false true) (fixed.$intToBool x@@10)))
 :qid |RSPROCLo.7893:15|
 :skolemid |1932|
 :pattern ( (fixed.$intToBool x@@10))
)))
(assert (forall ((x@@11 T@U) ) (!  (=> (= (type x@@11) refType) (and (=> (fixed.$refToBool x@@11) (ite (= x@@11 fixed.$null) false true)) (=> (ite (= x@@11 fixed.$null) false true) (fixed.$refToBool x@@11))))
 :qid |RSPROCLo.7897:15|
 :skolemid |1933|
 :pattern ( (fixed.$refToBool x@@11))
)))
(assert (forall ((x@@12 Bool) ) (! (= (fixed.$boolToInt x@@12) (ite  (and (=> x@@12 true) (=> true x@@12)) 1 0))
 :qid |RSPROCLo.7901:15|
 :skolemid |1934|
 :pattern ( (fixed.$boolToInt x@@12))
)))
(assert (forall ((x@@13 Real) (y@@3 Real) ) (! (= (fixed.$cmpReal x@@13 y@@3) (ite (> x@@13 y@@3) 1 (ite (< x@@13 y@@3) (- 0 1) 0)))
 :qid |RSPROCLo.7905:15|
 :skolemid |1935|
 :pattern ( (fixed.$cmpReal x@@13 y@@3))
)))
(assert (forall ((x@@14 Int) (y@@4 Int) ) (! (= (fixed.$cmpInt x@@14 y@@4) (ite (> x@@14 y@@4) 1 (ite (< x@@14 y@@4) (- 0 1) 0)))
 :qid |RSPROCLo.7909:15|
 :skolemid |1936|
 :pattern ( (fixed.$cmpInt x@@14 y@@4))
)))
(assert (forall ((index@@0 Int) ) (! (not (= (fixed.$intToRef index@@0) fixed.$null))
 :qid |RSPROCLo.7913:15|
 :skolemid |1937|
)))
(assert (forall ((i1@@0 Int) (i2@@0 Int) ) (!  (and (=> (= i1@@0 i2@@0) (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0))) (=> (= (fixed.$intToRef i1@@0) (fixed.$intToRef i2@@0)) (= i1@@0 i2@@0)))
 :qid |RSPROCLo.7915:15|
 :skolemid |1938|
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type inline$unsafe.Login$retrieve$java.lang.String$0$$return@1) refType) (= (type inline$fixed.Login$retrieve$java.lang.String$0$$return@1) refType)) (= (type inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1) refType)) (= (type inline$fixed.Login$retrieve$java.lang.String$0$$exception@1) refType)) (forall ((arg0@@9 T@T) ) (! (= (Ctor (MapType0Type arg0@@9)) 6)
 :qid |ctor:MapType0Type|
))) (forall ((arg0@@10 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@10)) arg0@@10)
 :qid |typeInv:MapType0TypeInv0|
 :pattern ( (MapType0Type arg0@@10))
))) (forall ((arg0@@11 T@U) (arg1@@0 T@U) (arg2 T@U) ) (! (let (($GenericType__0 (FieldTypeInv0 (type arg2))))
(= (type (MapType0Select arg0@@11 arg1@@0 arg2)) $GenericType__0))
 :qid |funType:MapType0Select|
 :pattern ( (MapType0Select arg0@@11 arg1@@0 arg2))
))) (forall ((arg0@@12 T@U) (arg1@@1 T@U) (arg2@@0 T@U) (arg3 T@U) ) (! (let ((aVar0 (type arg1@@1)))
(= (type (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3)) (MapType0Type aVar0)))
 :qid |funType:MapType0Store|
 :pattern ( (MapType0Store arg0@@12 arg1@@1 arg2@@0 arg3))
))) (forall ((m T@U) (x0 T@U) (x1 T@U) (val T@U) ) (! (let (($GenericType__0@@0 (FieldTypeInv0 (type x1))))
 (=> (= (type val) $GenericType__0@@0) (= (MapType0Select (MapType0Store m x0 x1 val) x0 x1) val)))
 :qid |mapAx0:MapType0Select|
 :weight 0
))) (and (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (x1@@0 T@U) (y0 T@U) (y1 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 x1@@0 val@@0) y0 y1) (MapType0Select m@@0 y0 y1)))
 :qid |mapAx1:MapType0Select:0|
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (x1@@1 T@U) (y0@@0 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType0Select (MapType0Store m@@1 x0@@1 x1@@1 val@@1) y0@@0 y1@@0) (MapType0Select m@@1 y0@@0 y1@@0)))
 :qid |mapAx1:MapType0Select:1|
 :weight 0
))) (forall ((val@@2 T@U) (m@@2 T@U) (x0@@2 T@U) (x1@@2 T@U) (y0@@1 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@2 x0@@2 x1@@2 val@@2) y0@@1 y1@@1) (MapType0Select m@@2 y0@@1 y1@@1)))
 :qid |mapAx2:MapType0Select|
 :weight 0
)))) (= (type fixed.$heap@11) (MapType0Type refType))) (= (type fixed.$heap@5) (MapType0Type refType))) (= (type fixed.$heap) (MapType0Type refType))) (forall ((arg0@@13 T@T) (arg1@@2 T@T) ) (! (= (Ctor (MapType1Type arg0@@13 arg1@@2)) 7)
 :qid |ctor:MapType1Type|
))) (forall ((arg0@@14 T@T) (arg1@@3 T@T) ) (! (= (MapType1TypeInv0 (MapType1Type arg0@@14 arg1@@3)) arg0@@14)
 :qid |typeInv:MapType1TypeInv0|
 :pattern ( (MapType1Type arg0@@14 arg1@@3))
))) (forall ((arg0@@15 T@T) (arg1@@4 T@T) ) (! (= (MapType1TypeInv1 (MapType1Type arg0@@15 arg1@@4)) arg1@@4)
 :qid |typeInv:MapType1TypeInv1|
 :pattern ( (MapType1Type arg0@@15 arg1@@4))
))) (forall ((arg0@@16 T@U) (arg1@@5 T@U) ) (! (let ((aVar1 (MapType1TypeInv1 (type arg0@@16))))
(= (type (MapType1Select arg0@@16 arg1@@5)) aVar1))
 :qid |funType:MapType1Select|
 :pattern ( (MapType1Select arg0@@16 arg1@@5))
))) (forall ((arg0@@17 T@U) (arg1@@6 T@U) (arg2@@1 T@U) ) (! (let ((aVar1@@0 (type arg2@@1)))
(let ((aVar0@@0 (type arg1@@6)))
(= (type (MapType1Store arg0@@17 arg1@@6 arg2@@1)) (MapType1Type aVar0@@0 aVar1@@0))))
 :qid |funType:MapType1Store|
 :pattern ( (MapType1Store arg0@@17 arg1@@6 arg2@@1))
))) (forall ((m@@3 T@U) (x0@@3 T@U) (val@@3 T@U) ) (! (let ((aVar1@@1 (MapType1TypeInv1 (type m@@3))))
 (=> (= (type val@@3) aVar1@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) x0@@3) val@@3)))
 :qid |mapAx0:MapType1Select|
 :weight 0
))) (and (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or (= x0@@4 y0@@2) (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :qid |mapAx1:MapType1Select:0|
 :weight 0
)) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (y0@@3 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 val@@5) y0@@3) (MapType1Select m@@5 y0@@3)))
 :qid |mapAx2:MapType1Select|
 :weight 0
)))) (= (type fixed.$arrSizeHeap@0) (MapType1Type refType intType))) (= (type fixed.$arrSizeHeap@1) (MapType1Type refType intType))) (= (type fixed.$intArrHeap@4) (MapType1Type refType (MapType1Type intType intType)))) (= (type fixed.$intArrHeap@9) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0) refType)) (= (type call3formal@$obj@0@@0) refType)) (= (type fixed.$heap@7) (MapType0Type refType))) (= (type fixed.$heap@6) (MapType0Type refType))) (= (type fixed.$intArrHeap) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0@@1) refType)) (= (type fixed.$heap@8) (MapType0Type refType))) (= (type fixed.$intArrHeap@5) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0@@2) refType)) (= (type fixed.$heap@9) (MapType0Type refType))) (= (type fixed.$intArrHeap@6) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0@@3) refType)) (= (type fixed.$heap@10) (MapType0Type refType))) (= (type fixed.$intArrHeap@7) (MapType1Type refType (MapType1Type intType intType)))) (= (type fixed.$intArrHeap@8) (MapType1Type refType (MapType1Type intType intType)))) (= (type fixed.$arrSizeHeap) (MapType1Type refType intType))) (= (type fixed.$stringSizeHeap) (MapType1Type refType intType))) (= (type $in_parameter__0) refType)) (= (type fixed.$intArrayType) javaTypeType)) (= (type call3formal@$obj@0@@4) refType)) (= (type call3formal@$obj@0@@5) refType)) (= (type fixed.$heap@1) (MapType0Type refType))) (= (type fixed.$heap@0) (MapType0Type refType))) (= (type call3formal@$obj@0@@6) refType)) (= (type fixed.$heap@2) (MapType0Type refType))) (= (type fixed.$intArrHeap@0) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0@@7) refType)) (= (type fixed.$heap@3) (MapType0Type refType))) (= (type fixed.$intArrHeap@1) (MapType1Type refType (MapType1Type intType intType)))) (= (type call3formal@$obj@0@@8) refType)) (= (type fixed.$heap@4) (MapType0Type refType))) (= (type fixed.$intArrHeap@2) (MapType1Type refType (MapType1Type intType intType)))) (= (type fixed.$intArrHeap@3) (MapType1Type refType (MapType1Type intType intType)))))
(push 1)
(set-info :boogie-vc-id PROC_.Login$retrieve$java.lang.String_EQ_unsafe__xx__fixed)
(assert (not
(let ((AA_INSTR_EQ_BODY$2_correct  (=> (! (and %lbl%+340826 true) :lblpos +340826) (=> (and (and (and (and (and (and (=> AA_TEMP130@1 (or AA_TEMP130@0 (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 inline$fixed.Login$retrieve$java.lang.String$0$$return@1))) (=> (or AA_TEMP130@0 (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 inline$fixed.Login$retrieve$java.lang.String$0$$return@1)) AA_TEMP130@1)) (and (=> AA_TEMP131@1 (or AA_TEMP131@0 (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 inline$fixed.Login$retrieve$java.lang.String$0$$exception@1))) (=> (or AA_TEMP131@0 (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 inline$fixed.Login$retrieve$java.lang.String$0$$exception@1)) AA_TEMP131@1))) (and (=> AA_TEMP132@1 (or AA_TEMP132@0 (= fixed.$objIndex@10 fixed.$objIndex@10))) (=> (or AA_TEMP132@0 (= fixed.$objIndex@10 fixed.$objIndex@10)) AA_TEMP132@1))) (and (=> AA_TEMP133@1 (or AA_TEMP133@0 (forall ((r T@U) (f T@U) ) (! (let ((_ty (FieldTypeInv0 (type f))))
 (=> (and (= (type r) refType) (= (type f) (FieldType _ty))) (or (= (MapType0Select fixed.$heap@11 r f) (MapType0Select fixed.$heap@5 r f)) (not (U_2_bool (MapType0Select fixed.$heap r fixed.$alloc))))))
 :qid |RSPROCLo.9975:20|
 :skolemid |1966|
 :no-pattern (type r)
 :no-pattern (type f)
 :no-pattern (U_2_int r)
 :no-pattern (U_2_bool r)
 :no-pattern (U_2_int f)
 :no-pattern (U_2_bool f)
)))) (=> (or AA_TEMP133@0 (forall ((r@@0 T@U) (f@@0 T@U) ) (! (let ((_ty@@0 (FieldTypeInv0 (type f@@0))))
 (=> (and (= (type r@@0) refType) (= (type f@@0) (FieldType _ty@@0))) (or (= (MapType0Select fixed.$heap@11 r@@0 f@@0) (MapType0Select fixed.$heap@5 r@@0 f@@0)) (not (U_2_bool (MapType0Select fixed.$heap r@@0 fixed.$alloc))))))
 :qid |RSPROCLo.9975:20|
 :skolemid |1966|
 :no-pattern (type r@@0)
 :no-pattern (type f@@0)
 :no-pattern (U_2_int r@@0)
 :no-pattern (U_2_bool r@@0)
 :no-pattern (U_2_int f@@0)
 :no-pattern (U_2_bool f@@0)
))) AA_TEMP133@1))) (and (=> AA_TEMP134@1 (or (or AA_TEMP134@0 (= fixed.$arrSizeHeap@0 fixed.$arrSizeHeap@1)) (forall ((_x0 T@U) ) (!  (=> (= (type _x0) refType) (= (U_2_int (MapType1Select fixed.$arrSizeHeap@0 _x0)) (U_2_int (MapType1Select fixed.$arrSizeHeap@1 _x0))))
 :qid |RSPROCLo.9979:15|
 :skolemid |1967|
 :no-pattern (type _x0)
 :no-pattern (U_2_int _x0)
 :no-pattern (U_2_bool _x0)
)))) (=> (or (or AA_TEMP134@0 (= fixed.$arrSizeHeap@0 fixed.$arrSizeHeap@1)) (forall ((_x0@@0 T@U) ) (!  (=> (= (type _x0@@0) refType) (= (U_2_int (MapType1Select fixed.$arrSizeHeap@0 _x0@@0)) (U_2_int (MapType1Select fixed.$arrSizeHeap@1 _x0@@0))))
 :qid |RSPROCLo.9979:15|
 :skolemid |1967|
 :no-pattern (type _x0@@0)
 :no-pattern (U_2_int _x0@@0)
 :no-pattern (U_2_bool _x0@@0)
))) AA_TEMP134@1))) (and (=> AA_TEMP135@1 (or AA_TEMP135@0 (= fixed.$intArrHeap@4 fixed.$intArrHeap@9))) (=> (or AA_TEMP135@0 (= fixed.$intArrHeap@4 fixed.$intArrHeap@9)) AA_TEMP135@1))) (! (or %lbl%@348931  (and (and (and (and (and AA_TEMP135@1 AA_TEMP134@1) AA_TEMP133@1) AA_TEMP132@1) AA_TEMP131@1) AA_TEMP130@1)) :lblneg @348931)))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$Return_correct  (=> (! (and %lbl%+340825 true) :lblpos +340825) AA_INSTR_EQ_BODY$2_correct)))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$block11_correct  (=> (! (and %lbl%+340824 true) :lblpos +340824) (=> (= fixed.$heap@11 fixed.$heap@6) (=> (and (and (= fixed.$intArrHeap@9 fixed.$intArrHeap@8) (= fixed.$objIndex@10 fixed.$objIndex@5)) (and (= inline$fixed.Login$retrieve$java.lang.String$0$$return@1 call3formal@$obj@0) (= inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 fixed.$null))) inline$fixed.Login$retrieve$java.lang.String$0$Return_correct)))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon12_correct  (=> (! (and %lbl%+340823 true) :lblpos +340823) (=> (= fixed.$intArrHeap@8 (MapType1Store fixed.$intArrHeap@7 call3formal@$obj@0 (MapType1Store (MapType1Select fixed.$intArrHeap@7 call3formal@$obj@0) (int_2_U 3) (int_2_U 1)))) inline$fixed.Login$retrieve$java.lang.String$0$block11_correct))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon16_Then_correct  (=> (! (and %lbl%+340822 true) :lblpos +340822) (=> (and (< 3 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 3 0)) inline$fixed.Login$retrieve$java.lang.String$0$anon12_correct))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon16_Else_correct  (=> (! (and %lbl%+340821 true) :lblpos +340821) (=> (not (and (< 3 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 3 0))) (=> (and (not (= call3formal@$obj@0@@3 fixed.$null)) (= fixed.$objIndex@9 (+ fixed.$objIndex@5 1))) (=> (and (and (and (= call3formal@$obj@0@@3 (fixed.$intToRef fixed.$objIndex@5)) (= fixed.$heap@10 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@3 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@3 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException))) (and (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@3 fixed.$alloc))) (= fixed.$heap@11 fixed.$heap@10))) (and (and (= fixed.$intArrHeap@9 fixed.$intArrHeap@7) (= fixed.$objIndex@10 fixed.$objIndex@9)) (and (= inline$fixed.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@3)))) inline$fixed.Login$retrieve$java.lang.String$0$Return_correct))))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon9_correct  (=> (! (and %lbl%+340820 true) :lblpos +340820) (=> (= fixed.$intArrHeap@7 (MapType1Store fixed.$intArrHeap@6 call3formal@$obj@0 (MapType1Store (MapType1Select fixed.$intArrHeap@6 call3formal@$obj@0) (int_2_U 2) (int_2_U 15)))) (and inline$fixed.Login$retrieve$java.lang.String$0$anon16_Then_correct inline$fixed.Login$retrieve$java.lang.String$0$anon16_Else_correct)))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon15_Then_correct  (=> (! (and %lbl%+340819 true) :lblpos +340819) (=> (and (< 2 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 2 0)) inline$fixed.Login$retrieve$java.lang.String$0$anon9_correct))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon15_Else_correct  (=> (! (and %lbl%+340818 true) :lblpos +340818) (=> (not (and (< 2 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 2 0))) (=> (and (not (= call3formal@$obj@0@@2 fixed.$null)) (= fixed.$objIndex@8 (+ fixed.$objIndex@5 1))) (=> (and (and (and (= call3formal@$obj@0@@2 (fixed.$intToRef fixed.$objIndex@5)) (= fixed.$heap@9 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@2 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@2 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException))) (and (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@2 fixed.$alloc))) (= fixed.$heap@11 fixed.$heap@9))) (and (and (= fixed.$intArrHeap@9 fixed.$intArrHeap@6) (= fixed.$objIndex@10 fixed.$objIndex@8)) (and (= inline$fixed.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@2)))) inline$fixed.Login$retrieve$java.lang.String$0$Return_correct))))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon6_correct  (=> (! (and %lbl%+340817 true) :lblpos +340817) (=> (= fixed.$intArrHeap@6 (MapType1Store fixed.$intArrHeap@5 call3formal@$obj@0 (MapType1Store (MapType1Select fixed.$intArrHeap@5 call3formal@$obj@0) (int_2_U 1) (int_2_U 3)))) (and inline$fixed.Login$retrieve$java.lang.String$0$anon15_Then_correct inline$fixed.Login$retrieve$java.lang.String$0$anon15_Else_correct)))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon14_Then_correct  (=> (! (and %lbl%+340816 true) :lblpos +340816) (=> (and (< 1 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 1 0)) inline$fixed.Login$retrieve$java.lang.String$0$anon6_correct))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon14_Else_correct  (=> (! (and %lbl%+340815 true) :lblpos +340815) (=> (not (and (< 1 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 1 0))) (=> (and (not (= call3formal@$obj@0@@1 fixed.$null)) (= fixed.$objIndex@7 (+ fixed.$objIndex@5 1))) (=> (and (and (and (= call3formal@$obj@0@@1 (fixed.$intToRef fixed.$objIndex@5)) (= fixed.$heap@8 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@1 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@1 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException))) (and (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@1 fixed.$alloc))) (= fixed.$heap@11 fixed.$heap@8))) (and (and (= fixed.$intArrHeap@9 fixed.$intArrHeap@5) (= fixed.$objIndex@10 fixed.$objIndex@7)) (and (= inline$fixed.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@1)))) inline$fixed.Login$retrieve$java.lang.String$0$Return_correct))))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon3_correct  (=> (! (and %lbl%+340814 true) :lblpos +340814) (=> (= fixed.$intArrHeap@5 (MapType1Store fixed.$intArrHeap call3formal@$obj@0 (MapType1Store (MapType1Select fixed.$intArrHeap call3formal@$obj@0) (int_2_U 0) (int_2_U 10)))) (and inline$fixed.Login$retrieve$java.lang.String$0$anon14_Then_correct inline$fixed.Login$retrieve$java.lang.String$0$anon14_Else_correct)))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon13_Then_correct  (=> (! (and %lbl%+340813 true) :lblpos +340813) (=> (and (< 0 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 0 0)) inline$fixed.Login$retrieve$java.lang.String$0$anon3_correct))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon13_Else_correct  (=> (! (and %lbl%+340812 true) :lblpos +340812) (=> (not (and (< 0 (U_2_int (MapType1Select fixed.$arrSizeHeap@1 call3formal@$obj@0))) (>= 0 0))) (=> (and (not (= call3formal@$obj@0@@0 fixed.$null)) (= fixed.$objIndex@6 (+ fixed.$objIndex@5 1))) (=> (and (and (and (= call3formal@$obj@0@@0 (fixed.$intToRef fixed.$objIndex@5)) (= fixed.$heap@7 (MapType0Store (MapType0Store fixed.$heap@6 call3formal@$obj@0@@0 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@0 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException))) (and (not (U_2_bool (MapType0Select fixed.$heap@6 call3formal@$obj@0@@0 fixed.$alloc))) (= fixed.$heap@11 fixed.$heap@7))) (and (and (= fixed.$intArrHeap@9 fixed.$intArrHeap) (= fixed.$objIndex@10 fixed.$objIndex@6)) (and (= inline$fixed.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$fixed.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@0)))) inline$fixed.Login$retrieve$java.lang.String$0$Return_correct))))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$anon0_correct  (=> (! (and %lbl%+340811 true) :lblpos +340811) (=> (and (forall ((T T@U) ) (!  (=> (= (type T) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T))
 :qid |RSPROCLo.9852:20|
 :skolemid |1963|
 :no-pattern (type T)
 :no-pattern (U_2_int T)
 :no-pattern (U_2_bool T)
)) (forall ((_r T@U) ) (!  (=> (= (type _r) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r)) 0))
 :qid |RSPROCLo.9853:20|
 :skolemid |1964|
 :no-pattern (type _r)
 :no-pattern (U_2_int _r)
 :no-pattern (U_2_bool _r)
))) (=> (and (and (and (forall ((_r@@0 T@U) ) (!  (=> (= (type _r@@0) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@0)) 0))
 :qid |RSPROCLo.9854:20|
 :skolemid |1965|
 :no-pattern (type _r@@0)
 :no-pattern (U_2_int _r@@0)
 :no-pattern (U_2_bool _r@@0)
)) (UOrdering2 (MapType0Select fixed.$heap $in_parameter__0 fixed.$type) fixed.java.lang.String)) (and (not (= call3formal@$obj@0 fixed.$null)) (= fixed.$objIndex@5 (+ fixed.$objIndex 1)))) (and (and (= call3formal@$obj@0 (fixed.$intToRef fixed.$objIndex)) (= fixed.$heap@6 (MapType0Store (MapType0Store fixed.$heap call3formal@$obj@0 fixed.$alloc (bool_2_U true)) call3formal@$obj@0 fixed.$type fixed.$intArrayType))) (and (not (U_2_bool (MapType0Select fixed.$heap call3formal@$obj@0 fixed.$alloc))) (= fixed.$arrSizeHeap@1 (MapType1Store fixed.$arrSizeHeap call3formal@$obj@0 (int_2_U 4)))))) (and inline$fixed.Login$retrieve$java.lang.String$0$anon13_Then_correct inline$fixed.Login$retrieve$java.lang.String$0$anon13_Else_correct))))))
(let ((inline$fixed.Login$retrieve$java.lang.String$0$Entry_correct  (=> (! (and %lbl%+340810 true) :lblpos +340810) inline$fixed.Login$retrieve$java.lang.String$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY$1_correct  (=> (! (and %lbl%+340809 true) :lblpos +340809) inline$fixed.Login$retrieve$java.lang.String$0$Entry_correct)))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct  (=> (! (and %lbl%+340808 true) :lblpos +340808) AA_INSTR_EQ_BODY$1_correct)))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$block11_correct  (=> (! (and %lbl%+340807 true) :lblpos +340807) (=> (and (and (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 call3formal@$obj@0@@4) (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 fixed.$null)) (and (= fixed.$heap@5 fixed.$heap@0) (= fixed.$intArrHeap@4 fixed.$intArrHeap@3))) inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon12_correct  (=> (! (and %lbl%+340806 true) :lblpos +340806) (=> (= fixed.$intArrHeap@3 (MapType1Store fixed.$intArrHeap@2 call3formal@$obj@0@@4 (MapType1Store (MapType1Select fixed.$intArrHeap@2 call3formal@$obj@0@@4) (int_2_U 3) (int_2_U 1)))) inline$unsafe.Login$retrieve$java.lang.String$0$block11_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon16_Then_correct  (=> (! (and %lbl%+340805 true) :lblpos +340805) (=> (and (< 3 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 3 0)) inline$unsafe.Login$retrieve$java.lang.String$0$anon12_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon16_Else_correct  (=> (! (and %lbl%+340804 true) :lblpos +340804) (=> (and (not (and (< 3 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 3 0))) (not (= call3formal@$obj@0@@8 fixed.$null))) (=> (and (and (and (= fixed.$objIndex@4 (+ fixed.$objIndex@0 1)) (= call3formal@$obj@0@@8 (fixed.$intToRef fixed.$objIndex@0))) (and (= fixed.$heap@4 (MapType0Store (MapType0Store fixed.$heap@0 call3formal@$obj@0@@8 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@8 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException)) (not (U_2_bool (MapType0Select fixed.$heap@0 call3formal@$obj@0@@8 fixed.$alloc))))) (and (and (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@8)) (and (= fixed.$heap@5 fixed.$heap@4) (= fixed.$intArrHeap@4 fixed.$intArrHeap@2)))) inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon9_correct  (=> (! (and %lbl%+340803 true) :lblpos +340803) (=> (= fixed.$intArrHeap@2 (MapType1Store fixed.$intArrHeap@1 call3formal@$obj@0@@4 (MapType1Store (MapType1Select fixed.$intArrHeap@1 call3formal@$obj@0@@4) (int_2_U 2) (int_2_U 15)))) (and inline$unsafe.Login$retrieve$java.lang.String$0$anon16_Then_correct inline$unsafe.Login$retrieve$java.lang.String$0$anon16_Else_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon15_Then_correct  (=> (! (and %lbl%+340802 true) :lblpos +340802) (=> (and (< 2 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 2 0)) inline$unsafe.Login$retrieve$java.lang.String$0$anon9_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon15_Else_correct  (=> (! (and %lbl%+340801 true) :lblpos +340801) (=> (and (not (and (< 2 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 2 0))) (not (= call3formal@$obj@0@@7 fixed.$null))) (=> (and (and (and (= fixed.$objIndex@3 (+ fixed.$objIndex@0 1)) (= call3formal@$obj@0@@7 (fixed.$intToRef fixed.$objIndex@0))) (and (= fixed.$heap@3 (MapType0Store (MapType0Store fixed.$heap@0 call3formal@$obj@0@@7 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@7 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException)) (not (U_2_bool (MapType0Select fixed.$heap@0 call3formal@$obj@0@@7 fixed.$alloc))))) (and (and (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@7)) (and (= fixed.$heap@5 fixed.$heap@3) (= fixed.$intArrHeap@4 fixed.$intArrHeap@1)))) inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon6_correct  (=> (! (and %lbl%+340800 true) :lblpos +340800) (=> (= fixed.$intArrHeap@1 (MapType1Store fixed.$intArrHeap@0 call3formal@$obj@0@@4 (MapType1Store (MapType1Select fixed.$intArrHeap@0 call3formal@$obj@0@@4) (int_2_U 1) (int_2_U 3)))) (and inline$unsafe.Login$retrieve$java.lang.String$0$anon15_Then_correct inline$unsafe.Login$retrieve$java.lang.String$0$anon15_Else_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon14_Then_correct  (=> (! (and %lbl%+340799 true) :lblpos +340799) (=> (and (< 1 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 1 0)) inline$unsafe.Login$retrieve$java.lang.String$0$anon6_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon14_Else_correct  (=> (! (and %lbl%+340798 true) :lblpos +340798) (=> (and (not (and (< 1 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 1 0))) (not (= call3formal@$obj@0@@6 fixed.$null))) (=> (and (and (and (= fixed.$objIndex@2 (+ fixed.$objIndex@0 1)) (= call3formal@$obj@0@@6 (fixed.$intToRef fixed.$objIndex@0))) (and (= fixed.$heap@2 (MapType0Store (MapType0Store fixed.$heap@0 call3formal@$obj@0@@6 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@6 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException)) (not (U_2_bool (MapType0Select fixed.$heap@0 call3formal@$obj@0@@6 fixed.$alloc))))) (and (and (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@6)) (and (= fixed.$heap@5 fixed.$heap@2) (= fixed.$intArrHeap@4 fixed.$intArrHeap@0)))) inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon3_correct  (=> (! (and %lbl%+340797 true) :lblpos +340797) (=> (= fixed.$intArrHeap@0 (MapType1Store fixed.$intArrHeap call3formal@$obj@0@@4 (MapType1Store (MapType1Select fixed.$intArrHeap call3formal@$obj@0@@4) (int_2_U 0) (int_2_U 10)))) (and inline$unsafe.Login$retrieve$java.lang.String$0$anon14_Then_correct inline$unsafe.Login$retrieve$java.lang.String$0$anon14_Else_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon13_Then_correct  (=> (! (and %lbl%+340796 true) :lblpos +340796) (=> (and (< 0 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 0 0)) inline$unsafe.Login$retrieve$java.lang.String$0$anon3_correct))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon13_Else_correct  (=> (! (and %lbl%+340795 true) :lblpos +340795) (=> (and (not (and (< 0 (U_2_int (MapType1Select fixed.$arrSizeHeap@0 call3formal@$obj@0@@4))) (>= 0 0))) (not (= call3formal@$obj@0@@5 fixed.$null))) (=> (and (and (and (= fixed.$objIndex@1 (+ fixed.$objIndex@0 1)) (= call3formal@$obj@0@@5 (fixed.$intToRef fixed.$objIndex@0))) (and (= fixed.$heap@1 (MapType0Store (MapType0Store fixed.$heap@0 call3formal@$obj@0@@5 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@5 fixed.$type fixed.java.lang.ArrayIndexOutOfBoundsException)) (not (U_2_bool (MapType0Select fixed.$heap@0 call3formal@$obj@0@@5 fixed.$alloc))))) (and (and (= inline$unsafe.Login$retrieve$java.lang.String$0$$return@1 fixed.$null) (= inline$unsafe.Login$retrieve$java.lang.String$0$$exception@1 call3formal@$obj@0@@5)) (and (= fixed.$heap@5 fixed.$heap@1) (= fixed.$intArrHeap@4 fixed.$intArrHeap)))) inline$unsafe.Login$retrieve$java.lang.String$0$Return_correct)))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$anon0_correct  (=> (! (and %lbl%+340794 true) :lblpos +340794) (=> (and (forall ((T@@0 T@U) ) (!  (=> (= (type T@@0) javaTypeType) (UOrdering2 (MapType0Select fixed.$heap fixed.$null fixed.$type) T@@0))
 :qid |RSPROCLo.9721:20|
 :skolemid |1960|
 :no-pattern (type T@@0)
 :no-pattern (U_2_int T@@0)
 :no-pattern (U_2_bool T@@0)
)) (forall ((_r@@1 T@U) ) (!  (=> (= (type _r@@1) refType) (>= (U_2_int (MapType1Select fixed.$arrSizeHeap _r@@1)) 0))
 :qid |RSPROCLo.9722:20|
 :skolemid |1961|
 :no-pattern (type _r@@1)
 :no-pattern (U_2_int _r@@1)
 :no-pattern (U_2_bool _r@@1)
))) (=> (and (and (and (forall ((_r@@2 T@U) ) (!  (=> (= (type _r@@2) refType) (>= (U_2_int (MapType1Select fixed.$stringSizeHeap _r@@2)) 0))
 :qid |RSPROCLo.9723:20|
 :skolemid |1962|
 :no-pattern (type _r@@2)
 :no-pattern (U_2_int _r@@2)
 :no-pattern (U_2_bool _r@@2)
)) (UOrdering2 (MapType0Select fixed.$heap $in_parameter__0 fixed.$type) fixed.java.lang.String)) (and (not (= call3formal@$obj@0@@4 fixed.$null)) (= fixed.$objIndex@0 (+ fixed.$objIndex 1)))) (and (and (= call3formal@$obj@0@@4 (fixed.$intToRef fixed.$objIndex)) (= fixed.$heap@0 (MapType0Store (MapType0Store fixed.$heap call3formal@$obj@0@@4 fixed.$alloc (bool_2_U true)) call3formal@$obj@0@@4 fixed.$type fixed.$intArrayType))) (and (not (U_2_bool (MapType0Select fixed.$heap call3formal@$obj@0@@4 fixed.$alloc))) (= fixed.$arrSizeHeap@0 (MapType1Store fixed.$arrSizeHeap call3formal@$obj@0@@4 (int_2_U 4)))))) (and inline$unsafe.Login$retrieve$java.lang.String$0$anon13_Then_correct inline$unsafe.Login$retrieve$java.lang.String$0$anon13_Else_correct))))))
(let ((inline$unsafe.Login$retrieve$java.lang.String$0$Entry_correct  (=> (! (and %lbl%+340793 true) :lblpos +340793) inline$unsafe.Login$retrieve$java.lang.String$0$anon0_correct)))
(let ((AA_INSTR_EQ_BODY_correct  (=> (! (and %lbl%+340792 true) :lblpos +340792) inline$unsafe.Login$retrieve$java.lang.String$0$Entry_correct)))
(let ((q@0_correct  (=> (! (and %lbl%+346185 true) :lblpos +346185) AA_INSTR_EQ_BODY_correct)))
(let ((PreconditionGeneratedEntry_correct  (=> (! (and %lbl%+346194 true) :lblpos +346194) q@0_correct)))
PreconditionGeneratedEntry_correct)))))))))))))))))))))))))))))))))))))
))
(check-sat)
(pop 1)
; Valid
